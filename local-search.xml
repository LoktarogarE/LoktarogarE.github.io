<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>About Homomorphic encryption, MPC &amp; Crypten</title>
    <link href="/2022/03/08/About-Homomorphic-encryption,-MPC-&amp;-Crypten/"/>
    <url>/2022/03/08/About-Homomorphic-encryption,-MPC-&amp;-Crypten/</url>
    
    <content type="html"><![CDATA[<h1 id="About-Homomorphic-Encryption-MPC-amp-Crypten"><a href="#About-Homomorphic-Encryption-MPC-amp-Crypten" class="headerlink" title="About Homomorphic Encryption, MPC &amp; Crypten"></a>About Homomorphic Encryption, MPC &amp; Crypten</h1><h3 id="homomorphic-encrytion"><a href="#homomorphic-encrytion" class="headerlink" title="homomorphic encrytion"></a><a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86">homomorphic encrytion</a></h3><p>对密文进行特定形式的代数运算后 仍然是加密的结果，这样解密得到的结果和明文进行同样的运算结果一样。 也就是说，这项技术能够在 数据加密的情况下进行诸如 检索、比较等操作，并且得出正确的结果。  这项技术的意义就是从根本上解决数据被委托给第三方时的保密问题。  </p><p>同态加密在以往都只能实现部分操作，全同态加密的可行性是由09年 斯坦福大学的 Craig Gentry 的 <a href="https://www.cs.cmu.edu/~odonnell/hits09/gentry-homomorphic-encryption.pdf">《Fully Homomorphic encryption Using Ideal Lattices》</a>一文中，从数学角度上证明了全同态加密的可行性。</p><hr><h3 id="MPC-Secure-multi-party-computation"><a href="#MPC-Secure-multi-party-computation" class="headerlink" title="MPC   Secure multi-party computation"></a>MPC   Secure multi-party computation</h3><ul><li><p>MPC 用到的三种安全模型： 理想模型(全是好人) ，半诚实模型(不破坏规则，但会推理出额外信息)，恶意模型</p></li><li><p>在无可信第三方的情况下，如何安全的计算一个约定函数(这可能有点像diffie Hellman)</p></li><li><p>Zero-Knowledge Proof 不向验证者提供有效信息的情况下使验证者相信你的论断</p></li><li><p>differential privacy 差分隐私 「利用噪声来实现安全(计算上安全)，而非加密手段」</p></li></ul><p>可以拿出以下这个例子： 两个百万富翁比财产(他们不想让任何人知道自己有多少钱)</p><p>假设两人的财富都是1kw ～ 10kw  拿来10个编号的箱子，编号代表kw数(比如3kw 就是3号箱)，甲会对这10个箱子，每一个的编号对应的钱数 少于自己的 放入苹果，和自己一样的，放入香蕉，多于自己的，放入梨。 然后将10个箱子寄给乙。 乙选出自己对应财富的箱子，并销毁其他的箱子和编号。  这时打开箱子，甲和乙就能知道谁更富有。</p><p>「这个例子 基于半诚实模型，同时也有<code>不经意传输 Obivious Transfer</code>的影子, 即发送方向接收方发送信息中的一个部分，接收方可以正确的接收到信息，但不知道这个信息属于整体的哪个部分」</p><h4 id="MPC的两种应用形式：-外包计算-x2F-多方计算-此处望文生义即可"><a href="#MPC的两种应用形式：-外包计算-x2F-多方计算-此处望文生义即可" class="headerlink" title="MPC的两种应用形式： 外包计算 &#x2F; 多方计算    此处望文生义即可"></a>MPC的两种应用形式： 外包计算 &#x2F; 多方计算    此处望文生义即可</h4><hr><h3 id="Crypten-「Privacy-Preserving-Machine-Learning」"><a href="#Crypten-「Privacy-Preserving-Machine-Learning」" class="headerlink" title="Crypten  「Privacy Preserving Machine Learning」"></a><a href="https://crypten.readthedocs.io/en/latest/">Crypten</a>  「Privacy Preserving Machine Learning」</h3><ul><li>目前是实验用，只支持MAC和Linux系统，不支持Windows和GPU训练</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Cryptography</tag>
      
      <tag>Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机技术杂谈</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机技术杂谈"><a href="#计算机技术杂谈" class="headerlink" title="计算机技术杂谈"></a>计算机技术杂谈</h1><h3 id="大数据与云计算"><a href="#大数据与云计算" class="headerlink" title="大数据与云计算"></a>大数据与云计算</h3><p>大数据不是数据存储技术，而是和海量数据相关的抽取、集成、管理、分析、解释方法，是一个庞大的框架系统。宏观上讲，对数据进行映射和提炼，发现其数据特征并加以利用。从技术上说，是通过<strong>获取、存储、分析，从大容量数据里挖掘价值的</strong>技术架构。</p><p>大数据的量级在 PB(1024TB)或者EB级，其关键特点有 Volume(量)、Variety、**Velocity(时效性短)**、Value(价值密度低)</p><p>云计算：这种基于互联网的计算方式，可以更好的对软硬计算资源进行整合，在我看来，这个概念有些类似操作系统中提供虚拟化资源的概念，相当于是面向互联网计算的虚拟计算环境，使用户能够方便、有效地共享和利用网络上的资源</p><hr><h3 id="前端-amp-后端"><a href="#前端-amp-后端" class="headerlink" title="前端 &amp; 后端"></a>前端 &amp; 后端</h3><ul><li>广义上说，任何和UI直接相关的工作，都属于前端，狭义上讲，前端就是网页端</li><li>后端 是具体实现功能的地方，<strong>并且负责关键的 状态维护 和 控制权限</strong>，这些控制机制不能被放在前端</li></ul><h3 id="JavaScript，CSS与HTML的关系"><a href="#JavaScript，CSS与HTML的关系" class="headerlink" title="JavaScript，CSS与HTML的关系"></a>JavaScript，CSS与HTML的关系</h3><ul><li><strong>HTML定义页面结构和核心内容，CSS则为这些内容加上样式，JS则可以同时做到这两件事。</strong><ul><li>抽象的说，html是骨，负责将信息结构化，CSS则是肉，负责添加装饰性内容</li><li>CSS可以更简单的完成一些html完成很麻烦的工作，比如将所有的标题居中。</li></ul></li><li>JS可以完成html和css的工作，但复杂一些，其主要功能是 <strong>指导浏览器如何动态建立结构和作用样式，也就是负责控制逻辑</strong></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Computation tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Brief Introduction to Artificial Intelligence</title>
    <link href="/2022/03/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    <url>/2022/03/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="机器学习的常见算法"><a href="#机器学习的常见算法" class="headerlink" title="机器学习的常见算法"></a>机器学习的常见算法</h3><ul><li>supervised learning &amp; unsupervised learning 「main」</li><li>Reinforcement learning，recommender systems</li></ul><h3 id="机器学习的三大问题"><a href="#机器学习的三大问题" class="headerlink" title="机器学习的三大问题"></a>机器学习的三大问题</h3><h4 id="regression-problem-回归问题"><a href="#regression-problem-回归问题" class="headerlink" title="regression problem 回归问题"></a>regression problem 回归问题</h4><ul><li>样本由离散的点构成，我们需要利用模型来拟合它，从而对连续的每个值都给出预测</li><li>常见情况下 模型分为：linear model 和 polynomial model 两种</li><li><img src="/Users/natsumi/Library/Application Support/typora-user-images/image-20220114193515388.png" alt="image-20220114193515388" style="zoom:50%;" /></li></ul><h4 id="classification-problem-分类问题"><a href="#classification-problem-分类问题" class="headerlink" title="classification problem 分类问题"></a>classification problem 分类问题</h4><ul><li>和回归问题不同的地方在于 其产出是离散的 常见情况是 下判断</li></ul><h4 id="Clustering-problem-聚类问题"><a href="#Clustering-problem-聚类问题" class="headerlink" title="Clustering problem 聚类问题"></a>Clustering problem 聚类问题</h4><h3 id="Three-Basic-ML-method"><a href="#Three-Basic-ML-method" class="headerlink" title="Three Basic ML method"></a>Three Basic ML method</h3><p>Supervised Learning 「给出正确的答案，算法的目的是产生更多正确答案」</p><ul><li>a data set with right answers given,  the task of the algorithm is to <strong>produce more of these right answers.</strong> </li><li>由监督学习引出的两种问题是 分类问题和回归问题(两者的区别在连续和离散)</li><li>强监督和弱监督  如果你对每组数据都给出完整、正确的标签，那么就是强监督学习 <ul><li>弱监督学习分为三类： 「周志华老师  A brief Introduction to Weakly Supervised Learning」   这三类并非我们人为选择，而是在实际操作中可能会同时发生的。<ul><li><p>Incomplete su 不完全监督： 只对一部分数据给出label</p><ul><li>解决方案： <ul><li>Active L 主动学习 &#x3D;&gt; 先训练标注过的数据，剩下的自动查询。 有人工干预</li><li>Semi-su L半监督学习 &#x3D;&gt; 观察未被标注的数据分布，比如说在一个positive和一个negative中间的，如果他附近的样本点很多为正，那么可以认为它大概率为正</li></ul></li></ul></li><li><p>Inexact su 不确切监督：给出的标签是粗粒度的，一个包里的示例只给了一个标签</p><ul><li>解决方案：<ul><li>Multi-instance L 多实例学习 &#x3D;&gt; 实际上几乎所有机器学习算法都有其多实例对等体，这个的应用非常广泛</li></ul></li></ul></li><li><p>Inaccurate su不精确监督： 给出的标签可能有错误</p><ul><li>解决方案：<ul><li>L with label noise 带噪学习 &#x3D;&gt; 基本思想是 识别潜在的误分类样本然后修正。在系统中建立相邻关系表，如果某个点和其相邻的点不同，它就可能被判定为可疑点，系统可能会将其删除或重新标记</li></ul></li></ul></li></ul></li></ul></li></ul><p>Unsupervised Learning 「数据不含标签，算法的目的是找到数据中的结构 我们不知道正确答案」</p><ul><li>a data set with no labels, the task of the algorithm is to find some structure in the data, the key is we don’t know how to divide the data in advance.<ul><li>cluster algorithm (organize computing clusters or social network analysis)</li><li>cocktail party problem</li></ul></li><li>由非监督学习引出的问题则是 聚类问题，将训练数据分成几个类，自己去寻找结构</li></ul><p>Reinforcement learning  RL</p><p>强调探索和利用的平衡，通过某种奖惩机制刺激，逐步产生获得最大利益的习惯性行为。</p><hr><p>周志华 🍉📖 index</p><figure class="highlight elixir"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></div></td><td class="code"><pre><code class="hljs elixir">目录<br>第<span class="hljs-number">1</span>章 <span class="hljs-number">1</span><br><span class="hljs-number">1.1</span> 引言 <span class="hljs-number">1</span><br><span class="hljs-number">1.2</span> 基本术 <span class="hljs-number">2</span><br><span class="hljs-number">1.3</span> 假设空间 <span class="hljs-number">4</span><br><span class="hljs-number">1.4</span> 归纳偏好 <span class="hljs-number">6</span><br><span class="hljs-number">1.5</span> 发展历程 <span class="hljs-number">10</span><br><span class="hljs-number">1.6</span> 应用现状 <span class="hljs-number">13</span><br><span class="hljs-number">1.7</span> 阅读材料 <span class="hljs-number">16</span><br>习题 <span class="hljs-number">19</span><br>参考文献 <span class="hljs-number">20</span><br>休息一会儿 <span class="hljs-number">22</span><br>第<span class="hljs-number">2</span>章 模型评估与选择 <span class="hljs-number">23</span><br><span class="hljs-number">2.1</span> 经验误差与过拟合 <span class="hljs-number">23</span><br><span class="hljs-number">2.2</span> 评估方法 <span class="hljs-number">24</span><br><span class="hljs-number">2.2</span>.<span class="hljs-number">1</span> 留出法 <span class="hljs-number">25</span><br><span class="hljs-number">2.2</span>.<span class="hljs-number">2</span> 交叉验证法 <span class="hljs-number">26</span><br><span class="hljs-number">2.2</span>.<span class="hljs-number">3</span> 自助法 <span class="hljs-number">27</span><br><span class="hljs-number">2.2</span>.<span class="hljs-number">4</span> 调参与最终模型 <span class="hljs-number">28</span><br><span class="hljs-number">2.3</span> 性能度量 <span class="hljs-number">28</span><br><span class="hljs-number">2.3</span>.<span class="hljs-number">1</span> 错误率与精度 <span class="hljs-number">29</span><br><span class="hljs-number">2.3</span>.<span class="hljs-number">2</span> 查准率、查全率与F1 <span class="hljs-number">30</span><br><span class="hljs-number">2.3</span>.<span class="hljs-number">3</span> ROC与AUC <span class="hljs-number">33</span><br><span class="hljs-number">2.3</span>.<span class="hljs-number">4</span> 代价敏感错误率与代价曲线 <span class="hljs-number">35</span><br><span class="hljs-number">2.4</span> 比较检验 <span class="hljs-number">37</span><br><span class="hljs-number">2.4</span>.<span class="hljs-number">1</span> 假设检验 <span class="hljs-number">37</span><br><span class="hljs-number">2.4</span>.<span class="hljs-number">2</span> 交叉验证t检验 <span class="hljs-number">40</span><br><span class="hljs-number">2.4</span>.<span class="hljs-number">3</span> McNemar检验 <span class="hljs-number">41</span><br><span class="hljs-number">2.4</span>.<span class="hljs-number">4</span> Friedman检验与后续检验<span class="hljs-number">42</span><br><span class="hljs-number">2.5</span> 偏差与方差 <span class="hljs-number">44</span><br><span class="hljs-number">2.6</span> 阅读材料 <span class="hljs-number">46</span><br>习题 <span class="hljs-number">48</span><br>参考文献 <span class="hljs-number">49</span><br>休息一会儿 <span class="hljs-number">51</span><br>第<span class="hljs-number">3</span>章 线性模型 <span class="hljs-number">53</span><br><span class="hljs-number">3.1</span> 基本形式 <span class="hljs-number">53</span><br><span class="hljs-number">3.2</span> 线性回归 <span class="hljs-number">53</span><br><span class="hljs-number">3.3</span> 对数几率回归 <span class="hljs-number">57</span><br><span class="hljs-number">3.4</span> 线性判别分析 <span class="hljs-number">60</span><br><span class="hljs-number">3.5</span> 多分类学习 <span class="hljs-number">63</span><br><span class="hljs-number">3.6</span> 类别不平衡问题 <span class="hljs-number">66</span><br><span class="hljs-number">3.7</span> 阅读材料 <span class="hljs-number">67</span><br>习题 <span class="hljs-number">69</span><br>参考文献 <span class="hljs-number">70</span><br>休息一会儿 <span class="hljs-number">72</span><br>第<span class="hljs-number">4</span>章 决策树 <span class="hljs-number">73</span><br><span class="hljs-number">4.1</span> 基本流程 <span class="hljs-number">73</span><br><span class="hljs-number">4.2</span> 划分选择 <span class="hljs-number">75</span><br><span class="hljs-number">4.2</span>.<span class="hljs-number">1</span> 信息增益 <span class="hljs-number">75</span><br><span class="hljs-number">4.2</span>.<span class="hljs-number">2</span> 增益率 <span class="hljs-number">77</span><br><span class="hljs-number">4.2</span>.<span class="hljs-number">3</span> 基尼指数 <span class="hljs-number">79</span><br><span class="hljs-number">4.3</span> 剪枝处理 <span class="hljs-number">79</span><br><span class="hljs-number">4.3</span>.<span class="hljs-number">1</span> 预剪枝 <span class="hljs-number">80</span><br><span class="hljs-number">4.3</span>.<span class="hljs-number">2</span> 后剪枝 <span class="hljs-number">82</span><br><span class="hljs-number">4.4</span> 连续与缺失值 <span class="hljs-number">83</span><br><span class="hljs-number">4.4</span>.<span class="hljs-number">1</span> 连续值处理 <span class="hljs-number">83</span><br><span class="hljs-number">4.4</span>.<span class="hljs-number">2</span> 缺失值处理 <span class="hljs-number">85</span><br><span class="hljs-number">4.5</span> 多变量决策树 <span class="hljs-number">88</span><br><span class="hljs-number">4.6</span> 阅读材料 <span class="hljs-number">92</span><br>习题 <span class="hljs-number">93</span><br>参考文献 <span class="hljs-number">94</span><br>休息一会儿 <span class="hljs-number">95</span><br>第<span class="hljs-number">5</span>章 神经网络 <span class="hljs-number">97</span><br><span class="hljs-number">5.1</span> 神经元模型 <span class="hljs-number">97</span><br><span class="hljs-number">5.2</span> 感知机与多层网络 <span class="hljs-number">98</span><br><span class="hljs-number">5.3</span> 误差逆传播算法 <span class="hljs-number">101</span><br><span class="hljs-number">5.4</span> 全局最小与局部极小 <span class="hljs-number">106</span><br><span class="hljs-number">5.5</span> 其他常见神经网络 <span class="hljs-number">108</span><br><span class="hljs-number">5.5</span>.<span class="hljs-number">1</span> RBF网络 <span class="hljs-number">108</span><br><span class="hljs-number">5.5</span>.<span class="hljs-number">2</span> ART网络 <span class="hljs-number">108</span><br><span class="hljs-number">5.5</span>.<span class="hljs-number">3</span> SOM网络 <span class="hljs-number">109</span><br><span class="hljs-number">5.5</span>.<span class="hljs-number">4</span> 级联相关网络 <span class="hljs-number">110</span><br><span class="hljs-number">5.5</span>.<span class="hljs-number">5</span> Elman网络 <span class="hljs-number">111</span><br><span class="hljs-number">5.5</span>.<span class="hljs-number">6</span> Boltzmann机 <span class="hljs-number">111</span><br><span class="hljs-number">5.6</span> 深度学习 <span class="hljs-number">113</span><br><span class="hljs-number">5.7</span> 阅读材料 <span class="hljs-number">115</span><br>习题 <span class="hljs-number">116</span><br>参考文献 <span class="hljs-number">117</span><br>休息一会儿 <span class="hljs-number">120</span><br>第<span class="hljs-number">6</span>章 支持向量机 <span class="hljs-number">121</span><br><span class="hljs-number">6.1</span> 间隔与支持向量 <span class="hljs-number">121</span><br><span class="hljs-number">6.2</span> 对偶问题 <span class="hljs-number">123</span><br><span class="hljs-number">6.3</span> 核函数 <span class="hljs-number">126</span><br><span class="hljs-number">6.4</span> 软间隔与正则化 <span class="hljs-number">129</span><br><span class="hljs-number">6.5</span> 支持向量回归 <span class="hljs-number">133</span><br><span class="hljs-number">6.6</span> 核方法 <span class="hljs-number">137</span><br><span class="hljs-number">6.7</span> 阅读材料 <span class="hljs-number">139</span><br>习题 <span class="hljs-number">141</span><br>参考文献 <span class="hljs-number">142</span><br>休息一会儿 <span class="hljs-number">145</span><br>第<span class="hljs-number">7</span>章 贝叶斯分类器 <span class="hljs-number">147</span><br><span class="hljs-number">7.1</span> 贝叶斯决策论 <span class="hljs-number">147</span><br><span class="hljs-number">7.2</span> 极大似然估计 <span class="hljs-number">149</span><br><span class="hljs-number">7.3</span> 朴素贝叶斯分类器 <span class="hljs-number">150</span><br><span class="hljs-number">7.4</span> 半朴素贝叶斯分类器 <span class="hljs-number">154</span><br><span class="hljs-number">7.5</span> 贝叶斯网 <span class="hljs-number">156</span><br><span class="hljs-number">7.5</span>.<span class="hljs-number">1</span> 结构 <span class="hljs-number">157</span><br><span class="hljs-number">7.5</span>.<span class="hljs-number">2</span> 学习 <span class="hljs-number">159</span><br><span class="hljs-number">7.5</span>.<span class="hljs-number">3</span> 推断 <span class="hljs-number">161</span><br><span class="hljs-number">7.6</span> EM算法 <span class="hljs-number">162</span><br><span class="hljs-number">7.7</span> 阅读材料 <span class="hljs-number">164</span><br>习题 <span class="hljs-number">166</span><br>参考文献 <span class="hljs-number">167</span><br>休息一会儿 <span class="hljs-number">169</span><br>第<span class="hljs-number">8</span>章 集成学习 <span class="hljs-number">171</span><br><span class="hljs-number">8.1</span> 个体与集成 <span class="hljs-number">171</span><br><span class="hljs-number">8.2</span> Boosting <span class="hljs-number">173</span><br><span class="hljs-number">8.3</span> Bagging与随机森林 <span class="hljs-number">178</span><br><span class="hljs-number">8.3</span>.<span class="hljs-number">1</span> Bagging <span class="hljs-number">178</span><br><span class="hljs-number">8.3</span>.<span class="hljs-number">2</span> 随机森林 <span class="hljs-number">179</span><br><span class="hljs-number">8.4</span> 结合策略 <span class="hljs-number">181</span><br><span class="hljs-number">8.4</span>.<span class="hljs-number">1</span> 平均法 <span class="hljs-number">181</span><br><span class="hljs-number">8.4</span>.<span class="hljs-number">2</span> 投票法 <span class="hljs-number">182</span><br><span class="hljs-number">8.4</span>.<span class="hljs-number">3</span> 学习法 <span class="hljs-number">183</span><br><span class="hljs-number">8.5</span> 多样性 <span class="hljs-number">185</span><br><span class="hljs-number">8.5</span>.<span class="hljs-number">1</span> 误差--分歧分解 <span class="hljs-number">185</span><br><span class="hljs-number">8.5</span>.<span class="hljs-number">2</span> 多样性度量 <span class="hljs-number">186</span><br><span class="hljs-number">8.5</span>.<span class="hljs-number">3</span> 多样性增强 <span class="hljs-number">188</span><br><span class="hljs-number">8.6</span> 阅读材料 <span class="hljs-number">190</span><br>习题 <span class="hljs-number">192</span><br>参考文献 <span class="hljs-number">193</span><br>休息一会儿 <span class="hljs-number">196</span><br>第<span class="hljs-number">9</span>章 聚类 <span class="hljs-number">197</span><br><span class="hljs-number">9.1</span> 聚类任务 <span class="hljs-number">197</span><br><span class="hljs-number">9.2</span> 性能度量 <span class="hljs-number">197</span><br><span class="hljs-number">9.3</span> 距离计算 <span class="hljs-number">199</span><br><span class="hljs-number">9.4</span> 原型聚类 <span class="hljs-number">202</span><br><span class="hljs-number">9.4</span>.<span class="hljs-number">1</span> k均值算法 <span class="hljs-number">202</span><br><span class="hljs-number">9.4</span>.<span class="hljs-number">2</span> 学习向量量化 <span class="hljs-number">204</span><br><span class="hljs-number">9.4</span>.<span class="hljs-number">3</span> 高斯混合聚类 <span class="hljs-number">206</span><br><span class="hljs-number">9.5</span> 密度聚类 <span class="hljs-number">211</span><br><span class="hljs-number">9.6</span> 层次聚类 <span class="hljs-number">214</span><br><span class="hljs-number">9.7</span> 阅读材料 <span class="hljs-number">217</span><br>习题 <span class="hljs-number">220</span><br>参考文献 <span class="hljs-number">221</span><br>休息一会儿 <span class="hljs-number">224</span><br>第<span class="hljs-number">10</span>章 降维与度量学习 <span class="hljs-number">225</span><br><span class="hljs-number">10.1</span> k近邻学习 <span class="hljs-number">225</span><br><span class="hljs-number">10.2</span> 低维嵌入 <span class="hljs-number">226</span><br><span class="hljs-number">10.3</span> 主成分分析 <span class="hljs-number">229</span><br><span class="hljs-number">10.4</span> 核化线性降维 <span class="hljs-number">232</span><br><span class="hljs-number">10.5</span> 流形学习 <span class="hljs-number">234</span><br><span class="hljs-number">10.5</span>.<span class="hljs-number">1</span> 等度量映射 <span class="hljs-number">234</span><br><span class="hljs-number">10.5</span>.<span class="hljs-number">2</span> 局部线性嵌入 <span class="hljs-number">235</span><br><span class="hljs-number">10.6</span> 度量学习 <span class="hljs-number">237</span><br><span class="hljs-number">10.7</span> 阅读材料 <span class="hljs-number">240</span><br>习题 <span class="hljs-number">242</span><br>参考文献 <span class="hljs-number">243</span><br>休息一会儿 <span class="hljs-number">246</span><br>第<span class="hljs-number">11</span>章 特征选择与稀疏学习 <span class="hljs-number">247</span><br><span class="hljs-number">11.1</span> 子集搜索与评价 <span class="hljs-number">247</span><br><span class="hljs-number">11.2</span> 过滤式选择 <span class="hljs-number">249</span><br><span class="hljs-number">11.3</span> 包裹式选择 <span class="hljs-number">250</span><br><span class="hljs-number">11.4</span> 嵌入式选择与L<span class="hljs-variable">$_1</span><span class="hljs-variable">$正</span>则化 <span class="hljs-number">252</span><br><span class="hljs-number">11.5</span> 稀疏表示与字典学习 <span class="hljs-number">254</span><br><span class="hljs-number">11.6</span> 压缩感知 <span class="hljs-number">257</span><br><span class="hljs-number">11.7</span> 阅读材料 <span class="hljs-number">260</span><br>习题 <span class="hljs-number">262</span><br>参考文献 <span class="hljs-number">263</span><br>休息一会儿 <span class="hljs-number">266</span><br>第<span class="hljs-number">12</span>章 计算学习理论 <span class="hljs-number">267</span><br><span class="hljs-number">12.1</span> 基础知识 <span class="hljs-number">267</span><br><span class="hljs-number">12.2</span> PAC学习 <span class="hljs-number">268</span><br><span class="hljs-number">12.3</span> 有限假设空间 <span class="hljs-number">270</span><br><span class="hljs-number">12.3</span>.<span class="hljs-number">1</span> 可分情形 <span class="hljs-number">270</span><br><span class="hljs-number">12.3</span>.<span class="hljs-number">2</span> 不可分情形 <span class="hljs-number">272</span><br><span class="hljs-number">12.4</span> VC维 <span class="hljs-number">273</span><br><span class="hljs-number">12.5</span> Rademacher复杂度 <span class="hljs-number">279</span><br><span class="hljs-number">12.6</span> 稳定性 <span class="hljs-number">284</span><br><span class="hljs-number">12.7</span> 阅读材料 <span class="hljs-number">287</span><br>习题 <span class="hljs-number">289</span><br>参考文献 <span class="hljs-number">290</span><br>休息一会儿 <span class="hljs-number">292</span><br>第<span class="hljs-number">13</span>章 半监督学习 <span class="hljs-number">293</span><br><span class="hljs-number">13.1</span> 未标记样本 <span class="hljs-number">293</span><br><span class="hljs-number">13.2</span> 生成式方法 <span class="hljs-number">295</span><br><span class="hljs-number">13.3</span> 半监督SVM <span class="hljs-number">298</span><br><span class="hljs-number">13.4</span> 图半监督学习 <span class="hljs-number">300</span><br><span class="hljs-number">13.5</span> 基于分歧的方法 <span class="hljs-number">304</span><br><span class="hljs-number">13.6</span> 半监督聚类 <span class="hljs-number">307</span><br><span class="hljs-number">13.7</span> 阅读材料 <span class="hljs-number">311</span><br>习题 <span class="hljs-number">313</span><br>参考文献 <span class="hljs-number">314</span><br>休息一会儿 <span class="hljs-number">317</span><br>第<span class="hljs-number">14</span>章 概率图模型 <span class="hljs-number">319</span><br><span class="hljs-number">14.1</span> 隐马尔可夫模型 <span class="hljs-number">319</span><br><span class="hljs-number">14.2</span> 马尔可夫随机场 <span class="hljs-number">322</span><br><span class="hljs-number">14.3</span> 条件随机场 <span class="hljs-number">325</span><br><span class="hljs-number">14.4</span> 学习与推断 <span class="hljs-number">328</span><br><span class="hljs-number">14.4</span>.<span class="hljs-number">1</span> 变量消去 <span class="hljs-number">328</span><br><span class="hljs-number">14.4</span>.<span class="hljs-number">2</span> 信念传播 <span class="hljs-number">330</span><br><span class="hljs-number">14.5</span> 近似推断 <span class="hljs-number">331</span><br><span class="hljs-number">14.5</span>.<span class="hljs-number">1</span> MCMC采样 <span class="hljs-number">331</span><br><span class="hljs-number">14.5</span>.<span class="hljs-number">2</span> 变分推断 <span class="hljs-number">334</span><br><span class="hljs-number">14.6</span> 话题模型 <span class="hljs-number">337</span><br><span class="hljs-number">14.7</span> 阅读材料 <span class="hljs-number">339</span><br>习题 <span class="hljs-number">341</span><br>参考文献 <span class="hljs-number">342</span><br>休息一会儿 <span class="hljs-number">345</span><br>第<span class="hljs-number">15</span>章 规则学习 <span class="hljs-number">347</span><br><span class="hljs-number">15.1</span> 基本概念 <span class="hljs-number">347</span><br><span class="hljs-number">15.2</span> 序贯覆盖 <span class="hljs-number">349</span><br><span class="hljs-number">15.3</span> 剪枝优化 <span class="hljs-number">352</span><br><span class="hljs-number">15.4</span> 一阶规则学习 <span class="hljs-number">354</span><br><span class="hljs-number">15.5</span> 归纳逻辑程序设计 <span class="hljs-number">357</span><br><span class="hljs-number">15.5</span>.<span class="hljs-number">1</span> 最小一般泛化 <span class="hljs-number">358</span><br><span class="hljs-number">15.5</span>.<span class="hljs-number">2</span> 逆归结 <span class="hljs-number">359</span><br><span class="hljs-number">15.6</span> 阅读材料 <span class="hljs-number">363</span><br>习题 <span class="hljs-number">365</span><br>参考文献 <span class="hljs-number">366</span><br>休息一会儿 <span class="hljs-number">369</span><br>第<span class="hljs-number">16</span>章 强化学习 <span class="hljs-number">371</span><br><span class="hljs-number">16.1</span> 任务与奖赏 <span class="hljs-number">371</span><br><span class="hljs-number">16.2</span> <span class="hljs-variable">$K</span><span class="hljs-variable">$-</span>摇臂赌博机 <span class="hljs-number">373</span><br><span class="hljs-number">16.2</span>.<span class="hljs-number">1</span> 探索与利用 <span class="hljs-number">373</span><br><span class="hljs-number">16.2</span>.<span class="hljs-number">2</span> <span class="hljs-variable">$\</span>epsilon <span class="hljs-variable">$-</span>贪心 <span class="hljs-number">374</span><br><span class="hljs-number">16.2</span>.<span class="hljs-number">3</span> Softmax <span class="hljs-number">375</span><br><span class="hljs-number">16.3</span> 有模型学习 <span class="hljs-number">377</span><br><span class="hljs-number">16.3</span>.<span class="hljs-number">1</span> 策略评估 <span class="hljs-number">377</span><br><span class="hljs-number">16.3</span>.<span class="hljs-number">2</span> 策略改进 <span class="hljs-number">379</span><br><span class="hljs-number">16.3</span>.<span class="hljs-number">3</span> 策略迭代与值迭代 <span class="hljs-number">381</span><br><span class="hljs-number">16.4</span> 免模型学习 <span class="hljs-number">382</span><br><span class="hljs-number">16.4</span>.<span class="hljs-number">1</span> 蒙特卡罗强化学习 <span class="hljs-number">383</span><br><span class="hljs-number">16.4</span>.<span class="hljs-number">2</span> 时序差分学习 <span class="hljs-number">386</span><br><span class="hljs-number">16.5</span> 值函数近似 <span class="hljs-number">388</span><br><span class="hljs-number">16.6</span> 模仿学习 <span class="hljs-number">390</span><br><span class="hljs-number">16.6</span>.<span class="hljs-number">1</span> 直接模仿学习 <span class="hljs-number">391</span><br><span class="hljs-number">16.6</span>.<span class="hljs-number">2</span> 逆强化学习 <span class="hljs-number">391</span><br><span class="hljs-number">16.7</span> 阅读材料 <span class="hljs-number">393</span><br>习题 <span class="hljs-number">394</span><br>参考文献 <span class="hljs-number">395</span><br>休息一会儿 <span class="hljs-number">397</span><br>附录 <span class="hljs-number">399</span><br>A 矩阵 <span class="hljs-number">399</span><br>B 优化 <span class="hljs-number">403</span><br>C 概率分布 <span class="hljs-number">409</span><br>后记 <span class="hljs-number">417</span><br>索引 <span class="hljs-number">419</span><br></code></pre></td></tr></table></figure><hr><h2 id="AI必知必会基础"><a href="#AI必知必会基础" class="headerlink" title="AI必知必会基础"></a>AI必知必会基础</h2><p><a href="https://easyai.tech/">面向产品经理的AI科普</a></p><h3 id="人工智能概论"><a href="#人工智能概论" class="headerlink" title="人工智能概论"></a>人工智能概论</h3><h4 id="人工智能的描述"><a href="#人工智能的描述" class="headerlink" title="人工智能的描述"></a>人工智能的描述</h4><ul><li>可以感知“环境”，并且根据环境变化做出决策或者行动，从而达成目标的程序。(AI 的所谓学习，可以被解释成一种 优化)</li><li><code>为什么GPU为机器学习提供了支撑？</code>： GPU一开始被设计成方便图形开发，在渲染图形时候需要大量浮点运算，并且GPU可以大量并行的进行浮点运算</li></ul><h4 id="弱、强、超人工智能的含义"><a href="#弱、强、超人工智能的含义" class="headerlink" title="弱、强、超人工智能的含义"></a>弱、强、超人工智能的含义</h4><ul><li>弱人工智能 指的是专注于且只能解决特定问题的AI， AlphaGo、Siri这种也只能叫弱人工智能</li><li>强人工智能 又叫完全人工智能，可以胜任人类所有工作的人工智能，目前还无法实现。<ul><li>在我看来，一方面是由于人工智能的<strong>复杂决策和对不确定因素的推理能力</strong>还不成熟，另一方面，人工智能伦理问题也难以解决。</li></ul></li><li>超人工智能 比人类社会最聪明的人还要更逆天的存在</li><li>人工智能与岗位的关系：不可避免的替代掉一部分人的工作，但在历史上也有先例，会产生更好的工作 解放人类生产力。  决策信息量小，过程简单的重复性工作，可能会被替代。</li></ul><h4 id="人工智能几个基本概念"><a href="#人工智能几个基本概念" class="headerlink" title="人工智能几个基本概念"></a>人工智能几个基本概念</h4><ul><li><p>向量 &#x3D;&gt; 二维    平面 &#x3D;&gt; 矩阵   多维 &#x3D;&gt; 张量(tensor)</p></li><li><h5 id="训练集、验证集-训练好之后用来调整参数-、测试集-用来评估"><a href="#训练集、验证集-训练好之后用来调整参数-、测试集-用来评估" class="headerlink" title="训练集、验证集(训练好之后用来调整参数)、测试集(用来评估)"></a>训练集、验证集(训练好之后用来调整参数)、测试集(用来评估)</h5><ul><li>注意，三者其实都是数据集的划分而已，并不是独立的，一般的分配比例是 6 2 2(小型系统)<ul><li>每一个数据看作一个 包， 每个包里可以有多个instance.</li></ul></li></ul></li><li><p>随机梯度下降法 Stochastic Gradient Descent</p></li></ul><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>机器学习7大步骤</p><p>收集数据 $\rightarrow$ 数据准备 $\rightarrow$ 选择模型 $\rightarrow$ 训练 $\rightarrow$ 评估 $\rightarrow$ 参数调整 $\rightarrow$ 预估</p><img src="/Users/natsumi/Library/Application Support/typora-user-images/image-20220305002212922.png" alt="image-20220305002212922" style="zoom:50%;" /><p><strong>宏观上说，还是将现实问题抽象为数学问题，并利用计算机建立模型解决，最后评估模型的合理性。从过程上说，通过训练集，不断识别和提取特征，不断完善模型，最终形成有效模型的过程，就可以称为机器学习。</strong></p><h4 id="机器学习的评估指标-以男女预测为例"><a href="#机器学习的评估指标-以男女预测为例" class="headerlink" title="机器学习的评估指标 (以男女预测为例)"></a>机器学习的评估指标 (以男女预测为例)</h4><ul><li>Accuracy<ul><li>正确数&#x2F;总预测数    问题在于样本不平衡时(比如9成样本结果一样，那么即使全预测一样的结果仍然可能取得9成的准确率)</li></ul></li><li>Precision<ul><li>以男女预测为例，这个指的是，比如预测为男的结果里，实际上确实为男的比率，而Accuracy 指的是，所有的预测结果里，预测正确的比率。</li></ul></li><li>Recall  召回率&#x2F;查全率<ul><li>实际为男的样本，确实被预测为男的概率</li><li>为什么需要这个指标：有些系统必须找出全部含有某种特征的点, 比如必须找到所有欠债的人，至于有的人没欠债却被认为欠了，没关系。</li></ul></li><li>PR曲线 &#x2F; F1分数  「将精准率和召回率做出二维曲线」<ul><li>P和R 并不能都同时达到高位，因此综合两者的表现，出现了F1分数 &#x3D; (2 x p x r) &#x2F; (p + r)</li></ul></li><li>ROC 曲线 「TP率 和 FP率 真正率 &#x2F; 假正率」<ul><li>我觉得这个不是很好懂，姑且记住 <strong>ROC曲线越陡说明模型的性能越好</strong></li></ul></li><li>AUC 曲线下面积</li></ul><p>深度学习的兴起在2006年《一种深度置信网络的快速学习算法》</p><blockquote><p>为什么深度学习和机器学习会兴起：</p><p>​    归根到底互联网行业和硬件产业的发展，互联网的迅速发展形成了大量数据，而硬件产业(尤其是GPU的不断成熟)的发展则为存储、分析这些数据成为可能。</p></blockquote><p>深度学习相比普通机器学习而言，需要更多的数据，并且受数据规范性的影响更大。</p>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>Computation tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vscode为什么这么多奇怪问题</title>
    <link href="/2022/02/28/Vscode%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/28/Vscode%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Vscode"><a href="#Vscode" class="headerlink" title="Vscode"></a>Vscode</h1><ul><li><h4 id="SyntaxError-Non-ASCII-character-39-xe6-39-in-file"><a href="#SyntaxError-Non-ASCII-character-39-xe6-39-in-file" class="headerlink" title="SyntaxError: Non-ASCII character &#39;\xe6&#39; in file"></a><code>SyntaxError: Non-ASCII character &#39;\xe6&#39; in file</code></h4><ul><li>解决方案：主文件输入 <code>-\*- coding: utf-8 -* </code></li><li>原理：未知</li></ul></li><li><h4 id="python无法找到本就存在的库-no-import-module-named-quot-xxx-quot"><a href="#python无法找到本就存在的库-no-import-module-named-quot-xxx-quot" class="headerlink" title="python无法找到本就存在的库  no import module named &quot;xxx&quot;"></a>python无法找到本就存在的库  <code>no import module named &quot;xxx&quot;</code></h4><ul><li><p>解决方案1： 其实是无法链接的问题，引入ssl库进行链接即可</p><ul><li>import ssl</li><li>ssl._create_default_https_context &#x3D; ssl._create_unverified_context</li></ul></li><li><p>解决方案2 ： Vscode的coderunner扩展有问题，它的默认python路径是python2.7, 所以检测不出库</p><p>在setting.json 中添加这个条目即可。</p><figure class="highlight json"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;code-runner.executorMap&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;python&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;python3 -u&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About hexo blog</title>
    <link href="/2022/02/21/about-hexo-blog/"/>
    <url>/2022/02/21/about-hexo-blog/</url>
    
    <content type="html"><![CDATA[<h2 id="About-hexo-个人博客"><a href="#About-hexo-个人博客" class="headerlink" title="About hexo 个人博客"></a>About hexo 个人博客</h2><p><a href="https://hexo.io/zh-cn/">hexo</a>, 基于node.js的网站开发框架，无论是各种配置还是部署都足够的方便且容易。<br><a href="https://www.yousazoe.top/">来点花活</a></p><blockquote><p>几个标准命令</p><ul><li>n new <ul><li>hexo new post  <code>filename</code></li><li>hexo new page <code>pagename</code></li></ul></li><li>c clean up buffet</li><li>g generate</li><li>s server (localhost4000 deploy, 是实时的)</li><li>d deploy  不要随便deploy 先在本地看一下</li></ul></blockquote><h3 id="Problem-amp-Solve"><a href="#Problem-amp-Solve" class="headerlink" title="Problem &amp; Solve"></a>Problem &amp; Solve</h3><ul><li><p>博客页面404</p><ul><li>缺少index.html 非常基础的问题<ul><li><a href="https://www.jianshu.com/p/2349c763cc02">解决方案</a></li></ul></li></ul></li><li><p>deploy失败</p><blockquote><p>一般情况下只要localhost工作正常就可不需调整，一般是服务器缓存的问题，需要等待</p></blockquote></li><li><p>tag词云</p><ul><li><p>在 package.json下添加一条依赖<code>hexo-tag-cloud :&quot;^2.1.x&quot;</code>，然后在配置文件中找到<code>tags.ejs</code></p></li><li><p>将tags.ejs 进行修改，加入词云配置，同时一些调整也是在这个ejs文件中进行的</p><ul><li>如果想调整非运动字体的大小 调整min_font 和max_font</li><li>如果要调整动画字体， 调整 width 和 height</li><li>目前使用的这个方式有点小糊， 使用css绘制有可能可以解决这个问题</li></ul><p>以下是原本的文件</p><p>&lt;%<br>page.layout &#x3D; “tags”<br>page.title &#x3D; theme.tag.title || __(‘tag.title’)<br>page.subtitle &#x3D; theme.tag.subtitle || __(‘tag.subtitle’)<br>page.banner_img &#x3D; theme.tag.banner_img<br>page.banner_img_height &#x3D; theme.tag.banner_img_height<br>page.banner_mask_alpha &#x3D; theme.tag.banner_mask_alpha</p><p>var min_font &#x3D; theme.tag.tagcloud.min_font || 15<br>var max_font &#x3D; theme.tag.tagcloud.max_font || 30<br>var unit &#x3D; theme.tag.tagcloud.unit || ‘px’<br>var start_color &#x3D; theme.tag.tagcloud.start_color || ‘#BBBBEE’<br>var end_color &#x3D; theme.tag.tagcloud.end_color || ‘#337ab7’<br>%&gt;<br>&lt;div class&#x3D;”text-center tagcloud”&gt;<br>  &lt;%- tagcloud({<br>    min_font: min_font,<br>    max_font: max_font,<br>    amount: 999,<br>    unit: unit,<br>    color: true,<br>    start_color,<br>    end_color<br>  }) %&gt;<br>&lt;&#x2F;div&gt;</p></li></ul></li></ul><h4 id="主题推荐："><a href="#主题推荐：" class="headerlink" title="主题推荐："></a>主题推荐：</h4><ul><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a> 非常细致的配置文件，方便调整<ul><li><a href="https://hexo.fluid-dev.com/docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97">具体教程</a></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about Hash map</title>
    <link href="/2021/06/03/about%20Hash%20map/"/>
    <url>/2021/06/03/about%20Hash%20map/</url>
    
    <content type="html"><![CDATA[<h1 id="Hash-map"><a href="#Hash-map" class="headerlink" title="Hash map"></a>Hash map</h1><h3 id="Notifications"><a href="#Notifications" class="headerlink" title="Notifications"></a>Notifications</h3><ul><li><h4 id="C-17-hash-table-遍历-迭代器遍历则应当注意我们不能通过迭代器更改元素值"><a href="#C-17-hash-table-遍历-迭代器遍历则应当注意我们不能通过迭代器更改元素值" class="headerlink" title="C++ 17 hash table 遍历 (迭代器遍历则应当注意我们不能通过迭代器更改元素值)"></a>C++ 17 hash table 遍历 (迭代器遍历则应当注意我们不能通过迭代器更改元素值)</h4><p>for (auto&amp; [_, c] : cnt) {            maxCnt &#x3D; max(maxCnt, c);        } &#x2F;&#x2F; first 和 second, 用 <code>_</code> 也可以不命名</p></li><li><h3 id="请务必使用-mp-count-element-来查看是否存在某个元素-使用-mp-element-存在很大问题"><a href="#请务必使用-mp-count-element-来查看是否存在某个元素-使用-mp-element-存在很大问题" class="headerlink" title="请务必使用(mp.count(element)) 来查看是否存在某个元素, 使用 !mp[element] 存在很大问题."></a>请务必使用(mp.count(element)) 来查看是否存在某个元素, 使用 !mp[element] 存在很大问题.</h3><blockquote><p>e.g <a href="https://leetcode-cn.com/problems/contiguous-array/">525. 连续数组</a></p></blockquote></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about 位运算</title>
    <link href="/2021/05/11/about%20%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2021/05/11/about%20%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="about-位运算-运算符"><a href="#about-位运算-运算符" class="headerlink" title="about 位运算 (运算符)"></a>about 位运算 (运算符)</h1><h3 id="uint32-t-32位二进制整数-一般情况下-左移就是除二"><a href="#uint32-t-32位二进制整数-一般情况下-左移就是除二" class="headerlink" title="uint32_t   32位二进制整数  一般情况下 左移就是除二"></a>uint32_t   32位二进制整数  一般情况下 左移就是除二</h3><h5 id="x-amp-x-1-可以检测是否是2的整数次幂-x-amp-x-1-可以清除最右边的1-如果这个1是第一位的1-那这个数就变为0"><a href="#x-amp-x-1-可以检测是否是2的整数次幂-x-amp-x-1-可以清除最右边的1-如果这个1是第一位的1-那这个数就变为0" class="headerlink" title="x &amp; x-1 可以检测是否是2的整数次幂  (x&amp;x-1 可以清除最右边的1,如果这个1是第一位的1, 那这个数就变为0)"></a>x &amp; x-1 可以检测是否是2的整数次幂  (x&amp;x-1 可以清除最右边的1,如果这个1是第一位的1, 那这个数就变为0)</h5><h4 id="n-amp-1-在32位下-1是-00000····001-而不是111···1-用来检测奇偶性-最后一位是否为1-偶数结果为0"><a href="#n-amp-1-在32位下-1是-00000····001-而不是111···1-用来检测奇偶性-最后一位是否为1-偶数结果为0" class="headerlink" title="n &amp; 1 (在32位下 1是 00000····001 而不是111···1)   用来检测奇偶性(最后一位是否为1)   偶数结果为0"></a>n &amp; 1 (在32位下 1是 00000····001 而不是111···1)   用来检测奇偶性(最后一位是否为1)   偶数结果为0</h4><h4 id="对于x-取其第i位的二进制-rightarrow-x-gt-gt-i-amp-1-比如在477-汉明距离总和-我们有时候可以将每一个二进制位分开来看"><a href="#对于x-取其第i位的二进制-rightarrow-x-gt-gt-i-amp-1-比如在477-汉明距离总和-我们有时候可以将每一个二进制位分开来看" class="headerlink" title="对于x , 取其第i位的二进制 $\rightarrow$ (x &gt;&gt; i) &amp; 1,  比如在477. 汉明距离总和 我们有时候可以将每一个二进制位分开来看"></a>对于x , 取其第i位的二进制 $\rightarrow$ (x &gt;&gt; i) &amp; 1,  比如在<a href="https://leetcode-cn.com/problems/total-hamming-distance/">477. 汉明距离总和</a> 我们有时候可以将每一个二进制位分开来看</h4><h3 id="builtin-popcount-i-计算32位整型里-1的个数"><a href="#builtin-popcount-i-计算32位整型里-1的个数" class="headerlink" title="__builtin_popcount(i) 计算32位整型里 1的个数"></a>__builtin_popcount(i) 计算32位整型里 1的个数</h3><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与操作，按二进制位进行”与”运算。                                                             运算规则：<code>0&amp;0=0;    0&amp;1=0;     1&amp;0=0;      1&amp;1=1;</code></td><td>(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td>|</td><td>按位或运算符，按二进制位进行”或”运算。                                                         运算规则：&#96;0</td><td>0&#x3D;0;    0</td></tr><tr><td>^</td><td>异或运算符，按二进制位进行”异或”运算。                                                         运算规则：<code>0^0=0;    0^1=1;    1^0=1;   1^1=0;</code></td><td>(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td>~</td><td>取反运算符，按二进制位进行”取反”运算。                                                         运算规则：<code>~1=-2;    ~0=1;</code></td><td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td>二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）</td><td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</td><td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr></tbody></table><h3 id="位运算也有赋值运算符"><a href="#位运算也有赋值运算符" class="headerlink" title="位运算也有赋值运算符"></a>位运算也有赋值运算符</h3><table><thead><tr><th>&lt;&lt;&#x3D;</th><th>左移且赋值运算符</th><th>C &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2</th></tr></thead><tbody><tr><td>&gt;&gt;&#x3D;</td><td>右移且赋值运算符</td><td>C &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2</td></tr><tr><td>&amp;&#x3D;</td><td>按位与且赋值运算符</td><td>C &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2</td></tr><tr><td>^&#x3D;</td><td>按位异或且赋值运算符</td><td>C ^&#x3D; 2 等同于 C &#x3D; C ^ 2</td></tr><tr><td>|&#x3D;</td><td>按位或且赋值运算符</td><td>C |&#x3D; 2 等同于 C &#x3D; C | 2</td></tr></tbody></table><h3 id="杂项运算符"><a href="#杂项运算符" class="headerlink" title="杂项运算符"></a>杂项运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>sizeof</td><td><a href="https://www.runoob.com/cplusplus/cpp-sizeof-operator.html">sizeof 运算符</a>返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。</td></tr><tr><td>Condition ? X : Y</td><td><a href="https://www.runoob.com/cplusplus/cpp-conditional-operator.html">条件运算符</a>。如果 Condition 为真 ? 则值为 X : 否则值为 Y。</td></tr><tr><td>,</td><td><a href="https://www.runoob.com/cplusplus/cpp-comma-operator.html">逗号运算符</a>会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</td></tr><tr><td>.（点）和 -&gt;（箭头）</td><td><a href="https://www.runoob.com/cplusplus/cpp-member-operators.html">成员运算符</a>用于引用类、结构和共用体的成员。</td></tr><tr><td>Cast</td><td><a href="https://www.runoob.com/cplusplus/cpp-casting-operators.html">强制转换运算符</a>把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。</td></tr><tr><td>&amp;</td><td><a href="https://www.runoob.com/cplusplus/cpp-pointer-operators.html">指针运算符 &amp;</a> 返回变量的地址。例如 &amp;a; 将给出变量的实际地址。</td></tr><tr><td>*</td><td><a href="https://www.runoob.com/cplusplus/cpp-pointer-operators.html">指针运算符 *</a> 指向一个变量。例如，*var; 将指向变量 var。</td></tr></tbody></table><h3 id="运算符优先级-「由高到低」"><a href="#运算符优先级-「由高到低」" class="headerlink" title="运算符优先级 「由高到低」"></a>运算符优先级 「由高到低」</h3><table><thead><tr><th>类别</th><th>运算符</th><th>结合性</th></tr></thead><tbody><tr><td>后缀</td><td>() [] -&gt; . ++ - -</td><td>从左到右</td></tr><tr><td>一元</td><td>+ - ! ~ ++ - - (type)* &amp; sizeof</td><td>从右到左</td></tr><tr><td>乘除</td><td>* &#x2F; %</td><td>从左到右</td></tr><tr><td>加减</td><td>+ -</td><td>从左到右</td></tr><tr><td>移位</td><td>&lt;&lt; &gt;&gt;</td><td>从左到右</td></tr><tr><td>关系</td><td>&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td><td>从左到右</td></tr><tr><td>相等</td><td>&#x3D;&#x3D; !&#x3D;</td><td>从左到右</td></tr><tr><td>位与 AND</td><td>&amp;</td><td>从左到右</td></tr><tr><td>位异或 XOR</td><td>^</td><td>从左到右</td></tr><tr><td>位或 OR</td><td>|</td><td>从左到右</td></tr><tr><td>逻辑与 AND</td><td>&amp;&amp;</td><td>从左到右</td></tr><tr><td>逻辑或 OR</td><td>||</td><td>从左到右</td></tr><tr><td>条件</td><td>?:</td><td>从右到左</td></tr><tr><td>赋值</td><td>&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;&gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;</td><td>从右到左</td></tr><tr><td>逗号</td><td>,</td><td>从左到右</td></tr></tbody></table><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0xaaaaaaaa</span> = <span class="hljs-number">10101010101010101010101010101010</span> (偶数位为<span class="hljs-number">1</span>，奇数位为<span class="hljs-number">0</span>）<br><span class="hljs-attribute">0x55555555</span> = <span class="hljs-number">1010101010101010101010101010101</span> (偶数位为<span class="hljs-number">0</span>，奇数位为<span class="hljs-number">1</span>）<br><span class="hljs-attribute">0x33333333</span> = <span class="hljs-number">110011001100110011001100110011</span> (<span class="hljs-number">1</span>和<span class="hljs-number">0</span>每隔两位交替出现)<br><span class="hljs-attribute">0xcccccccc</span> = <span class="hljs-number">11001100110011001100110011001100</span> (<span class="hljs-number">0</span>和<span class="hljs-number">1</span>每隔两位交替出现)<br><span class="hljs-attribute">0x0f0f0f0f</span> = <span class="hljs-number">00001111000011110000111100001111</span> (<span class="hljs-number">1</span>和<span class="hljs-number">0</span>每隔四位交替出现)<br><span class="hljs-attribute">0xf0f0f0f0</span> = <span class="hljs-number">11110000111100001111000011110000</span> (<span class="hljs-number">0</span>和<span class="hljs-number">1</span>每隔四位交替出现)<br></code></pre></td></tr></table></figure><hr><h3 id="190-颠倒二进制位-「-gt-gt-x3D-和-gt-gt-的区别」"><a href="#190-颠倒二进制位-「-gt-gt-x3D-和-gt-gt-的区别」" class="headerlink" title="190. 颠倒二进制位  「&gt;&gt;&#x3D; 和 &gt;&gt; 的区别」"></a><a href="https://leetcode-cn.com/problems/reverse-bits/">190. 颠倒二进制位</a>  「&gt;&gt;&#x3D; 和 &gt;&gt; 的区别」</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// res 一开始为0, 每次我们都将 res左移, 将n右移</span><br><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>&#123;<br>        <span class="hljs-type">uint32_t</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i) &#123;<br>            res = (res &lt;&lt; <span class="hljs-number">1</span>) | (n &amp; <span class="hljs-number">1</span>);   <br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h3 id="XOR-异或运算的性质"><a href="#XOR-异或运算的性质" class="headerlink" title="XOR 异或运算的性质:"></a>XOR 异或运算的性质:</h3><ol><li><p>x⊕x&#x3D;0 ,  x⊕0 &#x3D; x</p></li><li><h4 id="x⊕y-x3D-y⊕x-交换律"><a href="#x⊕y-x3D-y⊕x-交换律" class="headerlink" title="x⊕y&#x3D;y⊕x (交换律)"></a>x⊕y&#x3D;y⊕x (交换律)</h4></li><li><p>(x⊕y)⊕z&#x3D;x⊕(y⊕z) (结合律)    「不支持分配律」</p></li><li><p>x⊕y⊕y&#x3D;x (自反性)</p></li><li><p>∀i∈Z，有 4i⊕(4i+1)⊕(4i+2)⊕(4i+3)&#x3D;0</p></li></ol><hr><h4 id="在342-4的幂-偶数位上是1的32位整形-0xaaaaaaaa"><a href="#在342-4的幂-偶数位上是1的32位整形-0xaaaaaaaa" class="headerlink" title="在342. 4的幂  偶数位上是1的32位整形, 0xaaaaaaaa"></a>在<a href="https://leetcode-cn.com/problems/power-of-four/">342. 4的幂</a>  偶数位上是1的32位整形, 0xaaaaaaaa</h4><hr><h3 id="如何取按照要求-取一个整型中的某些二进制位？"><a href="#如何取按照要求-取一个整型中的某些二进制位？" class="headerlink" title="如何取按照要求 取一个整型中的某些二进制位？"></a>如何取按照要求 取一个整型中的某些二进制位？</h3><ul><li><h4 id="对于x-取其第i位的二进制-rightarrow-x-gt-gt-i-amp-1-从0开始"><a href="#对于x-取其第i位的二进制-rightarrow-x-gt-gt-i-amp-1-从0开始" class="headerlink" title="对于x , 取其第i位的二进制 $\rightarrow$ (x &gt;&gt; i) &amp; 1 (从0开始)"></a>对于x , 取其第i位的二进制 $\rightarrow$ (x &gt;&gt; i) &amp; 1 (从0开始)</h4></li><li><p>如果我们框定了x的范围，比如我们确认x &lt;&#x3D; 1024 那么32位中必然只需要使用其中最右边的10位</p><ul><li>想取 高4位(即10位中左边的4位) 那显然 res &#x3D; x &gt;&gt; 6</li><li>想取 低6位 则不需要移位，可以通过&#x3D;&#x3D;与运算(和全1与)&#x3D;&#x3D;直接取 比如这里 2^6 -1   res &#x3D; x &amp; 63;</li></ul></li></ul><h4 id="关于进制转换问题"><a href="#关于进制转换问题" class="headerlink" title="关于进制转换问题"></a>关于进制转换问题</h4><ul><li>我们使用的进制转换是<strong>短除法</strong>的进制转换，因此最后有一个 reverse 操作，不要忘记</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetcodeNotes</title>
    <link href="/2021/05/11/LeetcodeNotes/"/>
    <url>/2021/05/11/LeetcodeNotes/</url>
    
    <content type="html"><![CDATA[<h1 id="资料库"><a href="#资料库" class="headerlink" title="资料库"></a><a href="https://github.com/bigbigwanglei/Algorithm/blob/master/Sort.md">资料库</a></h1><h1 id="leetcode-1370-上下字符串"><a href="#leetcode-1370-上下字符串" class="headerlink" title="leetcode 1370 上下字符串"></a>leetcode 1370 上下字符串</h1><p>index 从后往前遍历的时候 千万要注意 删除操作 对于index的位移</p><hr><h3 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290. 单词规律"></a><a href="https://leetcode-cn.com/problems/word-pattern/">290. 单词规律</a></h3><p><code>如果我们有 两个对象 他们必须一一对应 我们最好创建两个哈希表</code></p><p>实现这种一一对应的关系</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">    <span class="hljs-comment">//assume A is char and B is int | C is char too</span><br>    <span class="hljs-comment">//simulate A =&gt; B and C also =&gt; B</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; dict;<br>    <span class="hljs-type">char</span> A = <span class="hljs-string">&#x27;A&#x27;</span>, C = <span class="hljs-string">&#x27;C&#x27;</span>;<br>    <span class="hljs-type">int</span> B = <span class="hljs-number">17</span>;<br>    dict[B] = A;<br>    dict[B] = C;     <span class="hljs-comment">//只有 hash key是被保护的对象 被保护对象不可以重复</span><br><span class="hljs-comment">// 如果两者都是被保护对象 那只能建立两个hash table</span><br></code></pre></td></tr></table></figure><hr><ul><li><h3 id="我们将环岛划分为-n-个结点，要走过所有的结点，会漏下一段，想要求最短行进距离，只要漏下的最长即可"><a href="#我们将环岛划分为-n-个结点，要走过所有的结点，会漏下一段，想要求最短行进距离，只要漏下的最长即可" class="headerlink" title="我们将环岛划分为 n 个结点，要走过所有的结点，会漏下一段，想要求最短行进距离，只要漏下的最长即可"></a>我们将环岛划分为 n 个结点，要走过所有的结点，会漏下一段，想要求最短行进距离，只要漏下的最长即可</h3></li></ul><hr><h2 id="leetcode-387-找到第一个唯一字符"><a href="#leetcode-387-找到第一个唯一字符" class="headerlink" title="leetcode 387 找到第一个唯一字符"></a>leetcode 387 找到第一个唯一字符</h2><p>如题 我们要在一个字符串里找到<strong>第一个</strong> 不和后面任何字符重复的唯一出现一次的字符</p><ul><li>队列 + 延迟删除(每次检测到出现重复字符都会触发一个循环删除操作(当然 这其实挺慢的))</li></ul><p>由于队列的 FIFO属性 如果想找到第一个符合要求的元素 使用队列是方便的</p><hr><h3 id="2021-2-7｜665-非递减序列"><a href="#2021-2-7｜665-非递减序列" class="headerlink" title="2021. 2. 7｜665 非递减序列"></a><a href="https://leetcode-cn.com/problems/non-decreasing-array/">2021. 2. 7｜665 非递减序列</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 4 2 5</span><br><span class="hljs-comment">// 1 4 2 5</span><br><span class="hljs-comment">// 3 4 2 5  3种情况</span><br><span class="hljs-comment">// 当我们发现nums[i] &lt; nums[i-1] 时 应该优先调整num[i-1]的值 因为nums[i]变大会影响之后的判断</span><br><span class="hljs-comment">// 所以我们只需要知道 nums[i-1]最小能变到多小 显然，就是nums[i-2]的大小。</span><br><span class="hljs-comment">// 但如果nums[i]比nums[i-2]更小， 这意味着我们不得不调整nums[i]的值使得它和nums[i-1]一样。</span><br></code></pre></td></tr></table></figure><h3 id="2-7｜5674-构造字典序最大的合并字符串"><a href="#2-7｜5674-构造字典序最大的合并字符串" class="headerlink" title="2.7｜5674 构造字典序最大的合并字符串"></a><a href="https://leetcode-cn.com/problems/largest-merge-of-two-strings/">2.7｜5674 构造字典序最大的合并字符串</a></h3><blockquote><h3 id="总之两边每次都拿最大的那个，问题在于-如果说两个字符串的头都一样大，应当拿的是子字符串最大的那个-「使用-substr-i-」"><a href="#总之两边每次都拿最大的那个，问题在于-如果说两个字符串的头都一样大，应当拿的是子字符串最大的那个-「使用-substr-i-」" class="headerlink" title="总之两边每次都拿最大的那个，问题在于 如果说两个字符串的头都一样大，应当拿的是子字符串最大的那个 「使用 substr(i)」"></a>总之两边每次都拿最大的那个，问题在于 如果说两个字符串的头都一样大，应当拿的是子字符串最大的那个 「使用 substr(i)」</h3></blockquote><hr><h3 id="2-8｜978最长湍流子数组-和交替子序列比起来，这个是要求连续最长的-需要进行互相继承-优化了dp"><a href="#2-8｜978最长湍流子数组-和交替子序列比起来，这个是要求连续最长的-需要进行互相继承-优化了dp" class="headerlink" title="2.8｜978最长湍流子数组  和交替子序列比起来，这个是要求连续最长的 需要进行互相继承 优化了dp"></a>2.8｜978最长湍流子数组  和<code>交替子序列</code>比起来，这个是要求连续最长的 需要进行互相继承 优化了dp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxTurbulenceSize</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-comment">// 摆动上升记为up，摆动下降记为down  这个其实是动态规划的优化版本</span><br>        <span class="hljs-type">int</span> up = <span class="hljs-number">1</span>, down = <span class="hljs-number">1</span>, n = arr.<span class="hljs-built_in">size</span>(), res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-comment">// 我们应当注意的是 虽然up好像被清零了，但实际上它的值被继承到了down里，它们两个是交替继承到</span><br>            <span class="hljs-comment">// 建议先完全理解动态规划方法解决这个问题</span><br>            <span class="hljs-keyword">if</span> (arr[i] == arr[i<span class="hljs-number">-1</span>]) &#123;<br>                up = <span class="hljs-number">1</span>;<br>                down = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i<span class="hljs-number">-1</span>]) &#123;<br>                up = down + <span class="hljs-number">1</span>;<br>                down = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                down = up + <span class="hljs-number">1</span>;<br>                up = <span class="hljs-number">1</span>;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">max</span>(up, down));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-11｜703-数据流中的第K大元素-「不断的添加数据到一个数组中，我们每次都要第k大的元素」"><a href="#2-11｜703-数据流中的第K大元素-「不断的添加数据到一个数组中，我们每次都要第k大的元素」" class="headerlink" title="2.11｜703 数据流中的第K大元素  「不断的添加数据到一个数组中，我们每次都要第k大的元素」"></a>2.11｜<a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/">703 数据流中的第K大元素  「不断的添加数据到一个数组中，我们每次都要第k大的元素」</a></h3><blockquote><h3 id="只关注前K大，我们用数组中-x3D-x3D-前k大的元素组成一个最小堆，并且维持堆的大小为K-x3D-x3D-堆顶的就是目前第k大的元素-。"><a href="#只关注前K大，我们用数组中-x3D-x3D-前k大的元素组成一个最小堆，并且维持堆的大小为K-x3D-x3D-堆顶的就是目前第k大的元素-。" class="headerlink" title="只关注前K大，我们用数组中&#x3D;&#x3D;前k大的元素组成一个最小堆，并且维持堆的大小为K&#x3D;&#x3D;(堆顶的就是目前第k大的元素)。"></a>只关注前K大，我们用数组中&#x3D;&#x3D;前k大的元素组成一个最小堆，并且维持堆的大小为K&#x3D;&#x3D;(堆顶的就是目前第k大的元素)。</h3><h3 id="之后每次添加元素val，如果val比目前的堆顶小，那么它将被pop掉，如果它比堆顶要大，那么堆顶将被pop掉，第K大元素将会发生变更。"><a href="#之后每次添加元素val，如果val比目前的堆顶小，那么它将被pop掉，如果它比堆顶要大，那么堆顶将被pop掉，第K大元素将会发生变更。" class="headerlink" title="之后每次添加元素val，如果val比目前的堆顶小，那么它将被pop掉，如果它比堆顶要大，那么堆顶将被pop掉，第K大元素将会发生变更。"></a>之后每次添加元素val，如果val比目前的堆顶小，那么它将被pop掉，如果它比堆顶要大，那么堆顶将被pop掉，第K大元素将会发生变更。</h3><h5 id="初始数据-4-5-8-2-｜-第3大"><a href="#初始数据-4-5-8-2-｜-第3大" class="headerlink" title="初始数据 4 5 8 2  ｜ 第3大"></a>初始数据 4 5 8 2  ｜ 第3大</h5><h4 id="我们的堆中存有-4-5-8-，add-3的时候，3比4还小，所以它不会影响到第K大元素，-它会被放在堆顶，直接被pop掉"><a href="#我们的堆中存有-4-5-8-，add-3的时候，3比4还小，所以它不会影响到第K大元素，-它会被放在堆顶，直接被pop掉" class="headerlink" title="我们的堆中存有 4 5 8  ，add 3的时候，3比4还小，所以它不会影响到第K大元素， 它会被放在堆顶，直接被pop掉"></a>我们的堆中存有 4 5 8  ，add 3的时候，3比4还小，所以它不会影响到第K大元素， 它会被放在堆顶，直接被pop掉</h4><h4 id="如果add-的是5，-那么4会在堆顶，它现在已经不是第3大的元素了，4被pop掉。"><a href="#如果add-的是5，-那么4会在堆顶，它现在已经不是第3大的元素了，4被pop掉。" class="headerlink" title="如果add 的是5， 那么4会在堆顶，它现在已经不是第3大的元素了，4被pop掉。"></a>如果add 的是5， 那么4会在堆顶，它现在已经不是第3大的元素了，4被pop掉。</h4></blockquote><hr><h3 id="2-13｜448-找到1-n之中所有消失的数字"><a href="#2-13｜448-找到1-n之中所有消失的数字" class="headerlink" title="2.13｜448 找到1-n之中所有消失的数字"></a>2.13｜<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">448 找到1-n之中所有消失的数字</a></h3><h4 id="题：数组大小为n，它理应包含从1-n的连续不同的数字。"><a href="#题：数组大小为n，它理应包含从1-n的连续不同的数字。" class="headerlink" title="题：数组大小为n，它理应包含从1-n的连续不同的数字。"></a>题：数组大小为n，它理应包含从1-n的连续不同的数字。</h4><h4 id="但是有一些数字出现了多次，我们现在需要用一个数组返回数组中缺失的-范围在1-n之间的数字"><a href="#但是有一些数字出现了多次，我们现在需要用一个数组返回数组中缺失的-范围在1-n之间的数字" class="headerlink" title="但是有一些数字出现了多次，我们现在需要用一个数组返回数组中缺失的 范围在1-n之间的数字"></a>但是有一些数字出现了多次，我们现在需要用一个数组返回数组中缺失的 范围在1-n之间的数字</h4><blockquote><h3 id="关键在于-x3D-x3D-数的范围和下标的范围差不多-构建的直接就是下标对应的联系-x3D-x3D"><a href="#关键在于-x3D-x3D-数的范围和下标的范围差不多-构建的直接就是下标对应的联系-x3D-x3D" class="headerlink" title="关键在于 &#x3D;&#x3D;数的范围和下标的范围差不多 构建的直接就是下标对应的联系&#x3D;&#x3D;"></a>关键在于 &#x3D;&#x3D;数的范围和下标的范围差不多 构建的直接就是下标对应的联系&#x3D;&#x3D;</h3><h4 id="nums-i-的出现-直接将-nums-nums-i-1-n-n-可以把-n去掉，可能本来就已经加上了"><a href="#nums-i-的出现-直接将-nums-nums-i-1-n-n-可以把-n去掉，可能本来就已经加上了" class="headerlink" title="nums[i] 的出现 直接将 nums[nums[i]-1] + n (%n 可以把+n去掉，可能本来就已经加上了)"></a>nums[i] 的出现 直接将 nums[nums[i]-1] + n (%n 可以把+n去掉，可能本来就已经加上了)</h4></blockquote><hr><h3 id="3-2-304-二维区域和检索-矩阵不可变"><a href="#3-2-304-二维区域和检索-矩阵不可变" class="headerlink" title="3.2 | 304. 二维区域和检索 - 矩阵不可变"></a>3.2 | <a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></h3><blockquote><p>多次调用了矩阵的前缀和,我们可以一开始就全给他算出来,改成前缀模式 这样比较省时间.</p></blockquote><h2 id="3-4-1438-绝对差不超过限制的最长连续子数组"><a href="#3-4-1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="3.4 | 1438. 绝对差不超过限制的最长连续子数组"></a>3.4 | <a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a></h2><h3 id="「想要每次都拿出最大值和最小值-可以使用multiset」"><a href="#「想要每次都拿出最大值和最小值-可以使用multiset」" class="headerlink" title="「想要每次都拿出最大值和最小值 可以使用multiset」"></a>「想要每次都拿出最大值和最小值 可以使用multiset」</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ⚠️ 要求的子数组里 任意两个元素 的差 不能超过limit!! 不是相邻元素</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>        multiset&lt;<span class="hljs-type">int</span>&gt; count;   <span class="hljs-comment">// 为什么使用 multiset ? 因为我们需要保证有序 而且同时需要最大和最小元素 「这意味着堆(priority_queue 是基于队列实现的 所以不支持拿最后尾元素)的不可使用」</span><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(), left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            count.<span class="hljs-built_in">insert</span>(nums[right]); <span class="hljs-comment">//默认是从小到大排序</span><br>            <span class="hljs-keyword">while</span> (*count.<span class="hljs-built_in">rbegin</span>() - *count.<span class="hljs-built_in">begin</span>() &gt; limit) &#123;<br>                count.<span class="hljs-built_in">erase</span>(count.<span class="hljs-built_in">find</span>(nums[left++]));    <span class="hljs-comment">// multiset -&gt; erase </span><br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(right-left+<span class="hljs-number">1</span>, res);<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="3-6-503-下一个更大元素-II"><a href="#3-6-503-下一个更大元素-II" class="headerlink" title="3.6 | 503. 下一个更大元素 II"></a>3.6 | <a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h3><h3 id="1-单调栈"><a href="#1-单调栈" class="headerlink" title="1. 单调栈"></a>1. 单调栈</h3><h4 id="对于每个数都需要找到下一个比它大的元素-栈中存储的相当于一个降序的序列-只要出现一个更大的-栈中所有元素对应的下一个更大-都是它"><a href="#对于每个数都需要找到下一个比它大的元素-栈中存储的相当于一个降序的序列-只要出现一个更大的-栈中所有元素对应的下一个更大-都是它" class="headerlink" title="对于每个数都需要找到下一个比它大的元素, 栈中存储的相当于一个降序的序列 只要出现一个更大的 栈中所有元素对应的下一个更大 都是它"></a>对于每个数都需要找到下一个比它大的元素, 栈中存储的相当于一个降序的序列 只要出现一个更大的 栈中所有元素对应的下一个更大 都是它</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        stack&lt;<span class="hljs-type">int</span>&gt; tedious;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!tedious.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i % n] &gt; nums[tedious.<span class="hljs-built_in">top</span>()]) &#123;<br>                res[tedious.<span class="hljs-built_in">top</span>()] = nums[i % n];<br>                tedious.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            tedious.<span class="hljs-built_in">push</span>(i % n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="x3D-x3D-⚠️-可以通过「-capacity」-来实现对于数组的逻辑拉长-「⚠️-i-lt-2-n-1-是省了一次-不是越界」-x3D-x3D"><a href="#x3D-x3D-⚠️-可以通过「-capacity」-来实现对于数组的逻辑拉长-「⚠️-i-lt-2-n-1-是省了一次-不是越界」-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;⚠️ 可以通过「 % capacity」 来实现对于数组的逻辑拉长 「⚠️ i  &lt; 2*n-1  是省了一次 不是越界」&#x3D;&#x3D;"></a>&#x3D;&#x3D;⚠️ 可以通过「 % capacity」 来实现对于数组的逻辑拉长 「⚠️ i  &lt; 2*n-1  是省了一次 不是越界」&#x3D;&#x3D;</h3><h3 id="3-6-快速幂-本质上讲-是利用了递归的-栈逻辑-x-n-x3D-x-n-x2F-2-x-n-x2F-2-…"><a href="#3-6-快速幂-本质上讲-是利用了递归的-栈逻辑-x-n-x3D-x-n-x2F-2-x-n-x2F-2-…" class="headerlink" title="3.6 | 快速幂   本质上讲 是利用了递归的 栈逻辑  x^n &#x3D; x ^ n&#x2F;2 * x ^ n&#x2F;2 …"></a>3.6 | 快速幂   本质上讲 是利用了递归的 栈逻辑  x^n &#x3D; x ^ n&#x2F;2 * x ^ n&#x2F;2 …</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> N = n;<br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">quickMulit</span>(x, N) : <span class="hljs-number">1.0</span>/<span class="hljs-built_in">quickMulit</span>(x, -N);<br>    &#125;  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">quickMulit</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">long</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-type">double</span> y = <span class="hljs-built_in">quickMulit</span>(x, n / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//为奇数</span><br>            <span class="hljs-keyword">return</span> x * y * y;<br>        &#125;<br>        <span class="hljs-keyword">return</span> y * y;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-9-1047-删除字符串中的所有相邻重复项"><a href="#3-9-1047-删除字符串中的所有相邻重复项" class="headerlink" title="3.9 | 1047. 删除字符串中的所有相邻重复项"></a>3.9 | <a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h3><blockquote><h3 id="利用栈的性质解题-但注意的是-string-支持-pop-back-和-back-操作-我们可以直接将其理解为一个栈来做-「同样的道理-在a-b-hard中-我们也可以这样来用string-替代掉stack」"><a href="#利用栈的性质解题-但注意的是-string-支持-pop-back-和-back-操作-我们可以直接将其理解为一个栈来做-「同样的道理-在a-b-hard中-我们也可以这样来用string-替代掉stack」" class="headerlink" title="利用栈的性质解题 但注意的是 string 支持 pop_back() 和 back()操作  我们可以直接将其理解为一个栈来做 「同样的道理, 在a+b hard中, 我们也可以这样来用string 替代掉stack」"></a>利用栈的性质解题 但注意的是 string 支持 pop_back() 和 back()操作  我们可以直接将其理解为一个栈来做 「同样的道理, 在a+b hard中, 我们也可以这样来用string 替代掉stack」</h3></blockquote><h3 id="3-9-283-移动零-「把数组中某一特定值-此处是0-的元素-全部拿到队伍的末尾去」"><a href="#3-9-283-移动零-「把数组中某一特定值-此处是0-的元素-全部拿到队伍的末尾去」" class="headerlink" title="3.9 | 283 移动零 「把数组中某一特定值(此处是0)的元素 全部拿到队伍的末尾去」"></a>3.9 | 283 移动零 「把数组中某一特定值(此处是0)的元素 全部拿到队伍的末尾去」</h3><h2 id="「快慢指针」right指针一直前进-而left指针则停留在最后一个一定需要交换来解决问题的元素上-⚠️-在left-和right-都满足的时候-两者就都自加"><a href="#「快慢指针」right指针一直前进-而left指针则停留在最后一个一定需要交换来解决问题的元素上-⚠️-在left-和right-都满足的时候-两者就都自加" class="headerlink" title="「快慢指针」right指针一直前进,而left指针则停留在最后一个一定需要交换来解决问题的元素上 (⚠️ 在left 和right 都满足的时候, 两者就都自加)"></a>「快慢指针」right指针一直前进,而left指针则停留在最后一个一定需要交换来解决问题的元素上 (⚠️ 在left 和right 都满足的时候, 两者就都自加)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZero</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums )</span> </span>&#123;<br>  <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (right &lt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>      <span class="hljs-keyword">if</span> (nums[right]) <span class="hljs-built_in">swap</span>(nums[right], nums[left ++]);<br>      ++ right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-15-54-螺旋矩阵-螺旋输出一个矩阵"><a href="#3-15-54-螺旋矩阵-螺旋输出一个矩阵" class="headerlink" title="3.15 54. 螺旋矩阵 螺旋输出一个矩阵"></a>3.15 <a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a> 螺旋输出一个矩阵</h3><h3 id="考虑矩阵的四个角-「top-right-left-bottom-」-用这四个变量标记它们"><a href="#考虑矩阵的四个角-「top-right-left-bottom-」-用这四个变量标记它们" class="headerlink" title="考虑矩阵的四个角 「top right left bottom 」 用这四个变量标记它们"></a>考虑矩阵的四个角 「top right left bottom 」 用这四个变量标记它们</h3><ul><li><h3 id="此题由于输出的总数已经知道-我们应该设置一个恒定的标记-让它减少到0来判断是否应该结束循环-而不是加入超多的判断语句"><a href="#此题由于输出的总数已经知道-我们应该设置一个恒定的标记-让它减少到0来判断是否应该结束循环-而不是加入超多的判断语句" class="headerlink" title="此题由于输出的总数已经知道,我们应该设置一个恒定的标记 让它减少到0来判断是否应该结束循环,而不是加入超多的判断语句."></a>此题由于输出的总数已经知道,我们应该设置一个恒定的标记 让它减少到0来判断是否应该结束循环,而不是加入超多的判断语句.</h3></li></ul><hr><h3 id="3-14-检查5张牌是否为顺子-「排序后-看最大和最小-差距大于等于5-就不行啦」"><a href="#3-14-检查5张牌是否为顺子-「排序后-看最大和最小-差距大于等于5-就不行啦」" class="headerlink" title="3.14  检查5张牌是否为顺子 「排序后,看最大和最小 差距大于等于5 就不行啦」"></a>3.14  检查5张牌是否为顺子 「排序后,看最大和最小 差距大于等于5 就不行啦」</h3><h4 id="3-17-层序遍历-分层输出"><a href="#3-17-层序遍历-分层输出" class="headerlink" title="3.17  层序遍历,分层输出"></a>3.17  层序遍历,分层输出</h4><h4 id="分层的要点在于-我们在原有的while循环里加入一个for循环-对于原本就在队列中的n个结点-这个循环的目标就是把它们的孩子都加入队列-同时把它们都pop出去"><a href="#分层的要点在于-我们在原有的while循环里加入一个for循环-对于原本就在队列中的n个结点-这个循环的目标就是把它们的孩子都加入队列-同时把它们都pop出去" class="headerlink" title="分层的要点在于, 我们在原有的while循环里加入一个for循环, 对于原本就在队列中的n个结点,这个循环的目标就是把它们的孩子都加入队列, 同时把它们都pop出去."></a>分层的要点在于, 我们在原有的while循环里加入一个for循环, 对于原本就在队列中的n个结点,这个循环的目标就是把它们的孩子都加入队列, 同时把它们都pop出去.</h4><h4 id="3-17-股票的最大利润-「只可以买卖一次」「实际上就是求数组最大的元素差-其中大的元素一定要在小的后面」"><a href="#3-17-股票的最大利润-「只可以买卖一次」「实际上就是求数组最大的元素差-其中大的元素一定要在小的后面」" class="headerlink" title="3.17 股票的最大利润 「只可以买卖一次」「实际上就是求数组最大的元素差,其中大的元素一定要在小的后面」"></a>3.17 股票的最大利润 「只可以买卖一次」「实际上就是求数组最大的元素差,其中大的元素一定要在小的后面」</h4><p><code>minprice 保证了在位于 price处 时候, minprice一定是当前最小的那个值了.  而maxprice 则利用了这一点</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> price: nums) &#123;<br>      maxprofit = <span class="hljs-built_in">max</span>(maxprofit, price - minprice);<br>      minprice = <span class="hljs-built_in">min</span>(price, minprice);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-20-150-逆波兰表达式求值"><a href="#3-20-150-逆波兰表达式求值" class="headerlink" title="3.20 | 150. 逆波兰表达式求值"></a>3.20 | <a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h3><h4 id="逆波兰表达式的解法很简单-数字直接入栈-见运算符就把两个拿出来计算之后push回去-⚠️-isdigit-是对字符生效的函数-以及-stoi-字符串转int-函数-值的注意的是-没有itos-哦"><a href="#逆波兰表达式的解法很简单-数字直接入栈-见运算符就把两个拿出来计算之后push回去-⚠️-isdigit-是对字符生效的函数-以及-stoi-字符串转int-函数-值的注意的是-没有itos-哦" class="headerlink" title="逆波兰表达式的解法很简单, 数字直接入栈, 见运算符就把两个拿出来计算之后push回去.  ⚠️ isdigit 是对字符生效的函数, 以及 stoi  字符串转int 函数.  值的注意的是 没有itos 哦!"></a>逆波兰表达式的解法很简单, 数字直接入栈, 见运算符就把两个拿出来计算之后push回去.  ⚠️ isdigit 是对字符生效的函数, 以及 stoi  字符串转int 函数.  值的注意的是 没有itos 哦!</h4><hr><h4 id="3-22-爬楼梯"><a href="#3-22-爬楼梯" class="headerlink" title="3.22 | 爬楼梯"></a>3.22 | 爬楼梯</h4><h4 id="456-132-模式-「看数组里-是否有这样的三个元素-i-j-k-它们满足-i-lt-j-lt-k-同时-nums-i-lt-nums-k-lt-nums-j-」"><a href="#456-132-模式-「看数组里-是否有这样的三个元素-i-j-k-它们满足-i-lt-j-lt-k-同时-nums-i-lt-nums-k-lt-nums-j-」" class="headerlink" title="456. 132 模式  「看数组里 是否有这样的三个元素 i j k 它们满足 i &lt; j &lt; k, 同时 nums[i] &lt; nums[k] &lt; nums[j]」"></a><a href="https://leetcode-cn.com/problems/132-pattern/">456. 132 模式</a>  「看数组里 是否有这样的三个元素 i j k 它们满足 i &lt; j &lt; k, 同时 nums[i] &lt; nums[k] &lt; nums[j]」</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// i &lt; j &lt; k || nums[i] &lt; nums[k] &lt; nums[j]</span><br>    <span class="hljs-comment">// 这个题的问题在于 我们只需要知道有没有即可, 我们是不需要提供下标的!</span><br>    <span class="hljs-comment">// 不可以使用priorityqueue来存储k的所有可能性 想想为什么</span><br>   <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find132pattern</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left_min = nums[<span class="hljs-number">0</span>], j = <span class="hljs-number">1</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        multiset&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) s.<span class="hljs-built_in">insert</span>(nums[i]);<br>        <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (left_min &lt; nums[j]) &#123;<br>                <span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">begin</span>();<br>                <span class="hljs-keyword">while</span> (it != s.<span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">if</span> (*it &lt; nums[j] &amp;&amp; *it &gt; left_min) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    ++it;<br>                &#125;<br>            &#125;<br>            s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">find</span>(nums[j+<span class="hljs-number">1</span>])); <span class="hljs-comment">//这里使用erase 会一次删除掉所有值为val的元素,</span><br>            <span class="hljs-comment">// for (auto it = s.begin(); it != s.end(); ++it) &#123;</span><br>            <span class="hljs-comment">//     if (*it == nums[j+1]) &#123;</span><br>            <span class="hljs-comment">//         *it = 1e9+1;    </span><br>            <span class="hljs-comment">//     &#125;</span><br>            <span class="hljs-comment">// &#125;</span><br>            left_min = <span class="hljs-built_in">min</span>(left_min, nums[j++]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="x3D-x3D-⚠️-1-erase-如果里面直接给出元素-会直接删除所有的该元素-也可以使用find-这样只会删除第一个遇见的-2-迭代器只是遍历工具-我们是不能通过迭代器来修改容器内的值的-x3D-x3D"><a href="#x3D-x3D-⚠️-1-erase-如果里面直接给出元素-会直接删除所有的该元素-也可以使用find-这样只会删除第一个遇见的-2-迭代器只是遍历工具-我们是不能通过迭代器来修改容器内的值的-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;⚠️ 1. erase 如果里面直接给出元素, 会直接删除所有的该元素,  也可以使用find 这样只会删除第一个遇见的. 2.迭代器只是遍历工具, 我们是不能通过迭代器来修改容器内的值的!&#x3D;&#x3D;"></a>&#x3D;&#x3D;⚠️ 1. erase 如果里面直接给出元素, 会直接删除所有的该元素,  也可以使用find 这样只会删除第一个遇见的. 2.迭代器只是遍历工具, 我们是不能通过迭代器来修改容器内的值的!&#x3D;&#x3D;</h4><h3 id="4-12-179-最大数-「一个数组-把里面的数字拼成一个-字典序最大的字符串」"><a href="#4-12-179-最大数-「一个数组-把里面的数字拼成一个-字典序最大的字符串」" class="headerlink" title="4.12 179. 最大数 「一个数组 把里面的数字拼成一个 字典序最大的字符串」"></a>4.12 <a href="https://leetcode-cn.com/problems/largest-number/">179. 最大数</a> 「一个数组 把里面的数字拼成一个 字典序最大的字符串」</h3><blockquote><p>很容易想到在匿名函数里转字符串比较字典序. </p><h4 id="但我们可以直接利用整数来尝试拼接"><a href="#但我们可以直接利用整数来尝试拼接" class="headerlink" title="但我们可以直接利用整数来尝试拼接."></a>但我们可以直接利用整数来尝试拼接.</h4></blockquote><hr><h3 id="1738-找出第K大的异或坐标值「要注意前缀和从0开始」-https-leetcode-cn-com-x2F-problems-x2F-find-kth-largest-xor-coordinate-value-x2F"><a href="#1738-找出第K大的异或坐标值「要注意前缀和从0开始」-https-leetcode-cn-com-x2F-problems-x2F-find-kth-largest-xor-coordinate-value-x2F" class="headerlink" title="[1738. 找出第K大的异或坐标值「要注意前缀和从0开始」][https://leetcode- cn.com&#x2F;problems&#x2F;find-kth-largest-xor-coordinate-value&#x2F;]"></a>[1738. 找出第K大的异或坐标值「要注意前缀和从0开始」][<a href="https://leetcode-/">https://leetcode-</a> cn.com&#x2F;problems&#x2F;find-kth-largest-xor-coordinate-value&#x2F;]</h3><p>关于二维前缀和的解释如下: </p><p>所以 <code>prefix[i][j] = prefix[i][j-1]^prefix[i-1][j]^prefix[i-1][j-1]^matrix[i-1][j-1]</code></p><hr><h3 id="在342-4的幂"><a href="#在342-4的幂" class="headerlink" title="在342. 4的幂"></a>在<a href="https://leetcode-cn.com/problems/power-of-four/">342. 4的幂</a></h3><h5 id="1-偶数位上是1的32位整形-0xaaaaaaaa"><a href="#1-偶数位上是1的32位整形-0xaaaaaaaa" class="headerlink" title="1. 偶数位上是1的32位整形, 0xaaaaaaaa"></a>1. 偶数位上是1的32位整形, 0xaaaaaaaa</h5><h5 id="2-4-n-amp-3-x3D-x3D-1-利用的是数学法"><a href="#2-4-n-amp-3-x3D-x3D-1-利用的是数学法" class="headerlink" title="2. 4^n &amp; 3 &#x3D;&#x3D; 1 利用的是数学法"></a>2. 4^n &amp; 3 &#x3D;&#x3D; 1 利用的是数学法</h5><hr><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><ul><li><h4 id="accumulate-函数，到nums-begin-k，是不包括下标k的！并且-accmulate-所需要的时间是很短的-使用accumulate来检测数组中是否只有0是一个可行的选择。"><a href="#accumulate-函数，到nums-begin-k，是不包括下标k的！并且-accmulate-所需要的时间是很短的-使用accumulate来检测数组中是否只有0是一个可行的选择。" class="headerlink" title="accumulate 函数，到nums.begin()+k，是不包括下标k的！并且 accmulate 所需要的时间是很短的  使用accumulate来检测数组中是否只有0是一个可行的选择。"></a>accumulate 函数，到nums.begin()+k，是不包括下标k的！并且 accmulate 所需要的时间是很短的  使用accumulate来检测数组中是否只有0是一个可行的选择。</h4></li><li><p>index 从后往前遍历的时候 千万要注意 删除操作 对于index的位移</p></li><li><h3 id="如何用队列实现栈-「一个队列-每次push-都把队列转个圈」-如何用栈实现队列-「两个栈-in-x2F-out-push全部进入输入栈-每次执行pop或者top操作时如果输出栈为空就把输入栈的元素全部push进输出栈」"><a href="#如何用队列实现栈-「一个队列-每次push-都把队列转个圈」-如何用栈实现队列-「两个栈-in-x2F-out-push全部进入输入栈-每次执行pop或者top操作时如果输出栈为空就把输入栈的元素全部push进输出栈」" class="headerlink" title="如何用队列实现栈?  「一个队列 每次push 都把队列转个圈」 如何用栈实现队列? 「两个栈(in &#x2F; out) push全部进入输入栈, 每次执行pop或者top操作时如果输出栈为空就把输入栈的元素全部push进输出栈」"></a>如何用队列实现栈?  「一个队列 每次push 都把队列转个圈」 如何用栈实现队列? 「两个栈(in &#x2F; out) push全部进入输入栈, 每次执行pop或者top操作时如果输出栈为空就把输入栈的元素全部push进输出栈」</h3></li><li><h3 id="c-17-添加了新的特性-对于一个hashtable-dist-「for-auto-amp-y-x-dist」-x2F-x2F-顺序和原来相同"><a href="#c-17-添加了新的特性-对于一个hashtable-dist-「for-auto-amp-y-x-dist」-x2F-x2F-顺序和原来相同" class="headerlink" title="c++ 17 添加了新的特性 对于一个hashtable dist  「for (auto &amp;[y, x] : dist」&#x2F;&#x2F; 顺序和原来相同"></a>c++ 17 添加了新的特性 对于一个hashtable dist  「for (auto &amp;[y, x] : dist」&#x2F;&#x2F; 顺序和原来相同</h3></li><li><h2 id="两个变量交换"><a href="#两个变量交换" class="headerlink" title="两个变量交换"></a>两个变量交换</h2><blockquote><p>a &#x3D; a - b; b &#x3D; b - a; a &#x3D; a + b; &#x2F;&#x2F;法1</p><h3 id="a-x3D-a-b-b-x3D-a-b-a-x3D-a-b-x2F-x2F-法2"><a href="#a-x3D-a-b-b-x3D-a-b-a-x3D-a-b-x2F-x2F-法2" class="headerlink" title="a &#x3D; a ^ b ; b &#x3D; a ^ b; a &#x3D; a ^ b;  &#x2F;&#x2F; 法2"></a>a &#x3D; a ^ b ; b &#x3D; a ^ b; a &#x3D; a ^ b;  &#x2F;&#x2F; 法2</h3></blockquote></li></ul><h4 id="·想要返回正确的double值，把被除数转成double型，而不是把结果转为double"><a href="#·想要返回正确的double值，把被除数转成double型，而不是把结果转为double" class="headerlink" title="·想要返回正确的double值，把被除数转成double型，而不是把结果转为double"></a>·想要返回正确的double值，把被除数转成double型，而不是把结果转为double</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> <span class="hljs-built_in">double</span>(<span class="hljs-number">3</span>/<span class="hljs-number">2</span>) =&gt; <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">double</span>(<span class="hljs-number">3</span>)/<span class="hljs-number">2</span> =&gt; <span class="hljs-number">1.5</span><br></code></pre></td></tr></table></figure><ul><li><p>字符与int之间的转化是简单的,  只需要加减<code>&#39;0&#39; </code> 就可以了,   字符串则可以通过 stoi 和 to_string 函数来实现! </p></li><li><p>斐波那契数列 在n特别大时 采取矩阵快速幂的方法 能够求解 (滚动都太慢了)</p></li><li><h2 id="gt-操作符-和-操作符的区别-「-gt-左边是指针-左边是实体」-p-gt-a-p是指针-p-a-p是实体"><a href="#gt-操作符-和-操作符的区别-「-gt-左边是指针-左边是实体」-p-gt-a-p是指针-p-a-p是实体" class="headerlink" title="-&gt; 操作符 和 . 操作符的区别 「-&gt; 左边是指针  . 左边是实体」 (p -&gt; a()  p是指针,  p.a()  p是实体)"></a><code>-&gt;</code> 操作符 和 <code>.</code> 操作符的区别 「-&gt; 左边是指针  . 左边是实体」 <code>(p -&gt; a()  p是指针,  p.a()  p是实体)</code></h2></li><li></li><li><p><code>nth_element(res.begin(), res.begin() + k, res.end(), greater&lt;int&gt;()). </code> 寻找res中第k大的元素, 并将它放在第k个位置(默认是第k小)  「处理完之后,  K之前的全都比他大, K之后的全部比它小(比排序快上一点)」</p></li><li><p>STL copy </p><p>std::copy(start, end, container.begin());    &#x2F;&#x2F; container 是复制到的那个容器的第一个元素， 因为复制到这个已有元素后更加高效</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about string</title>
    <link href="/2021/04/20/about%20string%20/"/>
    <url>/2021/04/20/about%20string%20/</url>
    
    <content type="html"><![CDATA[<h1 id="about-string-字符串"><a href="#about-string-字符串" class="headerlink" title="about string 字符串"></a>about string 字符串</h1><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span> == #<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span> <span class="hljs-comment">//他们都是c语言的字符串库 ⚠️ 它们是不能定义string的 但可以使用字符串函数(如 strcpy)</span></span><br><br><span class="hljs-type">char</span>* <span class="hljs-type">char</span>[] <span class="hljs-comment">//都可以通过赋值 直接传给字符串对象 但字符串转到char[] 需要用data()或c_str()</span><br><br>string a, b<br><br>a.<span class="hljs-built_in">compare</span>(b); <span class="hljs-comment">//cmp函数 a和b相同返回0 a和b不同返回-1</span><br><br>a.<span class="hljs-built_in">find</span>(b); <span class="hljs-comment">// 寻找的是字符串</span><br><br>a.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">// 从下标3开始 截取2个字符.</span><br>a.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 从下标2开始的所有字符 (包括2).</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about Dynamic Programming</title>
    <link href="/2021/04/15/about%20DP/"/>
    <url>/2021/04/15/about%20DP/</url>
    
    <content type="html"><![CDATA[<h1 id="about-Dynamic-Programming-「DP-x2F-动态规划」"><a href="#about-Dynamic-Programming-「DP-x2F-动态规划」" class="headerlink" title="about Dynamic Programming 「DP&#x2F;动态规划」"></a>about Dynamic Programming 「DP&#x2F;动态规划」</h1><p>子问题最优则原始问题最优——贪心算法或者动态规划算法。<br>子问题最优则原始问题最优，且子问题互相独立——分治算法。<br>子问题最优不能推导出原始问题最优——暴力搜索等。</p><p>如果子问题最优则原问题最优，贪心算法。<br>如果子问题需要全部求解才能求解原问题，子问题互相独立，分治算法。<br>如果子问题最优不能保证原问题最优，但是子问题之间不会循环（所谓循环，是指从问题 A 拆解出子问题 B，然后子问题 B 又能拆解出子问题 A），考虑动态规划算法。<br>更加复杂的情况，我们总是可以考虑暴力搜索解决。</p><p>分治「Divide and Conquer Algorithm 」</p><p>值的注意的是 : 贪心算法在解决01背包问题的时候错误很明显 所以你最好能够证明这个题可以使用贪心算法. </p><p>分治和动态规划的思想区别本质在于: 分治的子问题毫无关联, 而动态规划则是子问题的嵌套「所以需要状态转移方程」</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划:"></a>动态规划:</h3><h3 id="在不问最优解-只问最优值的时候-可以尝试动态规划"><a href="#在不问最优解-只问最优值的时候-可以尝试动态规划" class="headerlink" title="在不问最优解 只问最优值的时候 可以尝试动态规划"></a>在不问最优解 只问最优值的时候 可以尝试动态规划</h3><ol><li><p>递归 直接基于状态转移方程来实现 </p></li><li><p>自顶向下(记忆化) 相当于是查表 「重叠子结构」</p></li><li><p>自底向上(迭代)  </p><ol><li><p>有了状态转移方程，我们就知道如何从最小的问题规模入手，然后不断地增加问题规模，直到所要求的问题规模为止。在这个过程中，我们同样地可以记忆每个问题规模的解来避免重复的计算。这种方法就是自底向上的方法，由于避免了递归，这是一种更好的办法。</p><p>但是迭代法需要有一个明确的迭代方向，例如线性，区间，树形，状态压缩等比较主流的动态规划问题中，迭代方向都有相应的模式。参考后面的例题。但是有一些问题迭代法方向是不确定的，这时可以退而求其次用记忆化来做，参考后面的例题。</p></li></ol></li></ol><h3 id="动态规划存在无后效性的原则-「状态必须是确定的」"><a href="#动态规划存在无后效性的原则-「状态必须是确定的」" class="headerlink" title="动态规划存在无后效性的原则 「状态必须是确定的」"></a>动态规划存在无后效性的原则 「状态必须是确定的」</h3><h4 id="e-g-丢n枚硬币-我们求其中k个朝上的概率是多少"><a href="#e-g-丢n枚硬币-我们求其中k个朝上的概率是多少" class="headerlink" title="e.g. 丢n枚硬币, 我们求其中k个朝上的概率是多少"></a>e.g. 丢n枚硬币, 我们求其中k个朝上的概率是多少</h4><h4 id="设立矩阵-p-i-j-其中i代表丢下第i枚硬币-j代表-其中在这次丢硬币之前有-j-枚朝上"><a href="#设立矩阵-p-i-j-其中i代表丢下第i枚硬币-j代表-其中在这次丢硬币之前有-j-枚朝上" class="headerlink" title="设立矩阵 p[i] [j] 其中i代表丢下第i枚硬币, j代表 其中在这次丢硬币之前有 j 枚朝上"></a>设立矩阵 p[i] [j] 其中i代表丢下第i枚硬币, j代表 其中在这次丢硬币<em>之前</em>有 j 枚朝上</h4><h4 id="显然-我们有这样的状态转移方程-p-i-j-x3D-p-i-1-j-1-0-5-p-i-1-j-0-5"><a href="#显然-我们有这样的状态转移方程-p-i-j-x3D-p-i-1-j-1-0-5-p-i-1-j-0-5" class="headerlink" title="显然 我们有这样的状态转移方程:  p[i] [j] &#x3D; p[i-1] [j-1] * 0.5 + p[i-1] [j] * 0.5"></a>显然 我们有这样的状态转移方程:  p[i] [j] &#x3D; p[i-1] [j-1] * 0.5 + p[i-1] [j] * 0.5</h4><h4 id="现在我们改变问题-当连续两次丢下硬币都朝着一面的时候-下一次丢硬币一定会是另一面-因为我们的状态里没有包含前两次的结果-所以显然刚才的状态方程是错误的-如果想要使用动态规划-这里应该添加两个维度-来存储上一次-和上上次的结果"><a href="#现在我们改变问题-当连续两次丢下硬币都朝着一面的时候-下一次丢硬币一定会是另一面-因为我们的状态里没有包含前两次的结果-所以显然刚才的状态方程是错误的-如果想要使用动态规划-这里应该添加两个维度-来存储上一次-和上上次的结果" class="headerlink" title="现在我们改变问题  当连续两次丢下硬币都朝着一面的时候,  下一次丢硬币一定会是另一面.  因为我们的状态里没有包含前两次的结果, 所以显然刚才的状态方程是错误的,  如果想要使用动态规划, 这里应该添加两个维度, 来存储上一次 和上上次的结果."></a>现在我们改变问题  当连续两次丢下硬币都朝着一面的时候,  下一次丢硬币一定会是另一面.  因为我们的状态里没有包含前两次的结果, 所以显然刚才的状态方程是错误的,  如果想要使用动态规划, 这里应该添加两个维度, 来存储上一次 和上上次的结果.</h4><h3 id="动态规划的最优子结构-「在设计状态的时候-我们应当保证最优的状态只从之前的最优状态来-而不是从之前的非最优状态来」"><a href="#动态规划的最优子结构-「在设计状态的时候-我们应当保证最优的状态只从之前的最优状态来-而不是从之前的非最优状态来」" class="headerlink" title="动态规划的最优子结构 「在设计状态的时候, 我们应当保证最优的状态只从之前的最优状态来, 而不是从之前的非最优状态来」"></a>动态规划的最优子结构 「在设计状态的时候, 我们应当保证最优的状态只从之前的最优状态来, 而不是从之前的非最优状态来」</h3><h4 id="比如01背包问题-如果我们加入一个条件-某两件物品一起拿能够产生额外价值-那么就不适用动态规划了"><a href="#比如01背包问题-如果我们加入一个条件-某两件物品一起拿能够产生额外价值-那么就不适用动态规划了" class="headerlink" title="比如01背包问题, 如果我们加入一个条件, 某两件物品一起拿能够产生额外价值,  那么就不适用动态规划了."></a>比如01背包问题, 如果我们加入一个条件, 某两件物品一起拿能够产生额外价值,  那么就不适用动态规划了.</h4><h3 id="重叠子结构"><a href="#重叠子结构" class="headerlink" title="重叠子结构"></a>重叠子结构</h3><p>比如在解斐波那契的时候 , 我们加入一个dp[n], 存储每一次的答案, 不需要重复计算,</p><h3 id="动态规划例题"><a href="#动态规划例题" class="headerlink" title="动态规划例题:"></a>动态规划例题:</h3><h4 id="1-编辑距离-II-在编辑距离的基础上-不允许插入操作-这意味着在A删除和在B删除是有区别的"><a href="#1-编辑距离-II-在编辑距离的基础上-不允许插入操作-这意味着在A删除和在B删除是有区别的" class="headerlink" title="1. 编辑距离 II 在编辑距离的基础上, 不允许插入操作, 这意味着在A删除和在B删除是有区别的"></a>1. 编辑距离 II 在编辑距离的基础上, 不允许插入操作, 这意味着在A删除和在B删除是有区别的</h4><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 在A中删除一个字符 或者替换</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">edit_distance</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>(), m = t.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span> (!(n * m)) <span class="hljs-keyword">return</span> m + n;<br>        <br>        <span class="hljs-comment">// 请务必注意dp边界的初始化 请一定要注意</span><br>        <span class="hljs-type">int</span> dp[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) dp[<span class="hljs-number">0</span>][i] = i;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (s[i<span class="hljs-number">-1</span>] == t[j<span class="hljs-number">-1</span>]) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                <span class="hljs-comment">// 问题就在于 s的子串长度一定要超过 t 的子串长度. 否则不应删减掉</span><br>                <span class="hljs-keyword">else</span> dp[i][j] = i &gt; j ? <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j])+<span class="hljs-number">1</span> : dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];   <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-打家劫舍I-「给定一个序列-我们不能连着偷相邻的两家-求我们能获取的最大利润是多少」"><a href="#2-打家劫舍I-「给定一个序列-我们不能连着偷相邻的两家-求我们能获取的最大利润是多少」" class="headerlink" title="2. 打家劫舍I 「给定一个序列, 我们不能连着偷相邻的两家, 求我们能获取的最大利润是多少」"></a>2. 打家劫舍I 「给定一个序列, 我们不能连着偷相邻的两家, 求我们能获取的最大利润是多少」</h3><blockquote><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p></blockquote><blockquote><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p></blockquote><h4 id="思路-四种DP的方式-「无非就是从增加维度控制后效性-rightarrow-不增加维度的dp优化」"><a href="#思路-四种DP的方式-「无非就是从增加维度控制后效性-rightarrow-不增加维度的dp优化」" class="headerlink" title="思路: 四种DP的方式  「无非就是从增加维度控制后效性 $\rightarrow$ 不增加维度的dp优化」"></a>思路: 四种DP的方式  「无非就是从增加维度控制后效性 $\rightarrow$ 不增加维度的dp优化」</h4><ol><li><h5 id="2维DP-dp-i-0-代表不偷第-i-间-前i间房能获取的最大利润-dp-i-1-则是偷第i间-显然-dp-i-0-x3D-max-dp-i-1-1-dp-i-1-0-而dp-i-1-x3D-dp-i-1-0-nums-i-因为偷这一间意味着上一间肯定不能偷啦"><a href="#2维DP-dp-i-0-代表不偷第-i-间-前i间房能获取的最大利润-dp-i-1-则是偷第i间-显然-dp-i-0-x3D-max-dp-i-1-1-dp-i-1-0-而dp-i-1-x3D-dp-i-1-0-nums-i-因为偷这一间意味着上一间肯定不能偷啦" class="headerlink" title="2维DP dp[i] [0] 代表不偷第 i 间, 前i间房能获取的最大利润  dp[i] [1]则是偷第i间. 显然 dp[i] [0] &#x3D; max(dp[i-1] [1], dp[i-1] [0]), 而dp[i] [1] &#x3D; dp[i-1] [0] + nums[i] (因为偷这一间意味着上一间肯定不能偷啦 )"></a>2维DP dp[i] [0] 代表不偷第 i 间, 前i间房能获取的最大利润  dp[i] [1]则是偷第i间. 显然 dp[i] [0] &#x3D; max(dp[i-1] [1], dp[i-1] [0]), 而dp[i] [1] &#x3D; dp[i-1] [0] + nums[i] (因为偷这一间意味着上一间肯定不能偷啦 )</h5></li><li><h4 id="1维DP-法1"><a href="#1维DP-法1" class="headerlink" title="1维DP 法1"></a>1维DP 法1</h4><ul><li><em><strong>这种思路是错误的</strong></em> 「我们通过dp[i-1」和dp[i-2]是否相同来判断是否可以偷第[i]间, 但是问题就在于, 每两间房必会偷一间, 但显然, 这种方式无法每次都找到最优解.</li></ul></li><li><h4 id="1维DP-法2"><a href="#1维DP-法2" class="headerlink" title="1维DP 法2"></a>1维DP 法2</h4><ul><li><h5 id="dp-i-确实有两种情况-1-不偷-dp-i-x3D-dp-i-1-显然-上一个房间也不一定非要偷-2-偷-dp-i-x3D-dp-i-2-nums-i"><a href="#dp-i-确实有两种情况-1-不偷-dp-i-x3D-dp-i-1-显然-上一个房间也不一定非要偷-2-偷-dp-i-x3D-dp-i-2-nums-i" class="headerlink" title="dp[i] 确实有两种情况  1. 不偷 dp[i] &#x3D; dp[i-1] (显然, 上一个房间也不一定非要偷)  2. 偷 dp[i] &#x3D; dp[i-2] + nums[i];"></a>dp[i] 确实有两种情况  1. 不偷 dp[i] &#x3D; dp[i-1] (显然, 上一个房间也不一定非要偷)  2. 偷 dp[i] &#x3D; dp[i-2] + nums[i];</h5></li><li><h5 id="所以dp-i-x3D-max-dp-i-1-dp-i-2-nums-i"><a href="#所以dp-i-x3D-max-dp-i-1-dp-i-2-nums-i" class="headerlink" title="所以dp[i] &#x3D; max(dp[i-1], dp[i-2]+nums[i])"></a>所以dp[i] &#x3D; max(dp[i-1], dp[i-2]+nums[i])</h5></li></ul></li><li><h4 id="0维DP-直接上代码-两个变量相互继承-有点类似之前做过的最长湍流子数组-是吗"><a href="#0维DP-直接上代码-两个变量相互继承-有点类似之前做过的最长湍流子数组-是吗" class="headerlink" title="0维DP 直接上代码 两个变量相互继承, 有点类似之前做过的最长湍流子数组? 是吗"></a>0维DP 直接上代码 两个变量相互继承, 有点类似之前做过的最长湍流子数组? 是吗</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <br>        <span class="hljs-type">int</span> rob = nums[<span class="hljs-number">0</span>], nrob = nums[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> temp = rob;<br>            rob = <span class="hljs-built_in">max</span> (rob, nrob);<br>            nrob = temp + nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(rob, nrob);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="打家截舍II-现在第一间房屋和最后一间房屋连起来-偷第一间就不可以偷最后一间"><a href="#打家截舍II-现在第一间房屋和最后一间房屋连起来-偷第一间就不可以偷最后一间" class="headerlink" title="打家截舍II  现在第一间房屋和最后一间房屋连起来 偷第一间就不可以偷最后一间"></a>打家截舍II  现在第一间房屋和最后一间房屋连起来 偷第一间就不可以偷最后一间</h3><blockquote><p>改变区间就可以了. 如果偷第一家 就把最后一家从区间中去掉.  (根据一维dp法2来做)</p></blockquote></li></ol><h2 id="3-预测赢家-「给定一组牌-数组-我们只能从最后或者最前面拿牌-玩家1先手-我们-希望能在给定序列的情况下-提前知道玩家1是否可以赢-假设两名玩家都绝顶聪明-」"><a href="#3-预测赢家-「给定一组牌-数组-我们只能从最后或者最前面拿牌-玩家1先手-我们-希望能在给定序列的情况下-提前知道玩家1是否可以赢-假设两名玩家都绝顶聪明-」" class="headerlink" title="3. 预测赢家 「给定一组牌(数组), 我们只能从最后或者最前面拿牌, 玩家1先手, 我们 希望能在给定序列的情况下, 提前知道玩家1是否可以赢(假设两名玩家都绝顶聪明)」"></a>3. 预测赢家 「给定一组牌(数组), 我们只能从最后或者最前面拿牌, 玩家1先手, 我们 希望能在给定序列的情况下, 提前知道玩家1是否可以赢(假设两名玩家都绝顶聪明)」</h2><h3 id="此题出现了-dp-i-由-dp-i-1-和-dp-i-2-推导而来的情况-我们需要通过一个矩阵来解决这个问题-麻烦画一下-现在我懒得画了-其实比较容易"><a href="#此题出现了-dp-i-由-dp-i-1-和-dp-i-2-推导而来的情况-我们需要通过一个矩阵来解决这个问题-麻烦画一下-现在我懒得画了-其实比较容易" class="headerlink" title="此题出现了 dp[i]由 dp[i+1] 和 dp[i+2] 推导而来的情况, 我们需要通过一个矩阵来解决这个问题. 麻烦画一下 现在我懒得画了 其实比较容易."></a>此题出现了 dp[i]由 dp[i+1] 和 dp[i+2] 推导而来的情况, 我们需要通过一个矩阵来解决这个问题. 麻烦画一下 现在我懒得画了 其实比较容易.</h3><blockquote><h4 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h4><p>输入：[1, 5, 2]<br>输出：False<br>解释：一开始，玩家1可以从1和2中进行选择。<br>如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。<br>所以，玩家 1 的最终分数为 1 + 2 &#x3D; 3，而玩家 2 为 5 。<br>因此，玩家 1 永远不会成为赢家，返回 False 。</p><h4 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2"></a>示例2</h4><p>输入：[1, 5, 233, 7]<br>输出：True<br>解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。<br>     最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// dp[i][j] 表示玩家1 在牌i到牌j可以拿到的最大分数; 最终的结果是 dp[i][nums.size()-1]</span><br>    <span class="hljs-comment">// dp[i][j] = max (left, right);  left -&gt; 拿左边的, right -&gt; 拿右边的</span><br>    <span class="hljs-comment">// left = min(dp[i+1][j-1], dp[i+2][j]) + nums[i] 站在玩家2的角度上思考,他必然选择最优解, 这意味着玩家1之后将拿到的只能是最小值. </span><br>    <span class="hljs-comment">// right = min(dp[i+1][j-1], dp[i][j-2]) + nums[j];</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PredictTheWinner</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(), sum = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) dp[i][i] = nums[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) dp[i][i+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[i], nums[i+<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">3</span>; l &lt;= n; ++l) &#123;<br>            <span class="hljs-comment">//l作为长度, 最开始至少有3三张, 我们从前3张卡开始,不断的向外扩散</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + l - <span class="hljs-number">1</span> &lt; n; ++i) &#123;<br>                <span class="hljs-type">int</span> j = i + l - <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> left = <span class="hljs-built_in">min</span>(dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>], dp[i+<span class="hljs-number">2</span>][j]) + nums[i];<br>                <span class="hljs-type">int</span> right = <span class="hljs-built_in">min</span>(dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>], dp[i][j<span class="hljs-number">-2</span>]) + nums[j];<br>                dp[i][j] = <span class="hljs-built_in">max</span>(left, right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>] &gt;= sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>备注：当手牌为奇数的时候，先手必胜。</p><hr><h2 id="4-礼物的最大价值-「有的时候-我们可以直接在原数组上dp-不需要空间」"><a href="#4-礼物的最大价值-「有的时候-我们可以直接在原数组上dp-不需要空间」" class="headerlink" title="4. 礼物的最大价值 「有的时候 我们可以直接在原数组上dp, 不需要空间」"></a>4. 礼物的最大价值 「有的时候 我们可以直接在原数组上dp, 不需要空间」</h2><h4 id="剑指offer-47-在一个-m-n-的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于-0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？"><a href="#剑指offer-47-在一个-m-n-的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于-0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？" class="headerlink" title="剑指offer 47 :在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？"></a>剑指offer 47 :在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>(), n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j];</span><br>        <span class="hljs-comment">// vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));</span><br>        <span class="hljs-comment">// // 我从左上角拿 那也意味着想要顺着边拿只能一直往下或一直往右.</span><br>        <span class="hljs-comment">// dp[0][0] = grid[0][0];</span><br>        <span class="hljs-comment">// for (int i = 1; i &lt; m; ++i) dp[i][0] = dp[i-1][0] + grid[i][0];</span><br>        <span class="hljs-comment">// for (int i = 1; i &lt; n; ++i) dp[0][i] = dp[0][i-1] + grid[0][i];</span><br>        <span class="hljs-comment">// for (int i = 1; i &lt; m; ++i) &#123;</span><br>        <span class="hljs-comment">//     for (int j = 1; j &lt; n; ++j) &#123;</span><br>        <span class="hljs-comment">//         dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j];</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// return dp[m-1][n-1];</span><br>        <br>        <span class="hljs-comment">// 我们可以直接用grid数组本身代替dp数组 以下为优化方案. </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i) grid[i][<span class="hljs-number">0</span>] += grid[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) grid[<span class="hljs-number">0</span>][i] += grid[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; ++j) grid[i][j] += <span class="hljs-built_in">max</span>(grid[i<span class="hljs-number">-1</span>][j], grid[i][j<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">return</span> grid[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about Binary Search</title>
    <link href="/2021/04/07/about%20Binary%20Search%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2021/04/07/about%20Binary%20Search%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="about-Binary-Search-二分查找"><a href="#about-Binary-Search-二分查找" class="headerlink" title="about Binary Search 二分查找"></a>about Binary Search 二分查找</h1><h3 id="普通的二分查找"><a href="#普通的二分查找" class="headerlink" title="普通的二分查找"></a>普通的二分查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinarySearch_nonrecursive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;  <span class="hljs-comment">//不加 = 如果数组长度为1 会错</span><br>        <span class="hljs-type">int</span> mid = (left + right)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//递归 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinarySearch_recursive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (nums[mid] &gt; target) <span class="hljs-keyword">return</span> <span class="hljs-built_in">BinarySearch_recursive</span>(nums, target, left, mid - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) <span class="hljs-keyword">return</span> <span class="hljs-built_in">BinarySearch_recursive</span>(nums, target, mid + <span class="hljs-number">1</span>, right);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如果你只想要二分查找找到的第一个："><a href="#如果你只想要二分查找找到的第一个：" class="headerlink" title="如果你只想要二分查找找到的第一个："></a>如果你只想要二分查找找到的第一个：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinarySearch_First_nonrecursive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123; <span class="hljs-comment">//查找第一个</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = (left + right)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[left] == target ? left : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>(l + r + 1) &gt;&gt; 1; 进阶的 (r - l)&#x2F;2 + l;</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about vector</title>
    <link href="/2021/04/05/about%20vector/"/>
    <url>/2021/04/05/about%20vector/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; a,b; <span class="hljs-comment">//缺省所有参数时 size直接为0的</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span> <span class="hljs-comment">//注意不使用[] 使用()来选定大小 值默认为0</span><br><br><span class="hljs-built_in">vector</span>&lt;&gt;::reverse_iterator i;<span class="hljs-comment">//在STL库中定义反向迭代器 </span><br><span class="hljs-comment">//迭代器可以用来遍历，反向迭代器++之后往前移动 通过加*号的迭代器 也可以直接访问数组元素的值(作为在STL中封装好的指针来使用)</span><br>begin(),end(),rbegin(),rend(); <span class="hljs-comment">//后两个的意思</span><br><br>a.assign(b.begin(),b.begin()+<span class="hljs-number">3</span>); <span class="hljs-comment">//b数组的前3个元素分给a</span><br>a.assign(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//4个2</span><br><br>a.back(); a.front(); a[i]; a.clear(); a.empty(); a.pop_back();<br><br><span class="hljs-comment">//删除a中第一个（从第0个算起）到第二个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）结束</span><br>a.erase(a.begin()+<span class="hljs-number">1</span>,a.begin()+<span class="hljs-number">3</span>);<br>a.push_back(); a.emplace_back(); <span class="hljs-comment">//两者一样功能 建议使用emplace 优化内存 c++11可以使用</span><br><br>a.insert(a.begin()+<span class="hljs-number">1</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">//第一个参数就是插入值之后这个值在数组里的下标！注意使用迭代器(前插)</span><br>a.insert(a.begin()+<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">//可以连续插入多个一样的 插入个数是第二个参数</span><br>a.inse3rt(a.begin()+<span class="hljs-number">1</span>,b+<span class="hljs-number">3</span>,b+<span class="hljs-number">6</span>); <span class="hljs-comment">//b是数组，在1号下标插入 b的[3,6)下标元素(不包括最后一个)</span><br><br>a.size();a.capacity(); <span class="hljs-comment">//返回数组大小 由于在空间不够时vector每次都直接扩大一倍，size返回的是元素的个数 而capacity返回的是现在vector能容纳多少个元素</span><br><br>a.resize(<span class="hljs-number">10</span>); <span class="hljs-comment">//把长度变成10 多删 少补(值随机)</span><br>a.resize(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//与上面的区别在于补的数值默认为2</span><br>a.reserve(<span class="hljs-number">100</span>); <span class="hljs-comment">//注意和reverse区分 注意：reserve是保留空间，但不创建对象(resize的可以直接调用)</span><br><br><br>a.swap(b); <span class="hljs-comment">//交换向量a和b</span><br><span class="hljs-comment">//b为向量，向量的比较操作还有 != &gt;= &gt; &lt;= &lt;</span><br>a==b;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(a.begin(), a.begin()+k) ; 我们可以通过这个语句 来返回数组的 前k项<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><ol><li><p><strong>vector 没有length() 函数</strong></p></li><li><p>&#x3D;&#x3D;<strong>vector 只能push_back 和 pop_back 从头插入 使用insert(a.begin(), value)</strong>&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;<strong>所有的STL返回整型 全部都是 unsigned long 我们需要在前面加括号 用int型接收它们</strong>&#x3D;&#x3D;</p></li><li><p><strong>size 和 capicity 大部分时候不需要关注</strong></p></li><li><p>&#x3D;&#x3D;在你直接初始化一个二维数组时 你可以使用memset 也可以这样&#x3D;&#x3D;</p><p>&#x3D;&#x3D;<code>vector&lt;vector&lt;int&gt;&gt; (5, vector&lt;int&gt;(6,1))</code> 显然 这里用了套娃的属性&#x3D;&#x3D;</p></li><li><p><strong>少使用push_back() 要使用emplace_back();</strong></p></li><li><p>**vector&lt;pair &lt;int, int&gt; &gt; 或者 vector&lt;vector&lt;int,int&gt; &gt;(在用sort比较时 会先比较first 如果first相同，再比较second **</p></li></ol></blockquote><ul><li>关于<code>pair</code> <ul><li>Pair 定义有序对 是结构体 调用使用 <code>.first</code> 和 <code>.second</code> 比较时也是先比较first 再比较second</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about Search</title>
    <link href="/2021/03/18/about%20Search/"/>
    <url>/2021/03/18/about%20Search/</url>
    
    <content type="html"><![CDATA[<h1 id="about-Search"><a href="#about-Search" class="headerlink" title="about Search"></a>about Search</h1><h2 id="深度优先搜索「一条路走到底，不撞南墙不回头」"><a href="#深度优先搜索「一条路走到底，不撞南墙不回头」" class="headerlink" title="深度优先搜索「一条路走到底，不撞南墙不回头」"></a>深度优先搜索「一条路走到底，不撞南墙不回头」</h2><ul><li><h5 id="深度优先遍历-只要前面有可以走的路，就会一直向前走，直到无路可走才会回头；"><a href="#深度优先遍历-只要前面有可以走的路，就会一直向前走，直到无路可走才会回头；" class="headerlink" title="深度优先遍历 只要前面有可以走的路，就会一直向前走，直到无路可走才会回头；"></a>深度优先遍历 只要前面有可以走的路，就会一直向前走，直到无路可走才会回头；</h5></li><li><h4 id="「无路可走」有两种情况：①-遇到了墙；②-遇到了已经走过的路；"><a href="#「无路可走」有两种情况：①-遇到了墙；②-遇到了已经走过的路；" class="headerlink" title="「无路可走」有两种情况：① 遇到了墙；② 遇到了已经走过的路；"></a>「无路可走」有两种情况：① 遇到了墙；② 遇到了已经走过的路；</h4></li><li><p>在「无路可走」的时候，沿着原路返回，直到回到了还有未走过的路的路口，尝试继续走没有走过的路径；有一些路径没有走到，这是因为找到了出口，程序就停止了；</p></li><li><p>「深度优先遍历」也叫「深度优先搜索」，遍历是行为的描述，搜索是目的（用途）；</p></li><li><p>遍历不是很深奥的事情，把 所有 可能的情况都看一遍，才能说「找到了目标元素」或者「没找到目标元素」。遍历也称为 穷举，穷举的思想在人类看来虽然很不起眼，但借助 计算机强大的计算能力，穷举可以帮助我们解决很多专业领域知识不能解决的问题。</p></li><li><h3 id="n皇后问题「n个皇后位于nxn的棋盘-她们不可互相攻击-横-竖-斜-都不可以在一列上-」"><a href="#n皇后问题「n个皇后位于nxn的棋盘-她们不可互相攻击-横-竖-斜-都不可以在一列上-」" class="headerlink" title="n皇后问题「n个皇后位于nxn的棋盘, 她们不可互相攻击(横 竖 斜 都不可以在一列上)」"></a>n皇后问题「n个皇后位于nxn的棋盘, 她们不可互相攻击(横 竖 斜 都不可以在一列上)」</h3></li><li><h4 id="解决这个问题的思路是尝试每一种可能，然后逐个判断。只不过回溯算法按照一定的顺序进行尝试，在一定不可能得到解的时候进行剪枝，进而减少了尝试的可能。"><a href="#解决这个问题的思路是尝试每一种可能，然后逐个判断。只不过回溯算法按照一定的顺序进行尝试，在一定不可能得到解的时候进行剪枝，进而减少了尝试的可能。" class="headerlink" title="解决这个问题的思路是尝试每一种可能，然后逐个判断。只不过回溯算法按照一定的顺序进行尝试，在一定不可能得到解的时候进行剪枝，进而减少了尝试的可能。"></a>解决这个问题的思路是尝试每一种可能，然后逐个判断。只不过回溯算法按照一定的顺序进行尝试，<strong>在一定不可能得到解的时候进行剪枝</strong>，进而减少了尝试的可能。</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayDeque;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 记录某一列是否放置了皇后</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] col;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 记录主对角线上的单元格是否放置了皇后</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] main;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 记录了副对角线上的单元格是否放置了皇后</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] sub;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;List&lt;String&gt;&gt; res;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-comment">// 设置成员变量，减少参数传递，具体作为方法参数还是作为成员变量，请参考团队开发规范</span><br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.col = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-built_in">this</span>.main = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">this</span>.sub = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>];<br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        dfs(<span class="hljs-number">0</span>, path);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row, Deque&lt;Integer&gt; path)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            <span class="hljs-comment">// 深度优先遍历到下标为 n，表示 [0.. n - 1] 已经填完，得到了一个结果</span><br>            List&lt;String&gt; board = convert2board(path);<br>            res.add(board);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 针对下标为 row 的每一列，尝试是否可以放置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!col[j] &amp;&amp; !main[row - j + n - <span class="hljs-number">1</span>] &amp;&amp; !sub[row + j]) &#123;<br>                path.addLast(j);<br>                col[j] = <span class="hljs-literal">true</span>;<br>                main[row - j + n - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                sub[row + j] = <span class="hljs-literal">true</span>;<br>                dfs(row + <span class="hljs-number">1</span>, path);<br>                sub[row + j] = <span class="hljs-literal">false</span>;<br>                main[row - j + n - <span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>                col[j] = <span class="hljs-literal">false</span>;<br>                path.removeLast();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">convert2board</span><span class="hljs-params">(Deque&lt;Integer&gt; path)</span> &#123;<br>        List&lt;String&gt; board = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Integer num : path) &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            row.append(<span class="hljs-string">&quot;.&quot;</span>.repeat(Math.max(<span class="hljs-number">0</span>, n)));<br>            row.replace(num, num + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Q&quot;</span>);<br>            board.add(row.toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> board;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        vis = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>);<br>        tmp = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n);<br>        <span class="hljs-comment">//从0层递归到n层 ，这里我们无需判断某一层是否有多个皇后，因为我们</span><br>        <span class="hljs-comment">//是按照层来递归，一层只有一个皇后</span><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">const</span> <span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-comment">//到达n层，存储一个可行解</span><br>        <span class="hljs-keyword">if</span>(k == n)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;string&gt;(n, <span class="hljs-built_in">string</span>(n, <span class="hljs-string">&#x27;.&#x27;</span>)));<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>                ans.<span class="hljs-built_in">back</span>()[i][tmp[i]] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>            <span class="hljs-comment">//该列已经有皇后了，不能放置</span><br>            <span class="hljs-keyword">if</span>(vis[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//第k行第i个位置放皇后</span><br>            tmp[k] = i;<br>            vis[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(k))<br>                <span class="hljs-built_in">dfs</span>(k + <span class="hljs-number">1</span>, n);<br>            vis[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//和之前已经放置过的皇后判断是否在对角线、斜对角线上</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i ++)&#123;<br>            <span class="hljs-keyword">if</span>(tmp[i] - i == tmp[k] - k || tmp[i] + i == tmp[k] + k)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//判断某一列上是否有皇后</span><br>    vector&lt;<span class="hljs-type">bool</span>&gt; vis;<br>    <span class="hljs-comment">//保存答案</span><br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    <span class="hljs-comment">//存储每一层皇后的位置</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="DFS的方向模版"><a href="#DFS的方向模版" class="headerlink" title="DFS的方向模版"></a>DFS的方向模版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> row, column;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; vis, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span>&amp; maxn)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= row || y &lt; <span class="hljs-number">0</span> || y &gt;= column || vis[x][y] || grid[x][y] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ++maxn;<br>        vis[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> dx = x + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> dy = y + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">dfs</span>(grid, vis, dx, dy, maxn);<br>        &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about Sort</title>
    <link href="/2021/03/14/about%20Sort/"/>
    <url>/2021/03/14/about%20Sort/</url>
    
    <content type="html"><![CDATA[<h1 id="about-Sort"><a href="#about-Sort" class="headerlink" title="about Sort"></a>about Sort</h1><h2 id="稳定排序-x2F-不稳定排序-「相同的元素-在排序前后-仍然处于相同顺序-rightarrow-稳定排序」"><a href="#稳定排序-x2F-不稳定排序-「相同的元素-在排序前后-仍然处于相同顺序-rightarrow-稳定排序」" class="headerlink" title="稳定排序&#x2F;不稳定排序 「相同的元素 在排序前后 仍然处于相同顺序 $\rightarrow$ 稳定排序」"></a>稳定排序&#x2F;不稳定排序 「相同的元素 在排序前后 仍然处于相同顺序 $\rightarrow$ 稳定排序」</h2><hr><ul><li><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2></li></ul><h5 id="Pivot-算法-「每次选择一个参考数-小于这个参考数的放在左边-大于它的放在右边-x2F-x2F-这个参考数当然也在合适的位置」"><a href="#Pivot-算法-「每次选择一个参考数-小于这个参考数的放在左边-大于它的放在右边-x2F-x2F-这个参考数当然也在合适的位置」" class="headerlink" title="Pivot 算法 「每次选择一个参考数 小于这个参考数的放在左边 大于它的放在右边 &#x2F;&#x2F; 这个参考数当然也在合适的位置」"></a>Pivot 算法 「每次选择一个参考数 小于这个参考数的放在左边 大于它的放在右边 &#x2F;&#x2F; 这个参考数当然也在合适的位置」</h5><h4 id="找出参考数之后-向左右部分递归调用Pivot算法-每次调用算法-会产生一个参考数-它一定会在最后正确的位置-如果参考数每次都处在中间位置-那么为O-nlogn-级别-但在最差情况下会退化到n-2"><a href="#找出参考数之后-向左右部分递归调用Pivot算法-每次调用算法-会产生一个参考数-它一定会在最后正确的位置-如果参考数每次都处在中间位置-那么为O-nlogn-级别-但在最差情况下会退化到n-2" class="headerlink" title="找出参考数之后 向左右部分递归调用Pivot算法 每次调用算法 会产生一个参考数 它一定会在最后正确的位置      如果参考数每次都处在中间位置 那么为O((nlogn))级别 但在最差情况下会退化到n^2"></a>找出参考数之后 向左右部分递归调用Pivot算法 每次调用算法 会产生一个参考数 它一定会在<em><strong>最后正确</strong></em>的位置      如果参考数每次都处在中间位置 那么为O((nlogn))级别 但在最差情况下会退化到n^2</h4><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义 pivot 函数，他会以数组第一个数作为参考数，并会按上述规则调整数组，并返回参考数的下标</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pivot</span>(<span class="hljs-params">a</span>):<br>    <span class="hljs-comment"># 首先我们分析一下边界情况，首先如果只有一个数，这种情况下数组已经是有序的了，我们返回 -1 代表不需要再继续后面的过程。那如果是两个数的话，我们可以直接比较大小然后给出正确排序，也不需要 pivot 过程了。我们仍然返回 -1。</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a) == <span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a) == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">if</span> a[<span class="hljs-number">0</span>] &gt; a[<span class="hljs-number">1</span>]:<br>            a[<span class="hljs-number">0</span>],a[<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>],a[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-comment"># 那么接下来我们就得进行我们的算法了，首先按我们刚才说的，我们假设参考数是第一个值。同时我们定义两个指针，i 指向 1，j 指向末尾。</span><br>    pivot = a[<span class="hljs-number">0</span>]<br>    i = <span class="hljs-number">1</span>; j = <span class="hljs-built_in">len</span>(a)-<span class="hljs-number">1</span><br>    <span class="hljs-comment"># 如果 i 和 j 还没重叠的话</span><br>    <span class="hljs-keyword">while</span> i &lt; j:<br>        <span class="hljs-comment"># 我们比较 a[i] 和 pivot 的大小关系，直到碰到第一个 a[i] 大于 pivot，或者 i 等于 j 就退出</span><br>        <span class="hljs-keyword">while</span> a[i] &lt; pivot <span class="hljs-keyword">and</span> i &lt; j:<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 对 a[j] 进行类似操作</span><br>        <span class="hljs-keyword">while</span> a[j] &gt; pivot <span class="hljs-keyword">and</span> i &lt; j:<br>            j -= <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 如果 i, j 重合，就可以退出了</span><br>        <span class="hljs-keyword">if</span> i == j:<span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># 交换 a[i], a[j] 继续算法</span><br>        a[i],a[j] = a[j],a[i]<br>    <span class="hljs-comment"># 最后交换 pivot</span><br>    <span class="hljs-keyword">if</span> a[i] &gt; a[<span class="hljs-number">0</span>]:<br>        a[<span class="hljs-number">0</span>],a[i-<span class="hljs-number">1</span>] = a[i-<span class="hljs-number">1</span>],a[<span class="hljs-number">0</span>]; i -=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        a[<span class="hljs-number">0</span>],a[i] = a[i],a[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> i<br><br>// 完整的快排算法 就是对其进行左右递归.  下面的是严蔚敏的快速排序算法<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = nums[low];<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        <span class="hljs-keyword">while</span> (low &lt; high <span class="hljs-keyword">and</span> nums[high] &gt;= pivot) --high;<br>        nums[low] = nums[high];<br>        <span class="hljs-keyword">while</span> (low &lt; high <span class="hljs-keyword">and</span> nums[low] &lt;= pivot) ++low;<br>        nums[high] = nums[low];<br>    &#125;<br>    nums[low] = pivot;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">Partition</span>(nums, low, high);<br>        <span class="hljs-built_in">QuickSort</span>(nums, low, pivot - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">QuickSort</span>(nums, pivot + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><ul><li><h2 id="基数排序-桶排序-桶排序是基数排序的特例"><a href="#基数排序-桶排序-桶排序是基数排序的特例" class="headerlink" title="基数排序(桶排序) 桶排序是基数排序的特例"></a>基数排序(桶排序) 桶排序是基数排序的特例</h2></li></ul><h3 id="桶排序-在序列里值的范围-且这个范围不算太大时使用"><a href="#桶排序-在序列里值的范围-且这个范围不算太大时使用" class="headerlink" title="桶排序  在序列里值的范围 且这个范围不算太大时使用"></a>桶排序  在序列里值的范围 且这个范围不算太大时使用</h3><p>是一种非常特殊的排序算法。在前面的课程中，我们有一道题目是要找数据流的中位数，限制是所有的数都在 1 到 100 以内。我们当时提到在这种限制下，可以将数字放到 1-100 的桶里，每个桶只记录当前数字的数量，从而将插入的复杂度从 O(n) 降低为<br>O(1)，这就是一个桶排序的思想。同样的，如果我们碰到这样的题目：</p><blockquote><h4 id="例题：有-10-万个整数，每个数范围在-0-99-之间。有若干查询，每个查询给定一个数-x，问比-x-小的数有多少。"><a href="#例题：有-10-万个整数，每个数范围在-0-99-之间。有若干查询，每个查询给定一个数-x，问比-x-小的数有多少。" class="headerlink" title="例题：有 10 万个整数，每个数范围在 [0,99] 之间。有若干查询，每个查询给定一个数 x，问比 x 小的数有多少。"></a>例题：有 10 万个整数，每个数范围在 [0,99] 之间。有若干查询，每个查询给定一个数 x，问比 x 小的数有多少。</h4><p>对于这道题目，我们可以直接把数都拿过来排序，然后对每个 x 做一个二分查找，可以解决问题。但是通过桶排序我们可以有更优的解。</p><p>我们开一个数组，大小为 100，分别代表 0 到 99 每个数有多少个。然后我们遍历所有数据，记录每个数字的数量。最后统计的时候，我们只需要计算数组中下标小于 x 的数的总和就可以了。</p><p>后面统计的部分只有 0 到 100 的循环，所以查询的时间非常短。整体复杂度的瓶颈就在于开始时预处理数据，也就是 O(n) </p></blockquote><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h4 id="我们开一个长度为10的桶-把数据按照-x3D-x3D-最后一位-x3D-x3D-放到对应的桶里-形成一个序列"><a href="#我们开一个长度为10的桶-把数据按照-x3D-x3D-最后一位-x3D-x3D-放到对应的桶里-形成一个序列" class="headerlink" title="我们开一个长度为10的桶  把数据按照&#x3D;&#x3D;最后一位&#x3D;&#x3D;放到对应的桶里 形成一个序列"></a>我们开一个长度为10的桶  把数据按照&#x3D;&#x3D;最后一位&#x3D;&#x3D;放到对应的桶里 形成一个序列</h4><h4 id="我们开一个长度为10的桶-把数据按照-x3D-x3D-倒数第二位-x3D-x3D-放到对应的桶里-⚠️-同一个桶里的元素要按照上个序列的顺序放"><a href="#我们开一个长度为10的桶-把数据按照-x3D-x3D-倒数第二位-x3D-x3D-放到对应的桶里-⚠️-同一个桶里的元素要按照上个序列的顺序放" class="headerlink" title="我们开一个长度为10的桶  把数据按照 &#x3D;&#x3D;倒数第二位&#x3D;&#x3D; 放到对应的桶里 ⚠️ 同一个桶里的元素要按照上个序列的顺序放"></a>我们开一个长度为10的桶  把数据按照 &#x3D;&#x3D;倒数第二位&#x3D;&#x3D; 放到对应的桶里 ⚠️ 同一个桶里的元素要按照上个序列的顺序放</h4><h4 id="我们开始一个长度为10的桶-把数据按照-x3D-x3D-倒数第三位-x3D-x3D-放到对应的桶里-同理"><a href="#我们开始一个长度为10的桶-把数据按照-x3D-x3D-倒数第三位-x3D-x3D-放到对应的桶里-同理" class="headerlink" title="我们开始一个长度为10的桶 把数据按照 &#x3D;&#x3D;倒数第三位&#x3D;&#x3D; 放到对应的桶里 同理"></a>我们开始一个长度为10的桶 把数据按照 &#x3D;&#x3D;倒数第三位&#x3D;&#x3D; 放到对应的桶里 同理</h4><img src="/Users/edelweiss/Library/Application Support/typora-user-images/image-20210308201415058.png" alt="image-20210308201415058" style="zoom:50%;" /><hr><ul><li><h2 id="冒泡排序-「优化-如果一轮里没有元素被交换-说明排序结束」"><a href="#冒泡排序-「优化-如果一轮里没有元素被交换-说明排序结束」" class="headerlink" title="冒泡排序 「优化 : 如果一轮里没有元素被交换 说明排序结束」"></a>冒泡排序 「优化 : 如果一轮里没有元素被交换 说明排序结束」</h2></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span><br>            arr[j + <span class="hljs-number">1</span>] = arr[j + <span class="hljs-number">1</span>] + arr[j];<br>            arr[j] = arr[j + <span class="hljs-number">1</span>] - arr[j];<br>            arr[j + <span class="hljs-number">1</span>] = arr[j + <span class="hljs-number">1</span>] - arr[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><ul><li><h2 id="选择排序-「不受输入状态影响-amp-交换次数少-最多n次交换-」「选择排序的优化版本就是堆排序」"><a href="#选择排序-「不受输入状态影响-amp-交换次数少-最多n次交换-」「选择排序的优化版本就是堆排序」" class="headerlink" title="选择排序 「不受输入状态影响 &amp; 交换次数少(最多n次交换)」「选择排序的优化版本就是堆排序」"></a>选择排序 「不受输入状态影响 &amp; 交换次数少(最多n次交换)」「选择排序的优化版本就是堆排序」</h2></li></ul><p>维护一个长度逐渐变长的窗口 这个窗口中的元素是已经排好序的了 每一次都把序列搜索一遍.  搜索n-1遍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> index = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                index = nums[j] &lt; nums[index] ? j : index;<br>            &#125;<br>            <span class="hljs-built_in">swap</span> (nums[i], nums[index]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><ul><li><h3 id="插入排序-「分为-向后腾挪和交换-两种方式」"><a href="#插入排序-「分为-向后腾挪和交换-两种方式」" class="headerlink" title="插入排序 「分为 向后腾挪和交换 两种方式」"></a>插入排序 「分为 向后腾挪和交换 两种方式」</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 从第二个数开始，往前插入数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentNumber</span> <span class="hljs-operator">=</span> arr[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 寻找插入位置的过程中，不断地将比 currentNumber 大的数字向后挪</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; currentNumber &lt; arr[j]) &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">// 两种情况会跳出循环：1. 遇到一个小于或等于 currentNumber 的数字，跳出循环，currentNumber 就坐到它后面。</span><br>        <span class="hljs-comment">// 2. 已经走到数列头部，仍然没有遇到小于或等于 currentNumber 的数字，也会跳出循环，此时 j 等于 -1，currentNumber 就坐到数列头部。</span><br>        arr[j + <span class="hljs-number">1</span>] = currentNumber;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 这种采取了交换的方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 从第二个数开始，往前插入数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-comment">// j 记录当前数字下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-comment">// 当前数字比前一个数字小，则将当前数字与前一个数字交换</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">1</span> &amp;&amp; arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>            arr[j] = arr[j - <span class="hljs-number">1</span>];<br>            arr[j - <span class="hljs-number">1</span>] = temp;<br>            <span class="hljs-comment">// 更新当前数字下标</span><br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about priority_queue &amp; heap</title>
    <link href="/2021/01/18/about%20priority_queue%20&amp;%20heap/"/>
    <url>/2021/01/18/about%20priority_queue%20&amp;%20heap/</url>
    
    <content type="html"><![CDATA[<h1 id="about-priority-queue-amp-heap"><a href="#about-priority-queue-amp-heap" class="headerlink" title="about priority_queue &amp; heap"></a>about priority_queue &amp; heap</h1><h2 id="自实现的堆"><a href="#自实现的堆" class="headerlink" title="自实现的堆"></a>自实现的堆</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">min_heap</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">min_heap</span>() &#123; <span class="hljs-comment">//下标从1开始</span><br>        nums.<span class="hljs-built_in">emplace_back</span>(nullhead);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        nums.<span class="hljs-built_in">emplace_back</span>(val);<br>        <span class="hljs-built_in">Shift_up</span>((<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Shift_up</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (index / <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (nums[index/<span class="hljs-number">2</span>] &gt; nums[index]) <span class="hljs-built_in">swap</span>(nums[index], nums[index/<span class="hljs-number">2</span>]); <span class="hljs-comment">//由于向下取整 2i 和 2i+1 对应的双亲只要除2就能到</span><br>            index /= <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">heap_top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;nums[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_delete</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;ERROR&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        nums.<span class="hljs-built_in">erase</span>(nums.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span> + index);<br>        <span class="hljs-built_in">heap_sort</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> index = (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">Shift_up</span>(index);<br>            index --;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_print</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//用来测试</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            cout &lt;&lt; nums[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><ol><li>上浮「shift_up」操作的关键在于 我们取1开始 两个孩子分别是 2i 和 2i+1 它们俩除2 可以同时到达双亲节点</li><li>我们把上浮定义成 可以指定任何一个下标 上浮。 这样的好处是 之后的 heap_sort 以及 Insert 函数 都很方便写了 「heapsort就是把每个元素都上浮，insert就是加到末尾然后上浮」</li><li>要注意的是 下标从1 开始 返回top的时候不要用front！</li></ol></blockquote><p>⚠️ 优先队列是一种数据结构 但堆不是 堆是优先队列的内部实现方式</p><h2 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h2><blockquote><ul><li><code>priority_queue&lt;int&gt; q;//等价于默认，从大到小排</code></li><li><code>priority_queue&lt;int, vector&lt;int&gt;,  less&lt;int&gt;&gt; q;//等价于默认，从大到小排</code></li><li><code>priority_queue&lt;int, vector&lt;int&gt;,  greater&lt;int&gt;&gt; q; 　　//通过操作，按照元素从小到大的顺序出队</code></li><li>priority_queue&lt;TreeNode*, vector&lt;TreeNode*&gt;,  decltype(cmp)&gt; q{cmp};</li></ul></blockquote><h2 id="自定义优先级"><a href="#自定义优先级" class="headerlink" title="自定义优先级"></a>自定义优先级</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;    <span class="hljs-comment">//通过传入不同类型来定义不同类型优先级</span><br>        <span class="hljs-keyword">return</span> a &gt; b;    <span class="hljs-comment">//最小值优先</span><br>      <span class="hljs-comment">//return a &lt; b; // 最大值优先</span><br>    &#125;<br>&#125;;<br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, cmp &gt; q;<br><br><span class="hljs-comment">//或者可以使用这种方式定义</span><br><span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">const</span> TreeNode* a, <span class="hljs-type">const</span> TreeNode* b) &#123;<br>    <span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val;<br>&#125;;<br>priority_queue&lt;TreeNode*, vector&lt;TreeNode*&gt;,  <span class="hljs-keyword">decltype</span>(cmp)&gt; q&#123;cmp&#125;;<br></code></pre></td></tr></table></figure><h2 id="自定义结构体、优先级"><a href="#自定义结构体、优先级" class="headerlink" title="自定义结构体、优先级"></a>自定义结构体、优先级</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> priority;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node &amp;a, <span class="hljs-type">const</span> node &amp;b) &#123;<br>        <span class="hljs-keyword">return</span> a.priority &lt; b.priority;<br>    &#125;<br>    <span class="hljs-comment">/* 这样写也可以</span><br><span class="hljs-comment">    bool operator &lt; (const node &amp;a) const &#123;</span><br><span class="hljs-comment">        return priority &lt; a.priority;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>&#125;;<br><br>priority_queue&lt;node&gt; q;<br></code></pre></td></tr></table></figure><blockquote><p>因为标准库默认使用元素类型的 <code>&lt;</code> 操作符来确定它们之间的优先级关系。而且自定义类型的 <code>&lt;</code> 操作符与 <code>&gt;</code> 操作符并无直接联系，故会编译不过。</p><p>错误示范：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> priority;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &gt; (<span class="hljs-type">const</span> node &amp;a, <span class="hljs-type">const</span> node &amp;b) &#123;   <span class="hljs-comment">//错误示范</span><br>        <span class="hljs-keyword">return</span> a.priority &gt; b.priority;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h2 id="decltype关键字-C-11"><a href="#decltype关键字-C-11" class="headerlink" title="decltype关键字 ( C++11 )"></a>decltype关键字 ( C++11 )</h2><blockquote><p><a href="https://baike.baidu.com/item/decltype">decltype</a>，在C++中，作为操作符，用于查询表达式的数据类型.</p><p>​    有时我们希望从表达式的<strong>类型推断</strong>出要定义的<strong>变量类型</strong>，但是不想用该表达式的值初始化变量 ( 如果要初始化就用auto了 )。为了满足这一需求，C++11新标准引入了decltype类型说明符，它的作用是<strong>选择并返回操作数的数据类型</strong>，在此过程中，编译器<strong>分析</strong>表达式并得到它的类型，却<strong>不实际计算</strong>表达式的值。</p></blockquote><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> tempA = <span class="hljs-number">2</span>;<br>    <br>    <span class="hljs-comment">/*1.dclTempA为int*/</span><br>    <span class="hljs-keyword">decltype</span>(tempA) dclTempA;<br>    <span class="hljs-comment">/*2.dclTempB为int，对于getSize根本没有定义，但是程序依旧正常，因为decltype只做分析，并不调用getSize，*/</span><br>    <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">getSize</span>()) dclTempB;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="与-const-结合"><a href="#与-const-结合" class="headerlink" title="与 const 结合"></a>与 const 结合</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> tempA = <span class="hljs-number">3.0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> ctempA = <span class="hljs-number">5.0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> ctempB = <span class="hljs-number">6.0</span>；<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> *<span class="hljs-type">const</span> cptrTempA = &amp;ctempA;<br><span class="hljs-comment">/*1.dclTempA推断为const double（保留顶层const，此处与auto不同）*/</span><br><span class="hljs-keyword">decltype</span>(ctempA) dclTempA = <span class="hljs-number">4.1</span>;<br><span class="hljs-comment">/*2.dclTempA为const double，不能对其赋值，编译不过*/</span><br>dclTempA = <span class="hljs-number">5</span>;<br><span class="hljs-comment">/*3.dclTempB推断为const double * const*/</span><br><span class="hljs-keyword">decltype</span>(cptrTempA) dclTempB = &amp;ctempA;<br><span class="hljs-comment">/*4.输出为4（32位计算机）和5*/</span><br>cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(dclTempB)&lt;&lt;<span class="hljs-string">&quot;    &quot;</span>&lt;&lt;*dclTempB&lt;&lt;endl;<br><span class="hljs-comment">/*5.保留顶层const，不能修改指针指向的对象，编译不过*/</span><br>dclTempB = &amp;ctempB;<br><span class="hljs-comment">/*6.保留底层const，不能修改指针指向的对象的值，编译不过*/</span><br>*dclTempB = <span class="hljs-number">7.0</span>;<br></code></pre></td></tr></table></figure><h3 id="与引用结合"><a href="#与引用结合" class="headerlink" title="与引用结合"></a>与引用结合</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> tempA = <span class="hljs-number">0</span>, &amp;refTempA = tempA;<br><br><span class="hljs-comment">/*1.dclTempA为引用，绑定到tempA*/</span><br><span class="hljs-keyword">decltype</span>(refTempA) dclTempA = tempA;<br><span class="hljs-comment">/*2.dclTempB为引用，必须绑定到变量，编译不过*/</span><br><span class="hljs-keyword">decltype</span>(refTempA) dclTempB = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/*3.dclTempC为引用，必须初始化，编译不过*/</span><br><span class="hljs-keyword">decltype</span>(refTempA) dclTempC;<br><span class="hljs-comment">/*4.双层括号表示引用，dclTempD为引用，绑定到tempA*/</span><br><span class="hljs-keyword">decltype</span>((tempA)) dclTempD = tempA;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ctempA = <span class="hljs-number">1</span>, &amp;crefTempA = ctempA;<br><br><span class="hljs-comment">/*5.dclTempE为常量引用，可以绑定到普通变量tempA*/</span><br><span class="hljs-keyword">decltype</span>(crefTempA) dclTempE = tempA;<br><span class="hljs-comment">/*6.dclTempF为常量引用，可以绑定到常量ctempA*/</span><br><span class="hljs-keyword">decltype</span>(crefTempA) dclTempF = ctempA;<br><span class="hljs-comment">/*7.dclTempG为常量引用，绑定到一个临时变量*/</span><br><span class="hljs-keyword">decltype</span>(crefTempA) dclTempG = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/*8.dclTempH为常量引用，必须初始化，编译不过*/</span><br><span class="hljs-keyword">decltype</span>(crefTempA) dclTempH;<br><span class="hljs-comment">/*9.双层括号表示引用,dclTempI为常量引用，可以绑定到普通变量tempA*/</span><br><span class="hljs-keyword">decltype</span>((ctempA))  dclTempI = ctempA;<br></code></pre></td></tr></table></figure><h3 id="与指针结合"><a href="#与指针结合" class="headerlink" title="与指针结合"></a>与指针结合</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> tempA = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> *ptrTempA = &amp;tempA;<br><span class="hljs-comment">/*1.常规使用dclTempA为一个int *的指针*/</span><br><span class="hljs-keyword">decltype</span>(ptrTempA) dclTempA;<br><span class="hljs-comment">/*2.需要特别注意，表达式内容为解引用操作，dclTempB为一个引用，引用必须初始化，故编译不过*/</span><br><span class="hljs-keyword">decltype</span>(*ptrTempA) dclTempB;<br></code></pre></td></tr></table></figure><h3 id="decltype-总结"><a href="#decltype-总结" class="headerlink" title="decltype 总结"></a>decltype 总结</h3><blockquote><p>decltype和auto都可以用来推断类型，但是二者有几处明显的差异：</p><p>1.<code>auto</code><strong>忽略</strong>顶层<code>const</code>，<code>decltype</code> <strong>保留</strong>顶层 <code>const</code>；</p><p>2.对<strong>引用操作</strong>，<code>auto</code>推断出<strong>原有类型</strong>，<code>decltype</code>推断出<strong>引用</strong>；</p><p>3.对<strong>解引用操作</strong>，<code>auto</code>推断出<strong>原有类型</strong>，<code>decltype</code>推断出<strong>引用</strong>；</p><p>4.<code>auto</code>推断时会<strong>实际执行</strong>，<code>decltype</code><strong>不会执行</strong>，<strong>只做分析</strong>。</p><p>总之在使用中过程中和<code>const</code>、引用和指针结合时需要特别小心。</p></blockquote><h2 id="Lambda-与-decltype-结合"><a href="#Lambda-与-decltype-结合" class="headerlink" title="Lambda 与 decltype 结合"></a>Lambda 与 decltype 结合</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">counts</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">auto</span> cmp = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; letter1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; letter2) &#123;<br><span class="hljs-keyword">return</span> counts[letter1 - <span class="hljs-string">&#x27;a&#x27;</span>]  &lt; counts[letter2 - <span class="hljs-string">&#x27;a&#x27;</span>];<br>&#125;;<br>priority_queue&lt;<span class="hljs-type">char</span>, vector&lt;<span class="hljs-type">char</span>&gt;,  <span class="hljs-keyword">decltype</span>(cmp)&gt; qu&#123;cmp&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web 开发技术</title>
    <link href="/2021/01/04/Web%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    <url>/2021/01/04/Web%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Web开发技术"><a href="#Web开发技术" class="headerlink" title="Web开发技术"></a>Web开发技术</h1><h3 id="远程过程调用-RPC-「Remote-Procedure-Call」"><a href="#远程过程调用-RPC-「Remote-Procedure-Call」" class="headerlink" title="远程过程调用 RPC 「Remote Procedure Call」"></a>远程过程调用 RPC 「Remote Procedure Call」</h3><p><strong>&#x3D;&#x3D;RPC模式 以及利用此模式制作的RPC中间件(通信插件) 旨在简化Web开发，使得程序员可以使用高级语言来建构程序(特别是网络分布式程序 如C&#x2F;S架构) 而不是利用API来调用&#x3D;&#x3D;</strong></p><ul><li><code>套接字API</code> 是底层通信过程最直接的抽象 直接面向TCP&#x2F;IP通信过程 所以即使是使用API来调用底层硬件<strong>仍然比较麻烦</strong> 并且会出现异常 好在<em><strong>API不是网络应用程序间通信实现的唯一方法</strong></em></li><li><code>procedure 过程</code> 指能解决一系列相关人物的可调用程序，(传统面向过程编程里的子程序)</li><li><code>procedure call 过程调用</code> 是面向过程编程机制 每个过程利用一组形式化参数定义，当过程被调用时 调用者要提供与形参匹配的实参(直接可以理解成 函数 和函数的调用)</li><li><code>RPC</code> <ul><li>是最早被提出和开发的C&#x2F;S通信工具的机制 </li><li>使用<strong>传统编程语言结构</strong>向开发者提供接口，而不像API那样需要利用显式通信原语</li><li>RPC允许程序员将过程适配到多个主机上，通过不同计算机间进行的远程过程调用自动生产代码并完成通信</li></ul></li></ul><h4 id="RPC模式规范"><a href="#RPC模式规范" class="headerlink" title="RPC模式规范"></a>RPC模式规范</h4><ul><li>我们需要的 RPC模式在现有的编程语言中扩展，设计了一种符合<strong>高级语言编写规范(考虑到不同计算机的适配问题 需要用高级语言 汇编不行)</strong> 并能自动处理网络通信细节</li><li>RPC允许客户端 <strong>跨过网络调用服务器过程 在这种情况下就可以使用<code>RPC工具</code>，它将生成处理所需的通信过程插件<code>communication stub/proxy</code> 真正的通信任务交给插件来完成 如下图</strong><ul><li>在使用通信插件后 程序员被允许在忽略底层通信拓扑的基础上使用高级语言和成熟的编程方法来进行架构 提高软件的可靠性<ul><li>客户端 $\Rightarrow$ 客户插件 + 客户端主程序</li><li>服务器 $\Rightarrow$ 服务器插件 + 远程过程</li></ul></li></ul></li><li><code>中间件 middleware</code> 是介于传统应用程序和系统平台(os和hardware system) 之间的通用服务工具 主要的作用是以下三点 我认为这和API有很多相似之处<ul><li>提供标准接口 ｜ 支持分布式计算(负载均衡) ｜ 支持跨平台</li></ul></li></ul><hr>]]></content>
    
    
    
    <tags>
      
      <tag>互联网原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Email &amp;&amp; WWW</title>
    <link href="/2021/01/04/Email-&amp;&amp;-WWW/"/>
    <url>/2021/01/04/Email-&amp;&amp;-WWW/</url>
    
    <content type="html"><![CDATA[<h1 id="E-mail-amp-amp-WWW"><a href="#E-mail-amp-amp-WWW" class="headerlink" title="E-mail &amp;&amp; WWW"></a>E-mail &amp;&amp; WWW</h1><h1 id="E-MAIL-系统概述"><a href="#E-MAIL-系统概述" class="headerlink" title="E-MAIL 系统概述"></a>E-MAIL 系统概述</h1><h3 id="⚠️-邮件系统-在大型机上不同邮箱移动报文时-就已经出现了-它的出现至少不晚于Internet"><a href="#⚠️-邮件系统-在大型机上不同邮箱移动报文时-就已经出现了-它的出现至少不晚于Internet" class="headerlink" title="⚠️ 邮件系统 在大型机上不同邮箱移动报文时 就已经出现了 (它的出现至少不晚于Internet)"></a>⚠️ 邮件系统 在大型机上不同邮箱移动报文时 就已经出现了 (它的出现至少不晚于Internet)</h3><h3 id="而我们使用的-所谓-x3D-x3D-E-Mail-则是-x3D-x3D-x3D-x3D-特指-x3D-x3D-x3D-x3D-通过计算机网络进行通信-x3D-x3D-的-电子化信息传递系统"><a href="#而我们使用的-所谓-x3D-x3D-E-Mail-则是-x3D-x3D-x3D-x3D-特指-x3D-x3D-x3D-x3D-通过计算机网络进行通信-x3D-x3D-的-电子化信息传递系统" class="headerlink" title="而我们使用的 所谓 &#x3D;&#x3D;E-Mail 则是&#x3D;&#x3D; &#x3D;&#x3D;特指&#x3D;&#x3D;&#x3D;&#x3D;通过计算机网络进行通信&#x3D;&#x3D;的 电子化信息传递系统"></a>而我们使用的 所谓 &#x3D;&#x3D;E-Mail 则是&#x3D;&#x3D; &#x3D;&#x3D;特指&#x3D;&#x3D;&#x3D;&#x3D;通过计算机网络进行通信&#x3D;&#x3D;的 电子化信息传递系统</h3><h3 id="E-Mail-是-Internet上-使用最广泛的应用"><a href="#E-Mail-是-Internet上-使用最广泛的应用" class="headerlink" title="E-Mail 是 Internet上 使用最广泛的应用"></a>E-Mail 是 Internet上 使用最广泛的应用</h3><p>E-Mail定义了SMTP 和 MIME </p><h5 id="电子邮件需要实现以下的几个功能"><a href="#电子邮件需要实现以下的几个功能" class="headerlink" title="电子邮件需要实现以下的几个功能"></a>电子邮件需要实现以下的几个功能</h5><ol><li>创建电子邮件</li><li>发送和接收邮件</li><li>管理邮件 「管理：包括回复 转发 删除 存储 等等」</li><li>保证邮箱的私有性质 「虽然任何人都可以在邮箱里放入邮件 但只有邮箱的拥有者可以查看」</li></ol><h3 id="E-Mail的地址结构"><a href="#E-Mail的地址结构" class="headerlink" title="E-Mail的地址结构"></a>E-Mail的地址结构</h3><p>一般认为 邮箱地址要保证唯一  需要 <strong>邮箱名+存放邮箱的主机域名</strong></p><p><a href="mailto:&#49;&#51;&#53;&#x37;&#48;&#48;&#48;&#x32;&#x37;&#x34;&#x40;&#113;&#113;&#46;&#99;&#x6f;&#x6d;">&#49;&#51;&#53;&#x37;&#48;&#48;&#48;&#x32;&#x37;&#x34;&#x40;&#113;&#113;&#46;&#99;&#x6f;&#x6d;</a> $\Rightarrow$ 1357000274 为邮箱名 ｜  qq.com 存放邮箱的主机域名</p><h2 id="SMTP-Simple-Mail-Transfer-Protocol"><a href="#SMTP-Simple-Mail-Transfer-Protocol" class="headerlink" title="SMTP Simple Mail Transfer Protocol"></a>SMTP Simple Mail Transfer Protocol</h2><ul><li>1981年出现 **它只能传输字符 信息主体被限制为 ASCII码 **</li><li>SMTP 规定相互通信的 C&#x2F;S端两个 SMTP进程间如何进行信息交互</li><li>⚠️ SMTP没有定义 邮件采用何种格式 以及 如何存储邮件 发送和递交邮件</li></ul><h3 id="SMTP传送的过程"><a href="#SMTP传送的过程" class="headerlink" title="SMTP传送的过程"></a>SMTP传送的过程</h3><ul><li>类似上图 用户按照格式填装邮件 输入发送命令后 电子邮件接口软件 首先将这个邮件放在 邮件暂存队列里</li><li>对邮件的控制权此时来到了 <strong>邮件传输程序</strong>这里。 它将判断这封邮件发往哪里。「可以发送给 本地的计算机」</li><li>如果要向互联网远程用户发送邮件 在确认连接互联网后 <strong>邮件传输软件作为客户 和 邮件服务器进行通信(它在远程计算机上)， 传输软件会将 邮件的 一个&#x3D;&#x3D;<em>副本</em>&#x3D;&#x3D;发送到邮件服务器上</strong></li><li>邮件现在来到了邮件缓存区 发送方SMTP软件会定时(几分钟或几时分钟)扫描缓冲区队列</li><li>如果SMTP软件检测到了待发邮件 它就会 <strong>作为客户和目的计算机SMTP服务器端口(25)建立TCP连接</strong><ul><li>服务器发出 220 Service ready  客户端发送 helo + 邮箱+主机名；</li><li>服务器如果可以接收 会应答 250 OK 否则返回代码 421 Service not available | 451 &#x2F; 452 等异常命令<ul><li>SMTP定义了 14条命令(由4个字母组成) 和 21种应答(由3个数字开始)</li></ul></li><li>开始传输邮件副本</li></ul></li><li><strong>由客户端在发送结束后 通过 QUIT 命令释放TCP连接</strong></li></ul><h3 id="SMTP-是复杂的协商交互协议-通常会在后台工作-因为邮件系统从来就不是一个实时传输新系统"><a href="#SMTP-是复杂的协商交互协议-通常会在后台工作-因为邮件系统从来就不是一个实时传输新系统" class="headerlink" title="SMTP 是复杂的协商交互协议 通常会在后台工作(因为邮件系统从来就不是一个实时传输新系统)"></a>SMTP 是复杂的协商交互协议 通常会在后台工作(因为邮件系统从来就不是一个实时传输新系统)</h3><h3 id="SMTP可以用在两个用户之间-但主流情况下-使用-邮局和中转的概念「分发-转发-列表-按照列表分发-多重接收-同一个计算机上的多个邮箱-只建立一个TCP连接-」"><a href="#SMTP可以用在两个用户之间-但主流情况下-使用-邮局和中转的概念「分发-转发-列表-按照列表分发-多重接收-同一个计算机上的多个邮箱-只建立一个TCP连接-」" class="headerlink" title="SMTP可以用在两个用户之间 但主流情况下 使用 邮局和中转的概念「分发 转发 列表(按照列表分发) 多重接收(同一个计算机上的多个邮箱 只建立一个TCP连接)」"></a>SMTP可以用在两个用户之间 但主流情况下 使用 邮局和中转的概念「分发 转发 列表(按照列表分发) 多重接收(同一个计算机上的多个邮箱 只建立一个TCP连接)」</h3><p><strong>邮件中继：</strong> 当需要进行 <strong>大量的</strong>的邮件转发&#x2F;分发时 一个独立且能力更强的计算机<strong>E-Mail Gateway &#x2F; E-Mail Relay</strong> 出现了</p><p>组织地址：它帮助每个自己管理下的计算机完成邮件的收发「这个组织通常会运行一个组织网关来管理」</p><p><strong>邮件网关实际隔离外部邮件地址与内部邮件地址(计算机与用户)</strong></p><h2 id="MIME-Multipurpose-Internet-Mail-Extension"><a href="#MIME-Multipurpose-Internet-Mail-Extension" class="headerlink" title="MIME Multipurpose Internet Mail Extension"></a>MIME Multipurpose Internet Mail Extension</h2><h3 id="邮件在这个协议里-被允许-分成几个部分-每个部分可以通过不同的格式来传送"><a href="#邮件在这个协议里-被允许-分成几个部分-每个部分可以通过不同的格式来传送" class="headerlink" title="邮件在这个协议里 被允许 分成几个部分 每个部分可以通过不同的格式来传送"></a>邮件在这个协议里 被允许 分成几个部分 每个部分可以通过不同的格式来传送</h3><ul><li>头部 「发、收地址 日期 主题等条目  每个头部行开始是 行关键字和冒号 + 信息」</li><li>空行 用来分割 头部和信息文本</li><li>信息文本   包含了 多媒体二进制信息 可以实现任意编辑</li></ul><h2 id="存储传送方式-非端到端直接传送-｜-POP-amp-IMAP"><a href="#存储传送方式-非端到端直接传送-｜-POP-amp-IMAP" class="headerlink" title="存储传送方式(非端到端直接传送) ｜ POP &amp; IMAP"></a>存储传送方式(非端到端直接传送) ｜ POP &amp; IMAP</h2><p>在目前邮箱通常被放在电子邮件系统服务器计算机上 接受者要自己去邮件服务器 读自己的邮件 而不是它主动发给你</p><h3 id="常用的-远程读取的邮局协议POP-Post-Office-Protocol-1996-POP3-IMAP-Internet-Mail-Access-Protocol"><a href="#常用的-远程读取的邮局协议POP-Post-Office-Protocol-1996-POP3-IMAP-Internet-Mail-Access-Protocol" class="headerlink" title="常用的 远程读取的邮局协议POP(Post Office Protocol)(1996 POP3) | IMAP(Internet Mail Access Protocol)"></a>常用的 远程读取的邮局协议POP(Post Office Protocol)(1996 POP3) | IMAP(Internet Mail Access Protocol)</h3><p>用户计算机的电子邮件软件作为POP服务器的客户 来存取</p><h3 id="POP相比SMTP的优越性-rightarrow-POP不进行传输交互"><a href="#POP相比SMTP的优越性-rightarrow-POP不进行传输交互" class="headerlink" title="POP相比SMTP的优越性 $\rightarrow$ POP不进行传输交互"></a>POP相比SMTP的优越性 $\rightarrow$ POP不进行传输交互</h3><p>pop主要完成 创建连接 用户认证 事务操作(列出 取回并删除等等) ｜ 邮件将在被读取后的不久被POP删除</p><h3 id="IMAP-2003-IMAP4-和POP3一样采用C-x2F-S方式来工作-但比POP3复杂-用户能进行更多的操作-比如只看首部-并且在不下令删除的情况下保留用户的邮件"><a href="#IMAP-2003-IMAP4-和POP3一样采用C-x2F-S方式来工作-但比POP3复杂-用户能进行更多的操作-比如只看首部-并且在不下令删除的情况下保留用户的邮件" class="headerlink" title="IMAP (2003 IMAP4) 和POP3一样采用C&#x2F;S方式来工作 但比POP3复杂(用户能进行更多的操作 比如只看首部) 并且在不下令删除的情况下保留用户的邮件"></a>IMAP (2003 IMAP4) 和POP3一样采用C&#x2F;S方式来工作 但比POP3复杂(用户能进行更多的操作 比如只看首部) 并且在不下令删除的情况下保留用户的邮件</h3><h3 id="目前-具有大邮箱数据库和SMTP-x2F-POP服务器-中继功能的计算机-相当于电子邮局"><a href="#目前-具有大邮箱数据库和SMTP-x2F-POP服务器-中继功能的计算机-相当于电子邮局" class="headerlink" title="目前 具有大邮箱数据库和SMTP&#x2F;POP服务器+中继功能的计算机 相当于电子邮局"></a>目前 具有大邮箱数据库和SMTP&#x2F;POP服务器+中继功能的计算机 相当于电子邮局</h3><h2 id="E-Mail传递的发展"><a href="#E-Mail传递的发展" class="headerlink" title="E-Mail传递的发展"></a>E-Mail传递的发展</h2><ol><li>两个主机间点对点的 SMTP邮件直接收发</li><li>邮件网关(中继) 和组织邮件地址 出现中间管理服务</li><li>电子邮局出现 形成现今的电子邮件系统框架</li><li>SMTP完成发送 POP&#x2F;IMAP完成电子邮局登陆 读取和管理邮件</li></ol><h2 id="MIME协议和实现"><a href="#MIME协议和实现" class="headerlink" title="MIME协议和实现"></a>MIME协议和实现</h2><p>现在使用的 是多用途Internet邮件扩充MIME协议</p><h3 id="MIME完成的是传输-ASCII码之外的-二进制信息-声音-图像-影视信号也可以发送了"><a href="#MIME完成的是传输-ASCII码之外的-二进制信息-声音-图像-影视信号也可以发送了" class="headerlink" title="MIME完成的是传输 ASCII码之外的 二进制信息(声音 图像 影视信号也可以发送了)"></a>MIME完成的是传输 ASCII码之外的 二进制信息(声音 图像 影视信号也可以发送了)</h3><p>MIME的设计思路是不推翻SMTP架构而对其微调</p><p>做法是：</p><blockquote><p>将所有不同类型的二进制数据<strong>分段编码</strong>为7位ASCII码 然后用SMTP作为一般的文本来发送 然后在接收端转换回去</p></blockquote><p>在使用MIME时发送方会在邮件头部增加附加行 这一行将会指明这个报文遵循的MIME格式 数据类型和编码算法</p><p>比如 MIME-Version:1.0 </p><p>MIME还允许发送方将报文分成多个部分(它们可以使用不一样的编码方法) 实际上就是 粘贴多个附件</p><h3 id="MIME具有-兼容性「SMTP不需要解析MIME的编码-所以和早期的SMTP兼容」-和-灵活性「不规定编码方法和名称-」"><a href="#MIME具有-兼容性「SMTP不需要解析MIME的编码-所以和早期的SMTP兼容」-和-灵活性「不规定编码方法和名称-」" class="headerlink" title="MIME具有 兼容性「SMTP不需要解析MIME的编码 所以和早期的SMTP兼容」 和 灵活性「不规定编码方法和名称 」"></a>MIME具有 兼容性「SMTP不需要解析MIME的编码 所以和早期的SMTP兼容」 和 灵活性「不规定编码方法和名称 」</h3><hr><blockquote><p><strong>1、为什么说电子邮件的使用超过了因特网的范围</strong></p><p>电子邮件用户计算机完全可以不是Internet用户(没有因特网域名或IP地址) 而可以是在某个Internet计算机上注册了邮箱的普通计算机。 甚至还可以只和本地的传输邮件。</p></blockquote><blockquote><p><strong>2、当你发送电子邮件给不同电子邮局用户时，需要经过哪些必要的环节?请画图 示意。</strong></p></blockquote><blockquote><p><strong>3、早期电子邮件直接在收发计算机之间传输完成，试说明这种模式的优缺点。</strong></p><p>优点：效率高 是即时的传输 实现简单</p><p>缺点：</p><ol><li><p>接收的计算机需要开着(并且要么连接互联网，要么和发送计算机直接相连)， 这意味着接收方需要事先知道要接收邮件，也就丧失了邮件系统的非实时性。</p></li><li><p>常用的个人计算机无法配置邮件服务器，这使得利用邮件服务器完成的功能(如 分发 转发 列表) 收发计算机都无法完成，使得邮件系统可用性大幅下降</p></li></ol></blockquote><blockquote><p><strong>4、通过目前电子邮件系统发往某邮件，常常发现传输时间是不确定的，有时快而 有时慢，为什么?</strong></p><p>因为用户邮件在发端是定时扫描、建立连接和批处理传输的；且发送到目的邮局服务器的邮箱后，需要用户登陆后取回；即E-mail系统工作过程不是一个实际收发的端到端连接通信，而是中间邮局的非实时处理，所以邮件传递快慢取决于个环节等待时间。</p></blockquote><blockquote><p> <strong>5、一个组织的电子邮件系统网关，通常具有什么功能</strong></p><ol><li>分发和管理组织内的电子邮件地址和电子邮箱</li><li>实现组织内部和组织内外之间进行大批量邮件分发或转发功能</li><li>对邮件进行一定的过滤和筛选(去除垃圾和病毒邮件)</li></ol></blockquote><blockquote><p><strong>6、SMTP的主要作用</strong></p><p>电子邮件客户软件定时扫描邮件暂存队列，有待发邮件时，SMTP客户和目的地计算机SMTP服务器建立TCP连接。然后SMTP协议进行通过ASCII码命令和应答逐步协商，最后客户发出邮件副本，服务器接收副本。</p></blockquote><blockquote><p><strong>7、POP的主要作用</strong> 见POP介绍</p></blockquote><blockquote><p><strong>8、SMTP可以传递非ASCII码信息吗</strong> 当然可以了。。MIME</p></blockquote><hr><h1 id="WWW-概述"><a href="#WWW-概述" class="headerlink" title="WWW 概述"></a>WWW 概述</h1><h2 id="World-Wide-Web-是Internet上最受欢迎-应用-其思路来自CERN-欧洲粒子物理研究中心"><a href="#World-Wide-Web-是Internet上最受欢迎-应用-其思路来自CERN-欧洲粒子物理研究中心" class="headerlink" title="World Wide Web 是Internet上最受欢迎 应用  其思路来自CERN(欧洲粒子物理研究中心)"></a>World Wide Web 是Internet上最受欢迎 应用  其思路来自CERN(欧洲粒子物理研究中心)</h2><p>Tim Berners-Lee 在1990年开发了第一个基于超文本的分布式信息系统  1991年Gopher在Internet上运行</p><p>第一个图形界面的浏览器产生于1993年「Mosaic」</p><p><strong>www的设计基于超文本 HTML HTTP和浏览器</strong></p><h2 id="超文本-x3D-一般文本-到其他文档的链接-「其数据结构是指针链接的-网状结构-⚠️和树状区分-」"><a href="#超文本-x3D-一般文本-到其他文档的链接-「其数据结构是指针链接的-网状结构-⚠️和树状区分-」" class="headerlink" title="超文本 &#x3D;  一般文本 + 到其他文档的链接 「其数据结构是指针链接的 网状结构(⚠️和树状区分)」"></a>超文本 &#x3D;  一般文本 + 到其他文档的链接 「其数据结构是指针链接的 网状结构(⚠️和树状区分)」</h2><ul><li><p>超媒体 $\Rightarrow$ 超文本 + 图像、声音、视频的链接 (即把超文本扩展为更多的媒体) 「它们被总称为 Web文档」</p><ul><li><em>所谓的 Web文档IE(也被称为HTML文档) $\Rightarrow$ 网页</em></li></ul></li><li><p><em><strong>超文本和超媒体 决定了WWW是 非线性、联想式的文档集合 和一个布满链接的信息网</strong></em></p></li><li><h3 id="所谓的-Web-指的是由超文本-连接而成的信息集合-而WWW则是指-在世界范围内分布的Web服务器的集合"><a href="#所谓的-Web-指的是由超文本-连接而成的信息集合-而WWW则是指-在世界范围内分布的Web服务器的集合" class="headerlink" title="所谓的 Web 指的是由超文本 连接而成的信息集合  而WWW则是指 在世界范围内分布的Web服务器的集合"></a>所谓的 Web 指的是由超文本 连接而成的信息集合  而WWW则是指 在世界范围内分布的Web服务器的集合</h3><ul><li>WWW &#x3D;&gt; 建立在超文本和超媒体基础上的 全球分布的 <strong>在线式</strong>的信息网 (这一概念有时会和Web混用)</li><li>Web服务器同时也集成了E-Mail FTP TELNET等服务</li></ul></li></ul><h2 id="HTML-Hypertext-MakeUp-Language-超文本标记语言-用来创建和识别标准的-Web文档"><a href="#HTML-Hypertext-MakeUp-Language-超文本标记语言-用来创建和识别标准的-Web文档" class="headerlink" title="HTML Hypertext MakeUp Language 超文本标记语言      用来创建和识别标准的 Web文档"></a>HTML Hypertext MakeUp Language 超文本标记语言      用来创建和识别标准的 Web文档</h2><ul><li><h3 id="标记语言-Rightarrow-在文本中嵌入一系列-控制符号-使得文件按照作者的想法-显示或者打印"><a href="#标记语言-Rightarrow-在文本中嵌入一系列-控制符号-使得文件按照作者的想法-显示或者打印" class="headerlink" title="标记语言 $\Rightarrow$ 在文本中嵌入一系列 控制符号 使得文件按照作者的想法 显示或者打印"></a>标记语言 $\Rightarrow$ 在文本中嵌入一系列 控制符号 使得文件按照作者的想法 显示或者打印</h3></li><li><h3 id="HTML和普通的标记语言区别-Rightarrow-在它们的基础上-扩展了-x3D-x3D-超文本引用-x3D-x3D-通过点击实现自动跳转"><a href="#HTML和普通的标记语言区别-Rightarrow-在它们的基础上-扩展了-x3D-x3D-超文本引用-x3D-x3D-通过点击实现自动跳转" class="headerlink" title="HTML和普通的标记语言区别$\Rightarrow$在它们的基础上 扩展了 &#x3D;&#x3D;超文本引用&#x3D;&#x3D;(通过点击实现自动跳转)"></a>HTML和普通的标记语言区别$\Rightarrow$在它们的基础上 扩展了 &#x3D;&#x3D;超文本引用&#x3D;&#x3D;(通过点击实现自动跳转)</h3></li><li><p>「Web文档的格式 一般情况下 就是 HTML格式  当然也支持HTML以外的格式」</p><ul><li>超文本引用的原理：文本中被预先设置指向另一个文档的被动指针(被动是指 需要用户主动选择)</li><li><strong><em>任何内容</em>都可以作为超文本引用可选项</strong>(声音 图像也是可以的) 而这种机制 被称为 anchor <em><strong>锚</strong></em></li></ul></li><li><p>当然 除了利用<strong>超文本引用</strong>来实现定位之外  URL的应用也十分广泛</p></li></ul><h2 id="通过-URL-Uniform-精确-Resource-Locater-实现网页的定位-「见sp-edition-互联网传奇」"><a href="#通过-URL-Uniform-精确-Resource-Locater-实现网页的定位-「见sp-edition-互联网传奇」" class="headerlink" title="通过 URL Uniform(精确) Resource Locater 实现网页的定位 「见sp edition 互联网传奇」"></a>通过 URL Uniform(精确) Resource Locater 实现网页的定位 「见sp edition 互联网传奇」</h2><p>找到存放Web的计算机 $\Rightarrow$ 找到是这个计算机中存放的哪个网页 $\Rightarrow$ 确认访问此网页需要的协议 $\Rightarrow$ 对接网页显示的格式</p><p>URL的一般格式：</p><p>$$<br>协议:&#x2F;&#x2F;计算机域名:端口号(optional)&#x2F;路径&#x2F;Web文档名称<br>$$<br>「端口号 http&#x2F;Web &#x3D;&gt; 80 ； FTP &#x3D;&gt; 21 在采用默认端口号时 可以省略」</p><p><em><strong>值得注意的是 虽然URL输入时 可以大小写， 但实际上URL不区分大小写</strong></em></p><p><strong>使用URL定位时 因为必须指明特定的主机 如果访问量太大 会炸。 这时只能 就近访问和负载均衡。 而正在发展的URI(Universal Resource Indentifier) 尝试将资源名称和主机位置分离开</strong></p><h2 id="网页传输-和-HTTP-协议"><a href="#网页传输-和-HTTP-协议" class="headerlink" title="网页传输 和 HTTP 协议"></a>网页传输 和 HTTP 协议</h2><h3 id="我们先把浏览器和客户等同起来，-这时浏览器和Web服务器的交流就属于典型的C-x2F-S模式-但连接时间短-不记忆状态"><a href="#我们先把浏览器和客户等同起来，-这时浏览器和Web服务器的交流就属于典型的C-x2F-S模式-但连接时间短-不记忆状态" class="headerlink" title="我们先把浏览器和客户等同起来， 这时浏览器和Web服务器的交流就属于典型的C&#x2F;S模式(但连接时间短 不记忆状态)"></a>我们先把浏览器和客户等同起来， 这时浏览器和Web服务器的交流就属于典型的C&#x2F;S模式(但连接时间短 不记忆状态)</h3><blockquote><ul><li>浏览器作为客户 根据URL指定的域名 向DNS服务器请求解析 $\Rightarrow$ 得到目的IP地址</li><li>浏览器作为客户 和目的IP对应的计算机(和这个计算机上的 Web服务器) 建立TCP连接</li><li>浏览器作为客户 向Web服务器发送请求获取Web文档命令 (GET)</li><li>Web服务器响应请求 然后返回网页(Web文档)</li><li>浏览器接收完成并释放TCP连接， 在这之后显示网页</li></ul><p>我们也把HTTP的这种连接方式称为 「无状态连接」它可以实现快速的传输和调用 缺点在于如果访问同一个计算机上的多个网页，需要多次连接 产生额外的开销</p></blockquote><h3 id="HTTP的请求和响应格式"><a href="#HTTP的请求和响应格式" class="headerlink" title="HTTP的请求和响应格式"></a>HTTP的请求和响应格式</h3><p>这是一条HTTP请求命令</p><p>以下是HTTP的某些响应命令</p><h3 id="HTTP具有以下的特点"><a href="#HTTP具有以下的特点" class="headerlink" title="HTTP具有以下的特点"></a>HTTP具有以下的特点</h3><blockquote><ol><li><h4 id="可以-高速处理-大量请求。-「包含6种请求方式-URL格式化信息-服务器简单应答」-从开销上看HTTP优于FTP"><a href="#可以-高速处理-大量请求。-「包含6种请求方式-URL格式化信息-服务器简单应答」-从开销上看HTTP优于FTP" class="headerlink" title="可以 高速处理 大量请求。 「包含6种请求方式(URL格式化信息) 服务器简单应答」  (从开销上看HTTP优于FTP)"></a>可以 高速处理 大量请求。 「包含6种请求方式(URL格式化信息) 服务器简单应答」  (<strong>从开销上看HTTP优于FTP</strong>)</h4></li><li><h4 id="可以传输任意类型的数据-并且-采用-C-x2F-S模式-支持全球访问-支持所有的超文本和超媒体"><a href="#可以传输任意类型的数据-并且-采用-C-x2F-S模式-支持全球访问-支持所有的超文本和超媒体" class="headerlink" title="可以传输任意类型的数据 并且 采用 C&#x2F;S模式 支持全球访问    支持所有的超文本和超媒体"></a>可以传输任意类型的数据 并且 采用 C&#x2F;S模式 支持全球访问    支持所有的超文本和超媒体</h4></li><li><h4 id="短连接-无状态-「一次请求-一次应答-并不记忆任何状态」"><a href="#短连接-无状态-「一次请求-一次应答-并不记忆任何状态」" class="headerlink" title="短连接 + 无状态 「一次请求 一次应答 并不记忆任何状态」"></a>短连接 + 无状态 「一次请求 一次应答 并不记忆任何状态」</h4></li><li><h4 id="可协商。-客户请求可以指明可接受的响应类型。"><a href="#可协商。-客户请求可以指明可接受的响应类型。" class="headerlink" title="可协商。 客户请求可以指明可接受的响应类型。"></a>可协商。 客户请求可以指明可接受的响应类型。</h4></li></ol></blockquote><h2 id="分布式Web-普通-与非分布式Web-公司内-｜-Web代理服务"><a href="#分布式Web-普通-与非分布式Web-公司内-｜-Web代理服务" class="headerlink" title="分布式Web(普通)与非分布式Web(公司内) ｜  Web代理服务"></a>分布式Web(普通)与非分布式Web(公司内) ｜  Web代理服务</h2><p>普通的Web文档被存放在不同的计算机上 由不同人员独立管理 由于管理人员之间信息不一定互通 所以可能会出现无效网页 错误定位等意外情况。</p><p><strong>而非分布式的 Web系统会将每个Web文档集中存放在某个计算机上，其Web文档的超链接也是本地的 并且由专门的人员统一管理， 相比分布式Web 更能保证链接的有效性和一致性</strong></p><h3 id="Web代理服务-「大量的Web访问可能占满Internet的带宽-所以做一个cache」"><a href="#Web代理服务-「大量的Web访问可能占满Internet的带宽-所以做一个cache」" class="headerlink" title="Web代理服务 「大量的Web访问可能占满Internet的带宽 所以做一个cache」"></a>Web代理服务 「大量的Web访问可能占满Internet的带宽 所以做一个cache」</h3><p>Web Proxy&#x2F;Cache Server 会用一个高速缓存存储被大量访问的Web文档</p><p>如果你连接了校园网 一般在访问WWW时 先被校园网出口的路由器重定向到Web Cache 如果里面没有再进行访问(同时把结果存在Proxy中)</p><h2 id="浏览器-Browser-Web系统最重要部分-是用户进入Internet的主要入口「本质上是Web系统的客户端」"><a href="#浏览器-Browser-Web系统最重要部分-是用户进入Internet的主要入口「本质上是Web系统的客户端」" class="headerlink" title="浏览器 Browser  Web系统最重要部分 是用户进入Internet的主要入口「本质上是Web系统的客户端」"></a>浏览器 Browser  Web系统最重要部分 是用户进入Internet的主要入口「本质上是Web系统的客户端」</h2><h3 id="浏览器实现的功能-「为了满足多功能客户端桌面的需求-」"><a href="#浏览器实现的功能-「为了满足多功能客户端桌面的需求-」" class="headerlink" title="浏览器实现的功能 「为了满足多功能客户端桌面的需求 」"></a>浏览器实现的功能 「为了满足多功能客户端桌面的需求 」</h3><blockquote><ol><li>网页浏览</li><li>作为HTTP客户 通过TCP&#x2F;IP网络 完成用户对选择URL的请求和文档接受</li><li>解析Web文档(HTML文档)  这个功能也包括控制外设来显示这个Web文档</li><li>提供额外的服务 支持多格式文档(比如flash服务)  从实际设计角度上看 Browser甚至比Web服务器更加的复杂</li></ol><ul><li>这一项同时也意味着 浏览器可以包含支持其他服务的客户端软件(FTP&#x2F;E-Mail等)</li><li>所以 Browser&#x2F;Web Server 「B&#x2F;S」已经逐渐发展为互联网应用的统一形式</li></ul></blockquote><h2 id="Web体系结构-｜-Browser-x2F-Web-Server模式-B-x2F-S模式｜Web技术的发展"><a href="#Web体系结构-｜-Browser-x2F-Web-Server模式-B-x2F-S模式｜Web技术的发展" class="headerlink" title="Web体系结构 ｜ Browser&#x2F;Web Server模式 B&#x2F;S模式｜Web技术的发展"></a>Web体系结构 ｜ Browser&#x2F;Web Server模式 B&#x2F;S模式｜Web技术的发展</h2><p>浏览器通过URL 在TCP基础上 HTTP协议规定B&#x2F;S之间遵循的规则和需要进行的操作</p><p>&#x3D;&#x3D;这也体现出WWW的核心： 超文本｜HTML&#x2F;URL结构｜HTTP｜浏览器&#x3D;&#x3D;</p><h3 id="B-x2F-S体系结构-是作为C-x2F-S的后继发展类型"><a href="#B-x2F-S体系结构-是作为C-x2F-S的后继发展类型" class="headerlink" title="B&#x2F;S体系结构    是作为C&#x2F;S的后继发展类型"></a>B&#x2F;S体系结构    是作为C&#x2F;S的后继发展类型</h3><p>Browser在90年代中期开始逐渐成为主流 其客户端采用标准化浏览器(Java虚拟机 多媒体解析显示+简单逻辑操作)</p><p>Web服务器要做的事 解决应用开发 逻辑计算 网页封装和管理 使网络应用系统的升级 扩展和维护更加方便</p><p>在现在的B&#x2F;S服务器端 Web服务器演变为新的 <strong>MVC</strong>结构「WebSever+应用服务器+数据库服务器」</p><p>M $\Rightarrow$ 业务逻辑   V $\Rightarrow$ 展示    C $\Rightarrow$ 控制  这种结构是目前电子商务、政务广泛流行的架构</p><h3 id="Web技术的发展"><a href="#Web技术的发展" class="headerlink" title="Web技术的发展"></a>Web技术的发展</h3><h4 id="1-HTML-Rightarrow-XML-表示数据时-HTML的个性化不够-所以需要建立一种具有理解数据格式和结构的规则和方法"><a href="#1-HTML-Rightarrow-XML-表示数据时-HTML的个性化不够-所以需要建立一种具有理解数据格式和结构的规则和方法" class="headerlink" title="1. HTML $\Rightarrow$ XML  表示数据时 HTML的个性化不够 所以需要建立一种具有理解数据格式和结构的规则和方法"></a>1. HTML $\Rightarrow$ XML  表示数据时 HTML的个性化不够 所以需要建立一种具有理解数据格式和结构的规则和方法</h4><h4 id="2-Web2-0和语义Web"><a href="#2-Web2-0和语义Web" class="headerlink" title="2. Web2.0和语义Web"></a>2. Web2.0和语义Web</h4><hr><blockquote><p><strong>什么是超媒体、HTML 与Web？</strong></p><p>超媒体：在超文本中加入了图像、声音和视频的链接。可调出指针指向多媒体的信息</p><p>HTML：超文本标记语言，在普通标记语言的基础上扩展了超文本引用</p><p>Web：由超文本(超媒体)连接而成的信息集合</p></blockquote><blockquote><p><strong>为什么有时链接打开一个网页会发现无效？</strong></p><p>WWW是基于互联网的分布式的超媒体(超文本), 每个Web文档存放在不同的计算机上，并由不同的人员独立管理，其修改、删除、增加或者重命名等不会(实际上是无法) 通知相连的其他节点。因此会出现链接无效 或者链接不一致的情况。</p></blockquote><blockquote><p><strong>如何区分分布式Web和非分布式Web系统，试说明两者的可能的应用场合。</strong></p><p>相比分布式Web系统，非分布式Web系统将所有的Web文档集中存放在某一个计算机上，通常通常其Web文档的超链也是本地的，并由专门人员统一管理，能够很好的保持链接的一致性和有效性。</p><p>分布式的Web将Web服务器散布在Internet的各处，所有Internet上的Web服务器构成了万维网，是Internet上最受欢迎的应用，</p><p>非分布式的Web系统可以应用在公司或组织的内部资料库中，由专门的人员管理，也只有公司本地网段的计算机可以访问。</p></blockquote><blockquote><p><strong>试说明C&#x2F;S结构和B&#x2F;S结构的异同。</strong></p><p>B&#x2F;S结构是由C&#x2F;S结构演变而来的，采用了客户层｜中间层｜服务器 的三层结构，是基于WWW产生的。</p><p>不同之处：</p><p>B&#x2F;S的设计目的是为了满足接入Internet的普通用户需求，而C&#x2F;S则更多的由专业用户使用，同时有一定的门槛</p><p>B&#x2F;S建立在WWW(Internet)上，而C&#x2F;S则常常被部署在局域网上</p><p>B&#x2F;S的兼容性强 部署容易，而C&#x2F;S的部署比较复杂</p><p>B&#x2F;S系统的开发和维护开销都比较小，而C&#x2F;S相对来说更大一些</p><p>B&#x2F;S建立在广域网上，相比C&#x2F;S结构对于安全性的要求更低</p></blockquote><blockquote><p><strong>B&#x2F;S架构是互联网应用基本形式，什么类应用不适合B&#x2F;S架构？</strong></p><p>B&#x2F;S的架构开发和维护都相对简单 但由于是基于WWW而设计，只需要和本地服务器交互，不需要连接互联网的应用，不适合用B&#x2F;S架构。</p><p>另外，由于其无状态连接的特点，需要点对点高强度交互的应用，不适合使用B&#x2F;S架构。</p><p>虽然浏览器的功能非常强大，但如果用户需要某些特定的功能(比如游玩大型的网络游戏)，就需要专门的客户端软件，而不适合B&#x2F;S架构。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>互联网原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS</title>
    <link href="/2021/01/04/DNS-&amp;-FTP/"/>
    <url>/2021/01/04/DNS-&amp;-FTP/</url>
    
    <content type="html"><![CDATA[<h2 id="4-1-域名服务系统-DNS-Domain-Name-System"><a href="#4-1-域名服务系统-DNS-Domain-Name-System" class="headerlink" title="4.1 域名服务系统 DNS[Domain Name System]"></a>4.1 域名服务系统 DNS[Domain Name System]</h2><h3 id="DNS系统概述"><a href="#DNS系统概述" class="headerlink" title="DNS系统概述"></a>DNS系统概述</h3><p>我们显然可以通过输入 IP地址来访问网站。 使用DNS只是为了 让字符化的计算机域名 能够起到 特征标示的作用。</p><p><em><strong>DNS 的作用是 将 用户使用的域名 和 计算机使用的IP地址 互相转换(translation)</strong></em></p><p><strong>备注：</strong></p><p><strong>1. DNS 同时也表示 Domain Name Server</strong></p><p><strong>2. DNS所实现的转换是 双向的</strong></p><p><strong>3. 域名的翻译是自动完成的 依赖分布在全球的一系列服务器完成， DNS实现的翻译 属于C&#x2F;S交互</strong></p><h3 id="Internet-域名构造"><a href="#Internet-域名构造" class="headerlink" title="Internet 域名构造"></a>Internet 域名构造</h3><p><strong>因特网将这些域名划分成 树状体系 最高级的域名一般是通用域名&#x2F;国家&#x2F;基础结构域类。 在这些最高级域名下划分子类 逐渐延伸</strong></p><p>我们的高级域名<code>.cn</code> 之下 定义了7个2级域名 ac(研究机构)  com    edu    gov    mil    net    org    以及34个行政区域名</p><p><strong>如果你想要使用最高级域名， 必须向Internet管理机构ICANN(或其授权管理机构 比如中国的CCNIC)登记，层层递进</strong></p><h3 id="DNS层次结构和服务器分布模型"><a href="#DNS层次结构和服务器分布模型" class="headerlink" title="DNS层次结构和服务器分布模型"></a>DNS层次结构和服务器分布模型</h3><ul><li>每个DNS服务器 都是域名体系中部分域名的实际管理者，要负责具有某后缀的所有计算机权威管理</li><li>每个计算机域名也必须在对应的DNS组织(服务器)登记</li><li>DNS具有命名 和 服务器设置的 自治性</li><li>每个DNS服务器 只能完成部分计算机域名的处理，因此因特网所有的DNS服务器宏观上被连接成了一个系统。<ul><li>这意味着：<strong>每个DNS服务器都知道如何找到根DNS服务器，以及如何找到下级的DNS服务器</strong></li></ul></li><li>对大型组织集中单一DNS服务很困难。但由于DNS服务具有 <strong>局部访问性原理</strong> 我们可以按照层次制定分布DNS服务策略</li></ul><h3 id="DNS记录和协议报文格式"><a href="#DNS记录和协议报文格式" class="headerlink" title="DNS记录和协议报文格式"></a>DNS记录和协议报文格式</h3><h5 id="DNS的拓扑"><a href="#DNS的拓扑" class="headerlink" title="DNS的拓扑"></a>DNS的拓扑</h5><p>一般组织使用单一DNS服务器，小型公司作为用户，和提供DNS的ISP连接，DNS服务也由和其连接的ISP完成</p><hr><blockquote><p><strong>试解释中文域名可能的工作原理</strong></p><p>我认为现在的DNS系统已经比较成熟，所以中文域名的工作可以从从用户角度入手，即将用户输入的中文域名，翻译成英文域名，然后接入现有的DNS体系框架内。</p><p>在用户使用的浏览器中添加扩展，使得浏览器能够实现汉字输入转换，并考虑使用缺省和机器学习来优化</p><p>如输入 百度 则浏览器转化为 <a href="https://www.baidu.com/">https://www.baidu.com</a> 实际上仍然使用现有的DNS服务</p></blockquote><blockquote><p><strong>试说明DNS服务器怎样获取请求客户主机域名的？</strong></p><ol><li>客户机想要查询时首先在本地计算机缓存中查找，如果无法获得查询信息，则向本地DNS服务器发送查询请求</li><li>本地DNS服务器收到请求，首先在其管理区域记录里查询，如果找到了，则直接解析并返回，没找到则执行3</li><li>本地DNS服务器将客户的请求发送到根域名DNS服务器。根域名服务器解析请求的根域部分，并以此获知管理下一级域名的DNS服务器地址，并将这个地址返回给本地DNS服务器。</li><li>本地DNS服务器利用上一级域名服务器给出的地址访问下一级DNS服务器，得到更下一级的DNS服务器地址，同样，这个地址被返回给本地DNS服务器。</li><li>返回递归执行步骤4 直到本地DNS服务器获取到知道域名对应IP的DNS服务器传回的IP地址</li><li>本地DNS服务器将查询结果返回客户 完成解析过程</li></ol><p><strong>两个DNS服务器包含完全相同的域名有意义吗？为什么？</strong></p><p>是有意义的。因为DNS的解析是递归的过程，如果有两个不同的DNS服务器都包含这个域名，说不定可以减少递归的次数，提高DNS服务的效率。</p><p><strong>试分析DNS体系的层次数对域名解析速度是否有影响？</strong></p><p><strong>有影响</strong>。如果你要访问的域名离自己的本地DNS服务器太远，你的访问请求将被迫一级一级的不断上传，同时一级一级的向下返回，虽然传输的时延不长，但处理和排队的时延累加起来就很长了。比如我们访问国外的网站，即使没有被屏蔽也会很慢。</p><p><strong>DNS系统为什么要优化，优化措施主要有哪些？</strong></p><p><strong>无论是递归还是迭代</strong>的请求方式，本质上其实<strong>效率都很糟糕</strong>，特别是根服务器的负载非常大，并且根服务器作为枢纽一旦下线，非本地访问的DNS服务几乎就中断了。</p><h5 id="但由于一台计算机经常访问本地域名或重复访问同样的域名，所以可以进行以下的优化处理："><a href="#但由于一台计算机经常访问本地域名或重复访问同样的域名，所以可以进行以下的优化处理：" class="headerlink" title="但由于一台计算机经常访问本地域名或重复访问同样的域名，所以可以进行以下的优化处理："></a>但由于一台计算机经常访问本地域名或重复访问同样的域名，所以可以进行以下的优化处理：</h5><ol><li>复制。复制多个根服务器副本，按照地域分布，实现就地DNS域名服务</li><li>缓存。每次查找新域名 本地DNS服务器将地址联编副本进行缓存 实际上客户的浏览器也有类似的 域名缓存措施</li></ol></blockquote><hr><h2 id="4-2-FTP-File-Transfer-Protocol"><a href="#4-2-FTP-File-Transfer-Protocol" class="headerlink" title="4.2 FTP [File Transfer Protocol]"></a>4.2 FTP [File Transfer Protocol]</h2><h3 id="FTP-概述"><a href="#FTP-概述" class="headerlink" title="FTP 概述"></a>FTP 概述</h3><p>FTP的产生 $\rightarrow$ 早期Internet(ARPANET) 的工作主要是 信息交互 (特别是文件交互共享)</p><p><strong>从历史上讲 FTP的产生要早于TCP (现在则是使用新的FTP协议 ) 在95年之前 FTP占据因特网通信量的 1&#x2F;3</strong></p><h2 id="FTP需要解决-在异构计算机之间的-通用文件传递-这需要克服不同文件系统的差异："><a href="#FTP需要解决-在异构计算机之间的-通用文件传递-这需要克服不同文件系统的差异：" class="headerlink" title="FTP需要解决 在异构计算机之间的 通用文件传递 这需要克服不同文件系统的差异："></a>FTP需要解决 在<em><strong>异构计算机之间的 通用文件传递</strong></em> 这需要克服不同文件系统的差异：</h2><ol><li>通用性 </li><li>跨平台特性</li><li>传输和控制 $\rightarrow$ 控制 上传 下载</li><li><strong>FTP可以支持 任意类型的数据文件</strong></li><li>FTP可以加密 可以控制访问</li></ol><h5 id="FTP主要提供2种交互方式-即-实时交互-和-批处理"><a href="#FTP主要提供2种交互方式-即-实时交互-和-批处理" class="headerlink" title="FTP主要提供2种交互方式 即  实时交互 和 批处理"></a>FTP主要提供2种交互方式 即  实时交互 和 批处理</h5><p>值得注意的是 可以建立一种 同时实现两种方式的 服务</p><h2 id="FTP只有-文本-和-binary-两种格式「FTP传输的是-文件的副本-而不是文件本身」"><a href="#FTP只有-文本-和-binary-两种格式「FTP传输的是-文件的副本-而不是文件本身」" class="headerlink" title="FTP只有 文本 和 binary 两种格式「FTP传输的是 文件的副本 而不是文件本身」"></a>FTP只有 文本 和 binary 两种格式「<em><strong>FTP传输的是 文件的副本 而不是文件本身</strong></em>」</h2><p>视频 浮点数 图形… 只要不是文本 全部都使用binary 传输</p><p>当然 二进制会出现在FTP两边格式不一样的情况 这FTP不管</p><h3 id="FTP工作原理-「两条连接-控制和数据传输分离」"><a href="#FTP工作原理-「两条连接-控制和数据传输分离」" class="headerlink" title="FTP工作原理 「两条连接 控制和数据传输分离」"></a>FTP工作原理 「两条连接 控制和数据传输分离」</h3><p><strong>两端的进程会分别启动 控制和数据传送进程(它们是主进程的从属进程 并且相互独立)</strong></p><ol><li><strong>客户通过临时端口号N 和 FTP服务器(端口号 21 这是个熟知端口)  建立TCP链接</strong><ul><li><strong>这条连接 只是用来控制 由客户发起 服务器接受。 客户端输入的命令从这里发到服务器中</strong></li></ul></li><li><strong>服务器并不会马上 建立传输连接，而是在客户发起命令 确认一个文件之后</strong> </li><li><strong>服务器通过 <em>端口号20</em> 与<em>客户端口号N+1</em> 建立TCP连接</strong><ul><li>*<em>这条连接 只是用来传输 <em>由服务器发起 也会由服务器结束</em>。</em>*</li></ul></li></ol><h3 id="FTP交互方式的特点"><a href="#FTP交互方式的特点" class="headerlink" title="FTP交互方式的特点"></a>FTP交互方式的特点</h3><ol><li>两个不同的端口号分别建立控制连接和数据连接 目的是让命令交互 和 文件数据交互 之间不互相干扰</li><li>服务器在完成文件传递后 关闭数据连接 给客户端一个 文件结束条件</li><li>FTP命令可以控制远程计算机上的文件操作 就好像在操作本地文件一样</li></ol><h3 id="FTP登陆-和-常用命令"><a href="#FTP登陆-和-常用命令" class="headerlink" title="FTP登陆 和 常用命令"></a>FTP登陆 和 常用命令</h3><ol><li>输入 Open计算机域名 和这个计算机建立TCP连接。 使用Close 来关闭连接(并不是关闭FTP程序！)</li><li>对于私有的FTP服务 需要输入用户名+口令； 而有些开放的FTP服务 使用anonymous(guest) &#x2F; 电邮账户 即可实现访问了</li></ol><p><strong>FTP 一般使用命令行进行交互 客户端有约50条命令</strong></p><p>通用标准化处理(解决跨平台(OS)传输)</p><p>我们想要做到OS对FTP的C&#x2F;S透明。因此定义了 <strong>Telnet NVT(Network Vietual Terminal)网络虚拟终端</strong></p><p>这样 FTP和OS就不进行直接的交互了 而是通过NVT标准格式接口 在传输过程中 实际上就是</p><p>本地终端格式 $\rightarrow$转换为 NVT格式 $\rightarrow$ 传输 $\rightarrow$ NVT转换为本地主机格式 $\rightarrow$ 本地主机格式</p><p>NVT格式 统一使用8bit通信 7位ASCII码 最高位 为1 $\rightarrow$ 控制命令</p><h3 id="NFS-Network-File-System"><a href="#NFS-Network-File-System" class="headerlink" title="NFS(Network File System)"></a>NFS(Network File System)</h3><p>一般被集成在一个大的文件系统里</p><p>和FTP类似 但不传输文件副本 一般只传递 复制&#x2F;改变 文件的小片段</p><p>使用TCP和UDP 实现不同操作系统的各种终端和主机间远程登录和文件命令操作</p><blockquote><p><strong>1、怎样理解NVT？</strong></p></blockquote><blockquote><p><strong>2、FTP目前主要使用在什么场合，为什么不十分流行？</strong></p><p>FTP目前一般在公司或单位的内部进行公开的文件传输时使用。</p><p>不流行的原因：<br>\1. 使用命令行进行交互 没有图形界面 这意味着使用FTP的门槛要更高。</p><p>\2. 安全性不够高，FTP的信息在信道上可能被劫持 这样信息就全部泄漏了。</p><p>\3. FTP诞生时间太早，不适合现在的网络架构。使用两条TCP连接比较浪费，虽然是稳定的传输，但效率不够高，会浪费一些网络资源。</p></blockquote><blockquote><p><strong>3、在一条传输链路连接的网络两端，用FTP传输一个大文件，然后根据文件字节数和传输的时间测量链路的数据传输容量，是否准确？试说明理由。</strong></p><p>不准确。因为FTP的底层是TCP传输(TCP传输又需要进行IP层的封装)，这意味着大文件 会被封装成TCP报文段。大文件长度很可能大大超过了MTU，这意味着需要很多个TCP报文段来传输这个文件。如果只算文件字节数而忽略TCP报文头和IP报文头，算出的数据传输容量会有较大的偏差(会偏小)。</p></blockquote><blockquote><p><strong>4、二进制模式和文本模式下传输同一个文本文件，试说明两种模式传输时间哪个大？为什么？</strong></p><p>文本模式下 会花费更长时间。 FTP的文本使用ASCII&#x2F;EBCDIC 字符集，在FTP发送和接收前需要经过转换(本地文本文件$\rightarrow$ ASCII&#x2F;EBCDIC $\rightarrow$ 本地文本文件)，并且还需要加入控制字符。而二进制是不进行任何表达转换处理，直接传输文件副本。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>互联网原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络服务模式&amp;API</title>
    <link href="/2021/01/04/C:S%E4%B8%8EAPI/"/>
    <url>/2021/01/04/C:S%E4%B8%8EAPI/</url>
    
    <content type="html"><![CDATA[<h1 id="网络服务模式与API"><a href="#网络服务模式与API" class="headerlink" title="网络服务模式与API"></a>网络服务模式与API</h1><h2 id="Client-x2F-Server-模式"><a href="#Client-x2F-Server-模式" class="headerlink" title="Client&#x2F;Server 模式"></a>Client&#x2F;Server 模式</h2><h3 id="因特网的基本通信模式"><a href="#因特网的基本通信模式" class="headerlink" title="因特网的基本通信模式"></a>因特网的基本通信模式</h3><ul><li><h5 id="流模式-如-Web通信"><a href="#流模式-如-Web通信" class="headerlink" title="流模式(如: Web通信)"></a>流模式(如: Web通信)</h5></li><li><h5 id="报文模式"><a href="#报文模式" class="headerlink" title="报文模式"></a>报文模式</h5></li></ul><h3 id="C-x2F-S模式基本概念"><a href="#C-x2F-S模式基本概念" class="headerlink" title="C&#x2F;S模式基本概念"></a>C&#x2F;S模式基本概念</h3><h5 id="一种基于网络的信息交互-计算-分布模式"><a href="#一种基于网络的信息交互-计算-分布模式" class="headerlink" title="一种基于网络的信息交互/计算 分布模式"></a><code>一种基于网络的信息交互/计算 分布模式</code></h5><p><strong>网络软件被分为client和server 这两个名词直接指向通信中的两个进程，而不是主机</strong></p><h3 id="C-x2F-S模式的关系和特点"><a href="#C-x2F-S模式的关系和特点" class="headerlink" title="C&#x2F;S模式的关系和特点"></a>C&#x2F;S模式的关系和特点</h3><ul><li>对于C&#x2F;S模式 一定&#x3D;&#x3D;由客户发起请求，而服务器只被动响应&#x3D;&#x3D; $\rightarrow$ 请求&amp;应答 的分布计算(会话)模式</li><li>应用进程可以同时是服务器和客户</li></ul><blockquote><p>对于服务器软件 $\rightarrow$ <strong>主体框架 + 单个服务请求处理 + 并发服务请求处理</strong></p><ul><li>在共享计算机上首先运行，当系统启动时自动调用并不断运行</li><li>被动等待并且接受来自任意客户的通信请求 在大部分情况下 服务器软件提供单一的服务</li><li>可以同时处理多个远地&#x2F;本地客户的请求，但也需要强大的硬件和高级的操作系统支持  <strong>并发执行是服务器必须具备的</strong></li><li><strong>一个服务器软件包括 接收请求、处理单个请求和生成新线程三个部分</strong></li></ul></blockquote><blockquote><p>对于客户软件 $\rightarrow$ <strong>客户软件只是一个应用程序在进行服务器访问时的称呼</strong></p><ul><li>是任意的应用程序，它一般还能在本地做其它的事情</li><li>被用户调用 主动向远地服务器发起通信</li></ul></blockquote><h5 id="较复杂的C-x2F-S交互"><a href="#较复杂的C-x2F-S交互" class="headerlink" title="较复杂的C&#x2F;S交互"></a>较复杂的C&#x2F;S交互</h5><ul><li>客户应用不限制访问一个服务器，它需要同时和多个服务器通信。</li><li>服务器在提供服务的同时也需要作为另一个服务器的客户</li><li>服务器间可能会出现循环依赖</li></ul><p>在早期C&#x2F;S系统中 服务器计算机通常作为信息共享的设备部署(文件服务器、数据库服务器) 客户端自己来计算和跑程序</p><p>现今阶段 服务器是数据与业务功能处理中心 客户端则主要是UI界面+少量辅助功能处理</p><hr><h3 id="服务器识别"><a href="#服务器识别" class="headerlink" title="服务器识别"></a>服务器识别</h3><p><strong>Protocol Port Number 协议端口号 (OSI 术语是运输层服务访问点TSAP) 是TCP&#x2F;UDP给每种服务定义的标识</strong></p><p>对于源进程(它发起了请求)交付通信时通过 端口号明确自己的身份 还有接收方身份</p><p>收端进程会通过端口号来向目的进程交付。(很明显 这一切都发生在运输层)</p><p>对于服务器 通过端口号来明确提供的服务</p><h5 id="服务器端口号必须是唯一定义的-而客户端的端口号可以是临时指定的-只在本地有意义"><a href="#服务器端口号必须是唯一定义的-而客户端的端口号可以是临时指定的-只在本地有意义" class="headerlink" title="服务器端口号必须是唯一定义的 而客户端的端口号可以是临时指定的(只在本地有意义)"></a>服务器端口号必须是唯一定义的 而客户端的端口号可以是临时指定的(只在本地有意义)</h5><blockquote><p><strong>在使用TCP通信时 只有端口号是不够的 TCP的两个端点由Socket 插口 :(IP地址，端口号)定义</strong> (或者叫端地址)</p></blockquote><h5 id="协议端口号定义"><a href="#协议端口号定义" class="headerlink" title="协议端口号定义"></a>协议端口号定义</h5><p>TCP&#x2F;UDP定义一套16bit整数值 端口号被分为熟知端口号和一般端口号两列</p><p>熟知端口号 : FTP $\rightarrow$ 21    Telnet $\rightarrow$ 23    SMTP $\rightarrow$ 25    DNS $\rightarrow$ 53    TFTP $\rightarrow$ 69    HTTP $\rightarrow$ 80    SNMP $\rightarrow$ 161</p><p>一般端口号可以在规定区域内随意定义和分配</p><p>主要的端口号在1-225之间</p><p>端口号256-1023由Unix系统占用 </p><p>1024-5000作为临时端口 5000+不常出现 </p><h3 id="其他的交互模式"><a href="#其他的交互模式" class="headerlink" title="其他的交互模式"></a>其他的交互模式</h3><blockquote><p>C&#x2F;S模式比较简单 但容易造成网络瓶颈 并且负载不均衡问题也会使得服务器常常过载</p></blockquote><h5 id="P2P-peer-to-peer-：无中心服务器的流行网络技术-依赖所有参与者的计算能力和带宽-占到因特网流量的50-90"><a href="#P2P-peer-to-peer-：无中心服务器的流行网络技术-依赖所有参与者的计算能力和带宽-占到因特网流量的50-90" class="headerlink" title="P2P (peer to peer)：无中心服务器的流行网络技术 依赖所有参与者的计算能力和带宽 占到因特网流量的50%-90%"></a>P2P (peer to peer)：无中心服务器的流行网络技术 依赖所有参与者的计算能力和带宽 占到因特网流量的50%-90%</h5><hr><blockquote><p><strong>因特网通信模式和C&#x2F;S模式各自说明什么问题</strong></p><p>因特网通信模式：流模式和报文模式有着比较鲜明的特点，说明我们对因特网功能的需求是多样的，而网络技术也可以用不同的通信模式来满足不同的用户需求，但也说明想要实现稳定可能就需要牺牲效率，实现高效可能就保证不了可靠的传输。</p><p>C&#x2F;S模式：早期的C&#x2F;S模式以文件数据访问服务为主，客户程序也需要进行计算。而现今的C&#x2F;S模式在强大的服务器算力支撑下，客户端几乎不用承担计算任务，这说明C&#x2F;S模式的确得到了大规模的应用，所以服务器技术才能发展的如此迅速。</p></blockquote><blockquote><p><strong>简述客户软件和服务器软件主要特点</strong></p><p>服务器软件：</p><ol><li>专门提供某类服务的程序，一定可以并行的处理多个客户请求。</li><li>运行在共享计算机上，只要系统不关闭，就一直运行。</li><li>被动等待并且接收来自任意用户的通信请求</li><li>一般需要较强大的硬件和高级的操作系统支持</li></ol><p>客户软件：</p><ol><li>只有在进行通信时才被称为客户，它也可能可以在本地进行其他的计算并且实现其他功能。</li><li>由用户调用，在用户本地计算机上运行，在用户有需要时主动向远地服务器发起通信请求。</li><li>可以与多个服务器通信 并且一般不需要特殊硬件和复杂的操作系统</li></ol></blockquote><blockquote><p><strong>一个服务器软件通常需要包括哪些主要的功能部分？</strong></p><p>一个服务器软件主要包括：等待接收请求、处理单个请求和生成新线程</p></blockquote><blockquote><p><strong>为什么通常服务器端口号是唯一定义的，而客户端的端口号可以临时指定？</strong></p><p>服务器端口号唯一定义是为了让所有的客户都能正确找到它。因为C&#x2F;S交互的身份问题，客户端的端口号只需要做到不和自己同时运行的其他进程混淆即可，临时指定端口号也可以实现同一个端口号的复用(当某个客户软件不运行时就不占用端口号了)</p></blockquote><hr><h1 id="API-Application-Program-Interface"><a href="#API-Application-Program-Interface" class="headerlink" title="API [Application Program Interface]"></a>API [Application Program Interface]</h1><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h5 id="是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节"><a href="#是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节" class="headerlink" title="是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节"></a><code>是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节</code></h5><ul><li><strong>在应用从操作系统中获得相关服务时 通过调用API 将任务和控制权都交给操作系统，在执行完毕后，操作系统会交还控制权</strong></li><li>网络通信和数据交互调用API $\rightarrow$ 网络API(他是应用程序和TCP&#x2F;IP协议通信交互的接口)</li><li><strong>API造就了 应用和网络 的一体 和 分离 $\rightarrow$  在使用时一体，在开发时分离</strong></li></ul><p>互联网中主要有两类API 伯克利版 $\rightarrow$ Socket API 以及 A&amp;AT版 $\rightarrow$ TLI[Transport Lay Interface]</p><p>其中Socket API被主流操作系统使用，成为标准。</p><h3 id="Socket-API"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h3><ul><li>它来自Unix 由于Unix一切皆文件(open - read - write - close)的哲学影响，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</li><li><strong>在通信前 APP要向OS申请一个 套接字(也叫通信描述符)，OS返回一个小的整形数作为描述符来识别这个套接字 在通信结束后，这个代表特殊参数的套接字会被回收</strong></li><li><strong>套接字API 定义并调用多个函数来确定参数和选项 (创建套接字(返回描述符)，然后调用这些函数来完成对接)</strong></li></ul><h3 id="实现套接字API的函数"><a href="#实现套接字API的函数" class="headerlink" title="实现套接字API的函数"></a>实现套接字API的函数</h3><ol><li><p><code>Socket</code>函数 <strong>&#x2F;&#x2F; 创建套接字并返回整型描述符</strong></p><p>$Descriptor &#x3D; socket(pf,type,protocol)$ </p><p>pf $\rightarrow$ ProtocolFamily:协议栈(TCP&#x2F;IP)  Type $\rightarrow$ 连接&#x2F;无连接 protocol $\rightarrow$ 具体协议</p></li><li><p><code>Bind</code> 函数 <strong>&#x2F;&#x2F; 赋予套接字特定的端地址，实现socket和端地址的联编</strong> &#x3D;&#x3D;联编相当于 绑定&#x3D;&#x3D;</p><p>$Bind(socket,locaaddr,addrlen)$ <strong>&#x2F;&#x2F; 不建立连接的话，bind函数之后就可以交互数据了</strong></p><p>loca addr $\rightarrow$ 本地端地址的一般socket地址描述结构。</p></li><li><p><code>Close</code> 函数 <strong>&#x2F;&#x2F; 告诉系统终止对一个套接字的使用(释放这个套接字)</strong></p><p>$close(socket)$ <strong>&#x2F;&#x2F; 如果面向连接，则先关闭连接，再回收套接字</strong></p></li><li><p><code>Listen</code> 函数 **&#x2F;&#x2F; (<em>只有面向连接使用) 套接字被设置为被动模式，等待连接请求</em>*</p><p>$Listen(socket,queuesize)$ Queue size $\rightarrow$ 客户请求队列长度</p></li><li><p><code>Connect</code>函数 <strong>&#x2F;&#x2F; 面向连接时使用，启动与服务器的连接(前提是服务器已经调用了listen和accept)</strong></p><p>$connect(socket,saddress,saddresslen)$  &#x2F;&#x2F;在UDP时 也可以使用 此时完成socket和目的服务器端地址联编</p></li><li><p><code>Accept</code>函数 **&#x2F;&#x2F; (<em>只有面向连接使用) 确定客户端的地址，确认连接，这时需要创建一个新的套接字，通信结束后回收</em>*</p><p>$newsock &#x3D; accept(caddress,caddresslen)$</p><p>c address$\rightarrow$按照socket地址结构描述的<strong>客户端IP地址</strong></p></li><li><p><code>Send</code>函数 <strong>&#x2F;&#x2F; 客户和服务器使用这个函数来发送消息</strong></p><p>$send(socket,data,length,flags)$ </p><p>data $\rightarrow$ 内存待发数据的地址    length $\rightarrow$ 数据字节数    flags $\rightarrow$ 特殊选项(用来调试系统)</p><p>$sendto(socket,data,length,flags,destaddress,addresslen)$ <strong>&#x2F;&#x2F;无连接使用sendto函数</strong></p><p>$sendmgs(socket,mgsstruct,flags)$ 作用和sendto类似</p></li><li><p><code>Recv</code>函数 <strong>&#x2F;&#x2F; 客户和服务器从套接字接收数据</strong></p><p>$recv(socket,buffer,length,flags)$</p><p>buffer $\rightarrow$ 内存中收到数据的地址    length $\rightarrow$ 缓冲区大小    flags$\rightarrow$特殊选项</p><p>$recvfrom(socket,buffer,length,flags,sndraddr,saddrlen)$ <strong>&#x2F;&#x2F;无连接使用recvfrom函数</strong></p><p>$recvmgs(socket,mgsstrucct,flags)$ 作用和recvfrom类似 <strong>sendmgs和recvmgs是原函数的简化参数版本</strong></p></li><li><p>其他</p><ol><li>$write(socket,buffer,length) &#x2F; read(socket,buffer,length)$ Unix的I&#x2F;O一般操作 在连接之后和send-recv一样</li><li>$getpeername$ <strong>&#x2F;&#x2F;调用accept接收连接请求后调用这个函数获取客户端地址</strong></li><li>$gethostname$ <strong>&#x2F;&#x2F;调用这个函数获取本机的完整信息，可以是域名，也可能是其他</strong></li><li>$ gethostbyname$ <strong>&#x2F;&#x2F;知道域名时 调用这个函数获取本机IP地址</strong></li><li>$getprotobyname$ <strong>&#x2F;&#x2F;知道域名时 调用这个函数获取 socket使用的二进制形式IP地址</strong></li><li>$gethostbyaddr$ <strong>&#x2F;&#x2F;知道IP地址，获取域名     这两个函数在API中完成IP地址和域名的转换</strong></li></ol></li></ol><p>备注：</p><ol><li><code>Accept</code>确认连接地址之后 需要创建一个新的socket (可以根据C&#x2F;S模式理解成，服务器创建新线程)，只要连接建立，原来的套接字就会用来和下一个客户进行连接。</li><li>服务器可以并发，服务器创建并发线程时套接字也会产生一个副本，这样就实现了并发线程都能调用所有的套接字功能</li><li><code>Listen</code>和 <code>Accept</code>函数是<em><strong>面向连接通信时</strong></em>服务器必须进行的调用</li></ol><h3 id="套接字API与C-x2F-S"><a href="#套接字API与C-x2F-S" class="headerlink" title="套接字API与C&#x2F;S"></a>套接字API与C&#x2F;S</h3><p>刚刚的程序每次收到请求都会打印一段信息(建立连接)。 </p><p>可以注意的是 <em><strong>客户端不需要 socket和端地址联编</strong></em> 因为客户端的端口号可以是临时指定的(端地址也就相当于是可变的)，如果客户端需要向服务器发送报文，那另说。</p><hr><blockquote><p><strong>API是否由TCP&#x2F;IP所定义，目前互联网最常用的API体系是什么。</strong></p><p>不是。API是宏观的概念，而网络中使用的API主要分为Socket API(它由Berkeley UNIX定义)和TLI ，其中Socket API被主流的操作系统使用，所以Socket API是互联网最常用的API体系。</p></blockquote><blockquote><p><strong>API接口与协议端口、插口有什么区别？</strong></p><p>在网络中使用的API，指的是应用程序和TCP&#x2F;IP协议通信交互的接口，它是经过抽象后定义的一组(函数)操作，由操作系统来调用它。API使得应用进程和TCP&#x2F;IP(运输层)实现透明。</p><p>协议端口是TCP&#x2F;UDP给每种服务定义的标识，在进程进行交互时协助对接。协议端口使得两端的操作系统都能识别身份和服务。</p></blockquote><blockquote><p><strong>服务器套接字API有哪些专门的函数（过程）；对一个面向连接的TCP通信，服务器端套接字API的实现要经过那些过程调用？</strong></p><ol><li>socket    bind    listen    accept    connect    close    send(sendto)    recv(recvfrom)    getpeername    gethostname    gethostbyname    getprotobyname    gethostbyaddr等</li><li>对于面向连接 服务器端API的实现要经过<ol><li>getprotobyname 获取IP地址</li><li>Socket 建立套接字</li><li>bind (socket和端口号联编)</li><li>listen 套接字设置为被动模式，等待连接请求</li><li>accept 确定客户端的地址，确认连接，并且返回一个新创建的套接字 </li><li>send&amp;recv 发送和接收数据</li><li>close 关闭连接 回收套接字</li></ol></li></ol></blockquote><blockquote><p><strong>对一个非连接通信，客户端套接字为什么不必和本地端地址绑定？</strong></p><p>因为客户端的端口号可以是临时指定的(端地址也就相当于是可变的)，这个端地址仅仅具有本地的意义，由于端地址已经可以在本地唯一的标识进程，即使不绑定套接字OS和TCP&#x2F;IP也都能通过端地址来找到应用进程。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>互联网原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>因特网路由与协议</title>
    <link href="/2021/01/04/%E5%9B%A0%E7%89%B9%E7%BD%91%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%8D%8F%E8%AE%AE/"/>
    <url>/2021/01/04/%E5%9B%A0%E7%89%B9%E7%BD%91%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="因特网路由与协议"><a href="#因特网路由与协议" class="headerlink" title="因特网路由与协议"></a>因特网路由与协议</h1><p>RIP BGP位于应用层</p><h5 id="3个概念：路由选择-路由协议-路由算法"><a href="#3个概念：路由选择-路由协议-路由算法" class="headerlink" title="3个概念：路由选择 路由协议 路由算法"></a>3个概念：路由选择 路由协议 路由算法</h5><p><strong>路由选择</strong>$\rightarrow$通过互连网络从源节点向目的节点传输信息的通道，且中间至少有一个中间节点</p><p><strong>路由协议</strong>$\rightarrow$路由指导IP数据报发送过程中事先约定好的规定和标准(规定了IP数据报在网络中存储和转发的方式)</p><p>​    <em>路由协议决定了路由选择，而路由算法是路由协议的实现。</em></p><p>​    <em>在一个Autonomous System内的路由协议被称为Interior Gateway Protocol</em></p><p>​    <em>而AS之间的路由协议则是Exterior Gateway Protocol</em></p><p>​    <em>内部网关协议：RIP IGRP EIGRP IS-IS OSPF</em></p><p>​    <em>外部网关协议：EGP BGP</em></p><p><strong>路由算法</strong>$\rightarrow$提高路由协议的功能，尽量减少路由时带来的开销的算法</p><h2 id="分层的路由选择协议"><a href="#分层的路由选择协议" class="headerlink" title="分层的路由选择协议"></a>分层的路由选择协议</h2><p>实际上的Internet是由各个组织的自治域系统AS(Autonomous System)网络互连而成。</p><p>而作用在AS内部的 被称为内部网关协议IGP(RIP,OSPF)，外部的则称为外部网关协议EGP(BGP)</p><hr><h5 id="目前主要使用自适应-分布式协议，对于理想的路由协议-如何实现"><a href="#目前主要使用自适应-分布式协议，对于理想的路由协议-如何实现" class="headerlink" title="目前主要使用自适应 分布式协议，对于理想的路由协议 如何实现?"></a>目前主要使用自适应 分布式协议，对于理想的路由协议 如何实现?</h5><blockquote><p>正确性+完整性$\rightarrow$沿着路由表 肯定能到达所有主机</p><p>简洁性+合理性$\rightarrow$是保证时延最小 占有系统资源少 同时要求算法技术复杂性尽可能低</p><p>健壮性+可靠性$\rightarrow$根据结点故障，拥塞情况等进行动态的调整</p><p>稳定性$\rightarrow$网络结构稳定时避免路由表不断变化</p><p>公平性$\rightarrow$除非紧急，否则所有用户数据报进行一样的处理</p></blockquote><h2 id="内部网关协议RIP"><a href="#内部网关协议RIP" class="headerlink" title="内部网关协议RIP"></a>内部网关协议RIP</h2><h5 id="RIP简介"><a href="#RIP简介" class="headerlink" title="RIP简介"></a>RIP简介</h5><p>路由信息协议Router Information Protocol 是最早的广泛应用的分布式路由选择协议 </p><p>是比较简单的内部网关协议Interior Gateway Protocol</p><p>包括了RIP-1和RIP-2 其中2是1的扩充版</p><h5 id="最大的特点：好消息传的快-坏消息传的慢"><a href="#最大的特点：好消息传的快-坏消息传的慢" class="headerlink" title="最大的特点：好消息传的快 坏消息传的慢"></a>最大的特点：好消息传的快 坏消息传的慢</h5><blockquote><p>它的设计基于距离矢量算法(Distance-Vector)，使用Hop Count(跳数)来度量和目的网络之间的距离</p><p>与设备直连时跳数为0，这个度量值等于到达目的网络间的设备数量。</p></blockquote><p>&#x3D;&#x3D;为了限制收敛时间，RIP规定度量值取0～15之间的整数 大于等于16目的网络不可达 <strong>这也直接使得RIP不可能应用在大型网络里</strong>&#x3D;&#x3D;</p><blockquote><p>ps: 什么是路由收敛，什么是收敛时间</p></blockquote><p><strong><u>路由收敛 $\rightarrow$ 所有路由器对当前的网络结构和路由转发达成一致的状态</u></strong></p><p><strong><u>收敛时间 $\rightarrow$ 从网络拓扑发生变化，到所有相关路由器都得知这个变化并作出相应改变所需要的时间</u></strong></p><h5 id="RIP如何工作"><a href="#RIP如何工作" class="headerlink" title="RIP如何工作"></a>RIP如何工作</h5><blockquote><p>路由器A只和邻居路由器交换信息(同一网段所有路由器的接口)，采用主动发送 被动接收的方式</p><p>RIP交换的信息是路由器当前所知的全部信息(路由表主体)</p><p>每<strong>30s</strong>完成一次信息交换，更新各自路由器的路由表 &#x3D;&#x3D;在更新时，RIPv1总是广播更新，而v2是组播更新&#x3D;&#x3D;</p><p>(具体的情况就是 在第一次交换之前 路由器只有直连网络的信息，在几次交换之后，会得到整个自治域的最短距离信息) 在几次交换之后，就能实现每次转发距离最小。</p></blockquote><h5 id="形成RIP路由表"><a href="#形成RIP路由表" class="headerlink" title="形成RIP路由表"></a>形成RIP路由表</h5><ul><li>RouterA启动了RIP协议，向相邻路由器广播一个Request报文</li><li>RouterB是A的邻居，受到Request报文后将自己的<strong>整个路由表</strong>封装在Response报文里，向接口对应的网络广播</li><li>RouterA根据B的报文形成自己的路由表</li></ul><h5 id="与RIPv1相比，RIPv2的不同"><a href="#与RIPv1相比，RIPv2的不同" class="headerlink" title="与RIPv1相比，RIPv2的不同"></a>与RIPv1相比，RIPv2的不同</h5><ol><li>v1是有类路由协议，v2是无类路由协议</li><li>v1不支持VLSM v2支持</li><li>v1没有认证功能，v2有明文和MD5认证</li><li>v1没有手工汇总，必须自动；v2可以关闭自动汇总</li><li><strong>V1总是广播更新，v2组播更新</strong></li><li>v1没有路由标记 不能过滤和实施策略</li><li>v1发送的updata包没有next-hop属性，这个属性可以用来进行路由更新的重定</li><li>使用v1的路由器可以接收v2的报文，而使用v2的则不能接收v1的报文</li></ol><h5 id="RIP协议-如何出现环路？"><a href="#RIP协议-如何出现环路？" class="headerlink" title="RIP协议 如何出现环路？"></a>RIP协议 如何出现环路？</h5><p>在如下的网段里，R1和C直连 跳数为1 R2到C跳数则为2</p><p>现在C网段出现故障 R1到C距离为16 不可达</p><p><code>R1</code>准备在下一个30秒内告诉<code>R2</code>这个坏消息，但是<code>R2</code>先把自己的所有信息都告诉了<code>R1</code>,<code>R1</code>一看咦？<code>R2</code>到<code>C</code>的跳数是2，我到<code>R2</code>就一跳，现在虽然我不能直接到<code>C</code>了，那么绕道<code>R2</code>不就可以了吗？说干就干，于是把自己到<code>C</code>的跳数改为<code>3</code>.好了，真相被谎言掩盖了。</p><p><code>R1</code>向<code>R2</code>这个坦白所有的信息，<code>R2</code>看到<code>R1</code>到<code>C</code>的距离变为3了，<code>R2</code>知道自己是经过<code>R1</code>才到达的<code>C</code>，于是毫不犹豫的改为4.下一次再把全部信息告诉<code>R1</code>,<code>R1</code>收到一看，咋回事啊，怎么又加一跳了呢！<code>R2</code>那边发生了什么？但是还是得根据规则，毫不犹豫的修改到C的距离跳数。<strong>就这样不断增加，直到都为16</strong>，才恍然大悟，原来大家都到不了了啊。</p><hr><h2 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h2><h5 id="OSPF简介"><a href="#OSPF简介" class="headerlink" title="OSPF简介"></a>OSPF简介</h5><p>Open Shortest Path First 开放最短路径优先协议 是为了克服RIP的缺陷而设计的。</p><p>属于典型链路状态(link-state)协议。在区域内的所有路由器维护共同的链路状态数据库。</p><p>维护的数据包括    链路标号    两端连接路由器    链路度量(距离 费用 带宽 时延)</p><p><em><strong>可以用在较大的网络中 但路由协议和算法比较复杂</strong></em></p><blockquote><p>AS 被OSPF划分成若干个区域，每个区域路由器数量不超过200个，并由32位区域标识符描述。</p><p>在某个区域的所有路由器，只需要知道本区域的网络拓扑结构即可。这使得OSPF协议的效率比较高</p></blockquote><p>AS被划分成 Backbone Area(主干区域,0.0.0.0) 和Area，主干区域路由器就是主干路由器，区域之间设置区域边界路由器，这个路由器和主干路由器连接。</p><h5 id="OSPF工作原理"><a href="#OSPF工作原理" class="headerlink" title="OSPF工作原理"></a>OSPF工作原理</h5><blockquote><p>在区域中使用flooding(泛洪法)，由路由器所有输出接口向相邻路由器发送某个特定链路状态信息(我所知的相邻路由器的链路状态)，再由相邻路由器向其他地方转发(不会发回来) 注意：转发的是人家的包？</p><p>经过信息交换，区域中的每个路由器都保存了所有路由链路状态信息 据此组成相同链路状态数据库(LSDB)</p><p>在进行数据报的路由选择时，可以通过链路状态计算得到最短路径，并且通过链路度量，能更加灵活的处理</p><p>链路发生变化时，OSPF才使用泛洪法发送变化的信息</p></blockquote><p>分层区域设置 让交换路由信息的种类增加。随着层次增加，OSPF会逐渐变的更加复杂 但在更强大的设备加持下，OSPF能够有效的管理大规模的网络</p><p>网络按照层次结构设计时大规模网络普遍采用的设计原则。一般分为接入层、汇聚层(边缘层)、核心层；同样的设备在不同的层次时所完成的工作也是不同的。</p><h5 id="OSPF路由算法"><a href="#OSPF路由算法" class="headerlink" title="OSPF路由算法"></a>OSPF路由算法</h5><p>在建立链路状态数据库后 路由器相当于拥有了网络拓扑的完整信息，根据网络拓扑构建网络最短路径树，路由器就能建立自己的***<u>隐式路由表</u>***(只供自己使用)</p><blockquote><p>根据本区域的 链路状态数据库 计算到本区域的各个网络路由</p><p>根据本AS的 链路状态数据库 计算到AS中其他区域各个网络路由。</p><p>​    主干路由器根据到区域边界路由器(ABR)距离,和ABR到区内网络的距离综合选择路由</p><p>根据到AS域边界路由器+AS边界路由器到外部目的网络的距离，计算选择的路由</p></blockquote><p>OSPF可以根据IP首部的TOS(Type Of Service服务类型)对不同的链路设置代价(1-65535) 根据链路带宽 时延来计算</p><p>如果有多个相同代价的路由，还可以作多路径间多负载均衡，支持VLSM和CIDR 健壮性、稳定性、服务质量都不错。</p><h5 id="OSPF和RIP的区别"><a href="#OSPF和RIP的区别" class="headerlink" title="OSPF和RIP的区别"></a>OSPF和RIP的区别</h5><p>RIP只关注最短路径(这个路径还是只看跳数决定的)和下一跳路由器；而OSPF则能进行链路状态计算，还有链路度量机制</p><p>RIP在进行信息交换时不是转发人家发来的包，而是根据他的人包更新，然后发送自己的包(OSPF是转发)</p><p>RIP的信息交换是定时的！而OSPF则是检测到链路变化时才发送。</p><p>OSPF虽然有着更好的服务效果，但对计算能力的要求比较高</p><p><em><strong>对于距离矢量路由协议来说交换的是路由表，每个路由器的路由表都是照搬其他人的包，并不需要计算</strong></em></p><p><em><strong>而链路状态路由协议交换链路状态</strong></em></p><h2 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h2><h5 id="BGP简介"><a href="#BGP简介" class="headerlink" title="BGP简介"></a>BGP简介</h5><p>自治域间的路由选择由外部网关协议负责。    早期出现的EGP(外部网关协议)已经不再使用</p><p>Border Gateway Protocol(version 4)占有重要地位 所有的 AS都需要通过BGP-4获取彼此路由信息。</p><h5 id="在域间路由选择时面临的问题"><a href="#在域间路由选择时面临的问题" class="headerlink" title="在域间路由选择时面临的问题"></a>在域间路由选择时面临的问题</h5><blockquote><p>可扩展性 ：</p><p>域间路由器必须能转发Internet里所有可能的地址的分组。需要的路由表必须提供任何合法的IP地址分配</p><p>适应 域的自治特性：</p><p>每个自治域被允许使用自己的内部路由协议，选择一条穿越多个AS的路径的最优化是无意义的</p><p>对自治域的信任问题</p><p>在路由信息交互时，各个ISP提供的路由选择信息是否存在错误？以及域间路由的灵活策略(如一个多连接的ISP可制定通往AS1与AS3的策略 存在信任问题)</p></blockquote><h5 id="BGP的工作原理"><a href="#BGP的工作原理" class="headerlink" title="BGP的工作原理"></a>BGP的工作原理</h5><p>&#x3D;&#x3D;<em><strong>首要目标是 找到任何一条 无环的 通往预定目的地的路径(可达优先，没必要最优)</strong></em>&#x3D;&#x3D;</p><p>其处理特点是：</p><p><em><strong>能够进行路由优选 避免路由环路 更高效传递路由和维护大量路由信息</strong></em></p><p>跨越多跳路由器建立邻居关系(基于TCP协议) 在BGP路由里携带丰富的属性值</p><ol><li>自治域间路由，系统层次：自治域外提供路由信息，也就是边界路由器，一个AS设置一个发言人和其他AS交换信息</li><li>政策性约束，管理员可以配置BGP对某些路径不提供中转的策略，即使它知道如何到达目的地址</li><li>中转路由设施，当一个自治域同意某个业务流通过本系统转送到另外一个AS时，BGP会作为Transit System。当有一个以上的其他AS连接 但拒绝中转通信的AS称为Multihomed AS，只和一个AS连接 只传输本地业务流称为Stub System(桩AS)</li><li>可靠传输，BGP使用TCP通信。</li></ol><hr><blockquote><p>路由器中路由协议和路由算法各自完成什么作用？</p></blockquote><p>​    路由协议规定和指导IP数据报在网络中的存储转发方式。路由算法则需要提高路由协议的功能(工作效率),尽量减少路由时产生的开销，并且尽可能做到快速收敛。</p><p>路由协议完成路由信息动态交换，并以此建立路由表；路由算法是根据转发IP包的目的地址，依据路由表计算出最优转发路径和端口。</p><blockquote><p>什么是跳数？RIP协议为什么将最大跳数设为16？</p></blockquote><p>​    跳数(Hop Count)，从源端口到目的端口所经过的路由设备个数</p><p>​    为了限制收敛时间。在网络中有一个设备出现故障时，与其直连的设备知道网络不可达，但在更新之前如果其他不知情的路由设备向故障网段发送报文，就会出现误解的情况从而出现环路，两个设备到故障网段的跳数不断增加直到达到16时才能确认不可达。</p><blockquote><p>RIP协议工作的基本思想，主要问题在那里？</p></blockquote><p>​    1.只和相邻路由器交换信息 采取主动发送 被动接收到方式</p><p>​    2.每30s一次交换，每次都交换整个路由表</p><p>主要的问题：</p><div class="code-wrapper"><pre><code class="hljs">1. 规定最多16跳，所有路由器持有全部路由信息，不能用在大型网络上2. 只根据跳数来判断传输效率，不考虑链路带宽和延时等等其他因素3. 发生故障时，收敛速度慢4. 无法考虑多链路的负载均衡机制5. 不能识别服务等级和类型</code></pre></div><blockquote><p>目前网络路由协议主要考虑的哪些要素？</p></blockquote><p>见<code>理想路由协议如何实现</code></p><blockquote><p>简述互联网为什么要定义自治域AS，解释为什么要分层路由。</p></blockquote><p>定义自治域AS：全球有很多的公司和组织需要接入互联网，但根据其业务或条件的不同，其内部拓扑有着很大区别，并且其网络构成细节也希望不对外界公开，所以引入AS的概念来让不同的互联网实体可以无障碍沟通的同时保留自己的完整性。</p><p>分层路由：实际上的互联网是由各个AS互连而成，而由于业务等等因素的区别，每个AS的内部拓扑和使用的协议不一定相同，因此进行分层的路由，在AS内部使用IGP，只需要考虑内部的拓扑结构，而AS之间使用BGP也可以无视不同AS内部的差异。</p><blockquote><p>RIP与OSPF协议主要特点，各自处理的自治域规模一般多大？</p></blockquote><p>RIP是基于距离矢量算法设计，只考虑跳数，所以路由选择没有考虑到链路的带宽和延时，引入不可超过16跳来避免环路也让其只能用于早期的 小型的互联网。但其的算法思路简单，对路由设备算力的要求低于OSPF协议。</p><p>OSPF则属于典型链路状态协议。在区域内的所有路由器维护共同的链路状态数据库，能够考虑到各种链路因素。自治域在OSPF中被划分成了若干个区域(每区域不超过200个路由器)，这使得OSPF不仅效率高，而且也能用在较大规模的自治域中。但随着层次的增加，OSPF协议会变的更加复杂，所以对设备的配置有一定要求。</p><p>RIP只能用在小型的自治域中(如果自治域中任意两个端点的最短距离大于等于16就不能再使用RIP协议了)</p><p>OSPF可以用在大规模的自治域中。</p><blockquote><p>简单说明IGP和EGP协议主要区别。</p></blockquote><p>IGP(Interior Gateway Protocol)用在自治域的内部，用来在AS内部交换路由信息。</p><p>EGP(Exterior Gateway Protocol)用于连接不同的自治域，通过策略和过滤来控制路由信息在不同AS间的传播。</p><blockquote><p>简述自治域划分与因特网主干网、区域ISP和用户接入网的关系。</p></blockquote><p>因特网主干网作为一个自治域和多个其他主干网互连，区域ISP则可以直接接入因特网主干网，而用户接入网则作为ISP的客户接入ISP，通过ISP来访问主干网。</p><blockquote><p>BGP协议是否一定能提供最佳路径，为什么？</p></blockquote><p>我认为不是。虽然BGP协议能路由优选 避免路由环路 更高效传递路由和维护大量路由信息。但首要目标是找到任何一条无环的通往预定目的地的路径(可达性为最优先)</p><blockquote><p>简述因特网的实际结构和特点，中国因特网可能的基本组成结构是？</p></blockquote><p>​    因特网实际上是由各个组织的自治域系统AS网络互连而成，并非平面结构而是层次结构。由核心层 分布层 接入层构成。主干网，城域网(ISP)和用户网(LAN)组成了其层次结构。</p><p>组成成分：</p><ol><li>网根结构是多个主干网(AS)互连</li><li>大公司和ISP直接与一个或者多个主干网连接</li><li>小公司和个人用户作为ISP的客户接入ISP</li></ol><blockquote><p>RIP为什么称为距离向量协议？</p></blockquote><p>基于距离矢量算法设计</p><blockquote><p>路由协议有什么作用？</p></blockquote><p>路由指导数据报转送方式，是传输过程中事先约定好的规定和标准</p><blockquote><p>什么是自治域？举两个例子。</p></blockquote><p>一个自治系统（Autonomous System，AS）是一组路由器的集合，它们拥有同样的选路策略、被同一技术管理部门管理运行。  </p><blockquote><p>因特网中的路由器任何配置？</p></blockquote><blockquote><p>OSPF协议交换什么信息，路径最优含义？</p></blockquote><p>交换的是链路状态信息，包括接口上的IP地址 子网码 网络类型 代价 区域</p><p>开放最短路径优先，构建一颗最短路径优先树。</p>]]></content>
    
    
    
    <tags>
      
      <tag>互联网原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NAT</title>
    <link href="/2021/01/03/NAT%E4%B8%8EDHCP/"/>
    <url>/2021/01/03/NAT%E4%B8%8EDHCP/</url>
    
    <content type="html"><![CDATA[<h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><p>对于TCP&#x2F;IP的每一层， 有些是协议 有些是技术。</p><p>宏观来看，IPv4的地址空间不够用，导致了大量的问题</p><blockquote><p>IPv6 (128bits)</p><p>NAT &#x2F; Network Address Translation</p><p>VLSM 可变长 subnet mask</p><p>CIDR 无类域间路由</p></blockquote><h3 id="NAT-简介"><a href="#NAT-简介" class="headerlink" title="NAT 简介"></a>NAT 简介</h3><p>Network Address Translation 发明于1994年</p><p>其思路是 <strong>内网域内使用私有的IP地址空间</strong> 10网段 172.16网段 192.168网段</p><blockquote><p>10.0.0.0—10.255.255.255 A<br>172.16.0.0—172.31.255.255 B<br>192.168.0.0—192.168.255.255 C</p></blockquote><p>私有IP只在局域网里使用 互联网上不会出现这些ip</p><p>NAT的普及程度 $\rightarrow$ 70%的P2P用户位于NAT网关以内 由于P2P主要运行在PC上，这意味着大部分的PC都是通过NAT网关连接到Internet</p><ul><li>NAT技术没有公认的发明者</li></ul><h3 id="NAT工作模型"><a href="#NAT工作模型" class="headerlink" title="NAT工作模型"></a>NAT工作模型</h3><p>&#x3D;&#x3D;NAT 通常被部署在一个局域网的网络出口位置 通过**<u><em>将内部网络IP地址 替换成出口的IP地址</em></u><strong>提供</strong>公网可达性<strong>和</strong>上层协议连接能力**&#x3D;&#x3D;</p><p>&#x3D;&#x3D;目的$\rightarrow$提供一种虚拟的寻址机制&#x3D;&#x3D;</p><p>正常情况下 使用私有IP地址不需要向IANA提出申请 但是这些地址 不能作为源地址和目的地址</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul><li>在组织的出口部署 NAT gateway  其功能是：<ul><li>报文离开局域网进入Internet时 将源地址替换成公网地址(一般是出口设备的interface地址)</li><li>对访问目标来说，访问源地址自然就是NAT gateway，target会回复给NAT gateway</li><li>收到回复后 NAT gateway再把目的地址<strong>替换成私有IP地址</strong></li></ul></li><li>显然 对通信的双方来说 NAT gateway是<strong>透明</strong>的 数量庞大的内网主机 也不需要公有的IP地址了</li></ul><h4 id="注意⚠️"><a href="#注意⚠️" class="headerlink" title="注意⚠️"></a>注意⚠️</h4><ol><li><p>外网 一般无法通过IP地址访问内网主机 想要访问有两种方法</p></li><li><blockquote><p>一个全局地址 可以让不同PC同时访问<em><strong>不同</strong></em>服务器吗？$\rightarrow$ 可以 离开站点前的私有IP地址映射不一样</p><p><strong>一个全局地址 可以让不同PC同时访问<em>相同</em>服务器吗？$\rightarrow$ 不可以 因为在NAT Gateway收到服务器传回的报文时 不知道是哪个PC发送的(这个报文的源地址是服务器 目的地址是NAT Gateway的IP地址)</strong></p></blockquote></li><li><p>为实现双方的持续交流，NAT gateway需要维护一张关联表 $\rightarrow$ 地址转换表(translation table) 存储重写地址时所需的信息来实现地址转换 具体实现方法：</p><ul><li>当数据报离开站点 NAT将目的地址和发送方的私有地址记录在一起。</li><li>当数据报到达站点 NAT查询translation table 来确认哪台站内计算机接收这个相应。</li></ul></li><li><p>全局地址数量M一般远小于主机数 一个一般对应4000个内部地址</p><ul><li>内网轮流使用NAT地址池里的全局地址 当NAT地址池的全局地址被用完时 主机对外部的因特网访问将必须等待</li></ul></li><li><p>NAT gateway对交流双方是透明的</p></li></ol><h3 id="NAPT-网络地址与端口转换"><a href="#NAPT-网络地址与端口转换" class="headerlink" title="NAPT 网络地址与端口转换"></a>NAPT 网络地址与端口转换</h3><p>与NAT的区别在于 NAT是一对一转换 而NAPT则在转换时把端口号也作为参数 实现多对一转换</p><p>用于以下的两种情况 解决了 收到应答不知道给谁的问题。</p><blockquote><p>内网里两台不同主机 要同一时间 访问同一个服务器 </p><p>内网里 一台主机的 多个不同进程 要同时访问同一个服务器</p></blockquote><p>生成一个本地的端口号(临时生成 只用来区分不同主机或进程)</p><h5 id="NAPT的负载均衡器功能"><a href="#NAPT的负载均衡器功能" class="headerlink" title="NAPT的负载均衡器功能"></a>NAPT的负载均衡器功能</h5><p>外到内网服务器的访问 表的静态记录项 通过服务端口区分不同服务器的访问</p><p>接受外部主机的请求时 NAT根据已有的NAPT表 把全局地址翻译成不同内部地址 建立与多部主机的连接。根据NAPT表 转发数据包到多个内部服务器 实现服务器负载均衡(访问的是单个服务器 多个一起处理) 或不同服务器的访问</p><h5 id="外部通过NAT的访问内网-NART表项动态建立"><a href="#外部通过NAT的访问内网-NART表项动态建立" class="headerlink" title="外部通过NAT的访问内网 NART表项动态建立"></a>外部通过NAT的访问内网 NART表项动态建立</h5><p>如果是一般主机非固定的服务器，由于NAPT表中一般主机和NAT公有地址只是内到外访问时临时建立的，即NAPT表无法自动构建转换映射表，所以外部访问一般无法根据IP地址访问内网主机。一种方法通过域名访问，即建立内网域名DNS（二级域名）和NAT联用机制，由DNS触发建立NAT表的一个记录项。这时NAPT动态建立对应表项，IP地址利用率更高</p><h3 id="NAT的优缺点"><a href="#NAT的优缺点" class="headerlink" title="NAT的优缺点"></a>NAT的优缺点</h3><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><blockquote><p>节约Internet地址</p><p>解决相同IP地址的负载扩展(均衡)</p><p>消除重新编址 (现有方案能继续使用)</p></blockquote><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><blockquote><p>延迟增加</p><p>降低地址的 Traceability</p><p>某些应用功能交互更加复杂或失效(FTP TCP要解决NAT穿越问题 而要求特定的源端口和源地址的应用无法工作)</p></blockquote><hr><h1 id="因特网系统初始化设置-BOOTP-amp-DHCP"><a href="#因特网系统初始化设置-BOOTP-amp-DHCP" class="headerlink" title="因特网系统初始化设置 BOOTP &amp; DHCP"></a>因特网系统初始化设置 BOOTP &amp; DHCP</h1><ul><li>TCP&#x2F;IP 协议参数和配置 需要参数：<ul><li>硬件地址</li><li>使用协议类型</li><li>IP地址</li><li>默认IP路由器地址(下一跳地址)</li><li>地址掩码(地址类型)</li><li>DNS服务器地址</li></ul></li></ul><h5 id="协议配置-：-协议软件被-协议通用性原则-约束。-需要协议软件参数化，所以要在编译之前对参数赋值"><a href="#协议配置-：-协议软件被-协议通用性原则-约束。-需要协议软件参数化，所以要在编译之前对参数赋值" class="headerlink" title="协议配置 ： 协议软件被 协议通用性原则 约束。 需要协议软件参数化，所以要在编译之前对参数赋值"></a>协议配置 ： 协议软件被 协议通用性原则 约束。 需要协议软件参数化，所以要在编译之前对参数赋值</h5><p>如何配置协议？ <em><u><strong>在不知道IP地址情况下交流的核心思路$\rightarrow$使用广播</strong></u></em></p><blockquote><p>人工配置 手动录入(仍然是常用的方法)</p><p>存储文件配置 打开配置文件进行配置(因为系统只在启动时读取配置文件 所以修改参数配置需要重启)</p><p>自动协议配置 只要出现大量设备或者频繁修改 前两种几乎都行不通</p></blockquote><h5 id="自动协议配置方法"><a href="#自动协议配置方法" class="headerlink" title="自动协议配置方法"></a>自动协议配置方法</h5><p>要克服单机分散配置问题 在<strong>服务器端进行集中配置</strong> 然后通过请求&#x2F;应答形式 当计算机启动入网前发出请求 网络服务器返回适当配置响应</p><ol><li>配置协议前 使用RARP 用MAC多播(主要使用RARP的是无盘工作站 存储不了自己的IP地址 MAC地址在网卡上)</li><li>此时不知道默认网关 使用ICMP 掩码请求&#x2F;网关发现 用IP广播方式获取路由器参数(获取地址掩码&#x2F;默认网关地址)<ul><li><strong>地址屏蔽码</strong>(掩码)请求&#x2F;应答Address Mask Request&#x2F; Reply:主机启动时，会广播一个地址屏蔽码请求报文。服务器或路由器收到地址屏蔽码请求报文后，回送一个<strong>包含本网使用的32位地址屏蔽码</strong>的应答报文。</li></ul></li></ol><p><em>总的来说 协议从底层到高层进行配置 通过底层广播协议&#x2F;单播的方式逐步获得高层参数信息。</em></p><h5 id="自举的过程如下"><a href="#自举的过程如下" class="headerlink" title="自举的过程如下"></a>自举的过程如下</h5><blockquote><p>MAC 广播RARP request 获取IP地址</p><p>等待RARP reply 如果T1时间内无响应 返回1</p><p>广播ICMP地址掩码请求 获取IP地址掩码</p><p>等待回复 如果T2时间无响应 返回3</p><p>利用ICMP网关发现 找到默然路由器的IP地址 并将其加入路由表中</p></blockquote><p>可以注意到 需要至少3次分散的协议过程 会出现分散 延时 报文不同</p><h3 id="自举协议BOOTP-Bootstrap-Protocol"><a href="#自举协议BOOTP-Bootstrap-Protocol" class="headerlink" title="自举协议BOOTP(Bootstrap Protocol)"></a>自举协议BOOTP(Bootstrap Protocol)</h3><p>Bootstrap $\rightarrow$ pull or drag oneself by one’s own </p><h5 id="功能：一次广播一个BOOTP协议请求包-BOOTP服务器查找各项信息返回"><a href="#功能：一次广播一个BOOTP协议请求包-BOOTP服务器查找各项信息返回" class="headerlink" title="功能：一次广播一个BOOTP协议请求包 BOOTP服务器查找各项信息返回"></a>功能：一次广播一个BOOTP协议请求包 BOOTP服务器查找各项信息返回</h5><p><strong>注意： BOOTP协议由于尚未配置参数 所以进行了特殊的地址定义 IP广播地址全1 作为目的地址 全0作为源地址</strong></p><p><strong>BOOTP服务器可使用MAC地址进行单播(此时工作站还不知道自己的IP地址 所以IP单播无效) 或者全1广播地址回送 自举协议使用UDP发送(68&#x2F;67 端口)</strong></p><h5 id="自举协议的报文格式"><a href="#自举协议的报文格式" class="headerlink" title="自举协议的报文格式"></a>自举协议的报文格式</h5><h5 id="BOOTP的局限性"><a href="#BOOTP的局限性" class="headerlink" title="BOOTP的局限性"></a>BOOTP的局限性</h5><blockquote><p>在工作前 需要对BOOTP服务器上配置相关主机参数数据库 且是固定设置值。只能满足&#x3D;&#x3D;小区域固定IP配置&#x3D;&#x3D;和&#x3D;&#x3D;PC的静态接入网络&#x3D;&#x3D;需求。在大区域或不固定IP配置的情况下 很难实现。</p></blockquote><h3 id="DHCP-x2F-Dynamic-Host-Configuration-Protocol"><a href="#DHCP-x2F-Dynamic-Host-Configuration-Protocol" class="headerlink" title="DHCP&#x2F;Dynamic Host Configuration Protocol"></a>DHCP&#x2F;Dynamic Host Configuration Protocol</h3><p>1997年 IETF设计了动态主机配置协议 这个协议是在BOOTP基础上的扩展改进 </p><p><strong>DHCP的最大特点就是 可以自动获取IP地址分配(不固定)机制，也就是即插即用的联网</strong></p><blockquote><p>仍然使用IP广播地址全1作为目的地址 全0作为源地址 </p><p>DHCP服务器也可使用MAC地址进行单播 或者全1广播地址回送 (和BOOTP是一样的端口)</p><p>不同的是 如果有数据库中该主机的指定信息(这和BOOTP一致)就取出返回 <strong>如果没有(新增)从IP地址缓冲池动态选择一个IP地址分配给主机</strong></p></blockquote><h5 id="IP租借：由于DHCP是一个IP地址按需分配的-不固定机制-DHCP需要地址租期的概念。产生的地址在过了有效期-1s-136years-后就会被回收。"><a href="#IP租借：由于DHCP是一个IP地址按需分配的-不固定机制-DHCP需要地址租期的概念。产生的地址在过了有效期-1s-136years-后就会被回收。" class="headerlink" title="IP租借：由于DHCP是一个IP地址按需分配的 不固定机制 DHCP需要地址租期的概念。产生的地址在过了有效期(1s-136years)后就会被回收。"></a>IP租借：由于DHCP是一个IP地址按需分配的 不固定机制 DHCP需要地址租期的概念。产生的地址在过了有效期(1s-136years)后就会被回收。</h5><ul><li>DHCP通过IP地址缓冲池和租借IP按需分配的形式 形成对移动计算机入网的动态配置信息，不需要管理员对配置数据库进行任何修改。</li></ul><h5 id="DHCP优化"><a href="#DHCP优化" class="headerlink" title="DHCP优化"></a>DHCP优化</h5><blockquote><p>使用DHCP的主机首先随机广播发送 DHCP发现报文(短报) 减少冲撞的概率，在确认DHCP服务器后再发送请求报文。DHCP服务器地址通常会被永久保存，以后会单播(类似我们的记住已经连接过的WIFI密码)</p></blockquote><h5 id="DHCP中继"><a href="#DHCP中继" class="headerlink" title="DHCP中继"></a>DHCP中继</h5><blockquote><p>不是每个网络都需要DHCP服务器 设置一个DHCP中继 可以代理转发DHCP服务器的请求和响应(一般的路由器都有此功能)</p></blockquote><h5 id="DHCP使用和DHCP报文"><a href="#DHCP使用和DHCP报文" class="headerlink" title="DHCP使用和DHCP报文"></a>DHCP使用和DHCP报文</h5><blockquote><p>属性配置选择 $\rightarrow$ 固定IP地址&#x2F; 自动获取IP地址(选择这个就是使用DHCP)</p><p>DHCP报文和BOOTP差不多 添加了一个 FLAGS选项 让用户说明希望服务器使用广播应答还是直接应答</p></blockquote><p>由于DHCP和DNS系统不关联 对有域名计算机来说 IP地址和DNS域名的映射在从DHCP中自动获取新的IP后，计算机名字将会失效</p><hr><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="请简述自举配置协议BOOTP要解决什么问题？"><a href="#请简述自举配置协议BOOTP要解决什么问题？" class="headerlink" title="请简述自举配置协议BOOTP要解决什么问题？"></a><em><strong>请简述自举配置协议BOOTP要解决什么问题？</strong></em></h4><p>​    BOOTP用于解决在自动配置协议时 需要发送多次不同协议报文带来的分散、时延等麻烦。通过广播 一次发送一个BOOTP请求包，由BOOTP服务器查找各项信息返回。</p><p><strong>标准答案：</strong></p><p><strong>第1发现协议地址，实际上我们还是可以通过RARP形式，在未知环境中获取本机参数；</strong></p><p><strong>第2获取配置服务器参数，实际上采用ICMP的掩码请求形式，以IP广播的方法请求获取</strong></p><h4 id="请简述DHCP-协议在BOOTP基础上主要改进了什么？。"><a href="#请简述DHCP-协议在BOOTP基础上主要改进了什么？。" class="headerlink" title="请简述DHCP 协议在BOOTP基础上主要改进了什么？。"></a><em><strong>请简述DHCP 协议在BOOTP基础上主要改进了什么？。</strong></em></h4><p>​    DHCP可以自动获取IP地址分配(不固定)机制，也就是即插即用的联网。和BOOTP不同的地方在于，如果服务器数据库中没有发出请求的主机信息，DHCP能从IP地址缓冲池里动态选择一个IP地址分配给主机(在租期过后则回收这个地址)。</p><h4 id="请列出在使用BOOTP协议前，一台计算机在利用网络启动之前，必须在本地需要具有什么协议与参数。"><a href="#请列出在使用BOOTP协议前，一台计算机在利用网络启动之前，必须在本地需要具有什么协议与参数。" class="headerlink" title="请列出在使用BOOTP协议前，一台计算机在利用网络启动之前，必须在本地需要具有什么协议与参数。"></a><em><strong>请列出在使用BOOTP协议前，一台计算机在利用网络启动之前，必须在本地需要具有什么协议与参数。</strong></em></h4><p>​    1.需要知道自己的MAC地址(硬件类型)</p><p>​    2.需要支持RARP协议(能进行MAC广播)</p><p>​    3.需要支持ICMP协议(用于获取地址掩码和找到默认路由)</p><p>​    4.需要支持UDP协议(用于发送BOOTP数据包)</p><h4 id="比较使用绑定方案地址分配协议和DHCP动态地址分配协议，哪个更适用于广域网？"><a href="#比较使用绑定方案地址分配协议和DHCP动态地址分配协议，哪个更适用于广域网？" class="headerlink" title="比较使用绑定方案地址分配协议和DHCP动态地址分配协议，哪个更适用于广域网？"></a><em><strong>比较使用绑定方案地址分配协议和DHCP动态地址分配协议，哪个更适用于广域网？</strong></em></h4><p>​    我认为DHCP动态地址分配协议更适合广域网。广域网区域大，而且用户变化大，静态的地址分配方案无法满足大量用户的需求，使用DHCP可以满足大量用户动态接入网络的需求，同时还能提高地址的利用率(不是每台主机都一直工作，如果静态分配会产生大量闲置时间)。与此同时，DHCP优化还可以减少发广播的次数。不管是从效率还是从可行性上看，都应该选择DHCP动态地址分配协议。</p>]]></content>
    
    
    
    <tags>
      
      <tag>互联网原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mass Media &amp; VoIP</title>
    <link href="/2020/12/08/%E5%A4%9A%E5%AA%92%E4%BD%93-&amp;-IP%E7%94%B5%E8%AF%9D(VoIP)/"/>
    <url>/2020/12/08/%E5%A4%9A%E5%AA%92%E4%BD%93-&amp;-IP%E7%94%B5%E8%AF%9D(VoIP)/</url>
    
    <content type="html"><![CDATA[<h1 id="多媒体-amp-IP电话-VoIP"><a href="#多媒体-amp-IP电话-VoIP" class="headerlink" title="多媒体 &amp; IP电话(VoIP)"></a>多媒体 &amp; IP电话(VoIP)</h1><h2 id="互联网中的实时业务"><a href="#互联网中的实时业务" class="headerlink" title="互联网中的实时业务"></a>互联网中的实时业务</h2><ul><li>多媒体「multimedia」 一般用来指含有音频&#x2F;视频的数据，当然也适用于文本</li></ul><p>这类信号在数字化后如果按照因特网传输数据的方式到达接收方，<strong>并实时的展示出来</strong> 其结果是难以接受的</p><p>我们知道 音视频信号的传播过程 包括 抽样、编码(D&#x3D;&gt;S)、网络传输、解码</p><p>而因特网存在的 丢包 和 乱序问题</p><p>丢包 $\Rightarrow$ 抽样值丢失</p><p>乱序 $\Rightarrow$ 抽样值时延不一致！这会造成以下我们所说的 <code>抖动</code></p><ul><li><h4 id="网络吞吐率T-单位时间内-有效传输的-比特-x2F-字节数「与带宽、速率的区别在于-它们俩用来表示某条链路-而不是整个网络」"><a href="#网络吞吐率T-单位时间内-有效传输的-比特-x2F-字节数「与带宽、速率的区别在于-它们俩用来表示某条链路-而不是整个网络」" class="headerlink" title="网络吞吐率T 单位时间内 有效传输的 比特&#x2F;字节数「与带宽、速率的区别在于 它们俩用来表示某条链路 而不是整个网络」"></a>网络吞吐率T 单位时间内 有效传输的 比特&#x2F;字节数「与带宽、速率的区别在于 它们俩用来表示某条链路 而不是整个网络」</h4></li><li><h4 id="网络时延D-一个分组-通过网络需要的时间"><a href="#网络时延D-一个分组-通过网络需要的时间" class="headerlink" title="网络时延D 一个分组 通过网络需要的时间"></a>网络时延D 一个分组 通过网络需要的时间</h4></li></ul><p>处理实时业务时碰到的最大困难， 不是分组丢失 而是 <strong><code>抖动「jitter」</code></strong> 这意味着「**<code>与常规的传输协议不同，传输实时数据的协议 只需要处理抖动问题，而不需要重传丢失的分组</code>**」</p><p><em><u>抖动的定义：「信号的某特定时刻相对于其理想时间位置上的短期偏离」</u></em> 相当于“跳ping、很小的延迟变化”</p><p>因特网无法要求底层的网络具有处理实时业务的功能 所以解决方案有两个</p><ol><li><h4 id="设计等时延、无抖动的网络-PSTN-TDM电路"><a href="#设计等时延、无抖动的网络-PSTN-TDM电路" class="headerlink" title="设计等时延、无抖动的网络(PSTN\TDM电路)"></a>设计等时延、无抖动的网络(PSTN\TDM电路)</h4></li><li><h4 id="设计抖动补偿协议-实现平滑重放「playback」-这又包含了两种主要的模式"><a href="#设计抖动补偿协议-实现平滑重放「playback」-这又包含了两种主要的模式" class="headerlink" title="设计抖动补偿协议 实现平滑重放「playback」 这又包含了两种主要的模式"></a>设计抖动补偿协议 实现<em><strong>平滑重放「playback」</strong></em> 这又包含了两种主要的模式</h4><ol><li><h5 id="时间戳「timestamp」-每个小片提供一个时间戳，接收方按照时间戳重放"><a href="#时间戳「timestamp」-每个小片提供一个时间戳，接收方按照时间戳重放" class="headerlink" title="时间戳「timestamp」 每个小片提供一个时间戳，接收方按照时间戳重放"></a>时间戳「timestamp」 每个小片提供一个时间戳，接收方按照时间戳重放</h5></li><li><h5 id="抖动缓冲「jitter-buffer」缓冲收到的数据、然后推迟重放"><a href="#抖动缓冲「jitter-buffer」缓冲收到的数据、然后推迟重放" class="headerlink" title="抖动缓冲「jitter buffer」缓冲收到的数据、然后推迟重放"></a>抖动缓冲「jitter buffer」缓冲收到的数据、然后推迟重放</h5></li></ol><p>实现抖动缓冲 我们只需要维护一个cache然后延迟d个时间单位，虽然分组到达的时间略有不同，但总会在d时间之内到达，我们均匀的输出分组，就没有关系了</p></li></ol><ul><li>想要实现流式传输有两种方法 ： 实时流式传输「RTS」 和 顺序流式传输</li><li>新世纪以来，流式存储下载的局限性越来越明显，而顺序流式传输「progressive streaming」成为主流</li></ul><h2 id="实时传输协议RTP「Real-time-Transport-Protocol」"><a href="#实时传输协议RTP「Real-time-Transport-Protocol」" class="headerlink" title="实时传输协议RTP「Real-time Transport Protocol」"></a>实时传输协议RTP「Real-time Transport Protocol」</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p>来自应用层｜支持单播&#x2F;多播｜提供时间信息+实现流同步｜<strong>通常使用UDP 也可在TCP&#x2F;ATM等协议上工作</strong></p><p><strong>RTP &#x3D; RTP数据协议+RTP控制协议</strong></p><h3 id="RTP的架构如下："><a href="#RTP的架构如下：" class="headerlink" title="RTP的架构如下："></a>RTP的架构如下：</h3><ul><li>version｜P: 载荷是否为0填充｜X：是否有扩展头部 ｜ M：特殊帧标志</li><li><strong>CC「CSRC计数」：即有多少个源(媒体流被按照规则封装成一个个源)</strong><ul><li>一个多媒体文件中， 视频、音频、字幕···会来自不同的轨道 它们被封装成不同的源 然后在接收端混合输出</li></ul></li><li><strong>PT：载荷的编码特性「包括 编码算法 采样频率 承载通道」 用来指示接收端如何解码</strong></li><li><strong>序列号</strong> 每个数据分组有一个16位的序列号，每次自加1。类似TCP序列号， 用来检测<strong>是否丢包</strong> 序列号初始值是随机的 因为要防范对加密数据的攻击</li><li><strong>时间戳(时标)</strong> 32位 反映RTP数据包中第一个数据的 <strong>采样时刻</strong> 初始时间戳是随机选择的，而随后从单调且线性增加的时钟导出，以解决同步与抖动计算。 时间戳的单位不是固定的s&#x2F;ms 而是根据载荷类型确定</li></ul><blockquote><p>序列号与时间戳 是完全独立的</p><p>因为分组顺序 和 时间顺序 并不是线性相关的</p><p>「⚠️ 意思不只是 每个分组和分组到达的时间不是线性相关。 问题的关键在于 信号是数字化(离散)的，而时间戳会随着时间一直累加，而如果信号进入了空白帧，那么分组可以进入缓变状态(等到有数据了 再发送这个分组)」</p></blockquote><ul><li><strong>CSRC列表：接收端会对多个源的数据进行混合输出 以此列表作为参照</strong> </li><li>SSRC：标识多个源进行同步。 不是随机选择，每个RTP包里的每个同步源(需要同步播放)都有不同的SSRC标识</li></ul><h2 id="RTCP协议「Real-time-Transport-Control-Protocol」它和RTP是连体婴儿-不可分割"><a href="#RTCP协议「Real-time-Transport-Control-Protocol」它和RTP是连体婴儿-不可分割" class="headerlink" title="RTCP协议「Real-time Transport Control Protocol」它和RTP是连体婴儿 不可分割"></a>RTCP协议「Real-time Transport Control Protocol」它和RTP是连体婴儿 不可分割</h2><p><strong>不对实际音视频数据进行封装，是控制短分组协议</strong></p><h3 id="RTCP的任务："><a href="#RTCP的任务：" class="headerlink" title="RTCP的任务："></a>RTCP的任务：</h3><ul><li>服务质量监控和反馈<ul><li>接收端会多播发送丢包率、抖动···，发送端会多播发送 分组数、时间戳、绝对时间</li></ul></li><li>多源媒体之间的标识和同步</li></ul><h2 id="IP电话-IP-telephony-x2F-IP语音-Voice-over-IP-x2F-VoIP"><a href="#IP电话-IP-telephony-x2F-IP语音-Voice-over-IP-x2F-VoIP" class="headerlink" title="IP电话(IP telephony)&#x2F;IP语音(Voice over IP&#x2F; VoIP)"></a>IP电话(IP telephony)&#x2F;IP语音(Voice over IP&#x2F; VoIP)</h2><p>使用IP路由器取代传统电话交换机的动机很简单：💰</p><p>而且由于底层的网络设施共享，只要有了基本的设备就可以实现IP通话</p><p>IP电话的应用所面对的最大挑战就是 设计者希望IP电话能和已有的公共电话交换网络PSTN(Public Switched Telephone Network)兼容(向后兼容)，它们需要实现双向可通话。</p><h2 id="信令与VoIP标准"><a href="#信令与VoIP标准" class="headerlink" title="信令与VoIP标准"></a>信令与VoIP标准</h2><p>目前有两个组织为IP电话制定了标准：</p><p>国际电信联盟International Telecommunications Union 制定电话标准</p><p>因特网工程任务组Internet Engineering Task Force&#x2F; IETF 制定TCP&#x2F;IP标准</p><h3 id="IP电话的基础技术"><a href="#IP电话的基础技术" class="headerlink" title="IP电话的基础技术"></a>IP电话的基础技术</h3><ul><li>音频采用脉冲编码调制(PCM&#x2F; Pulse Code Modulation) 编码</li><li>数字化音频使用 RTP进行传输</li></ul><h3 id="IP电话的主要复杂之处在于-呼叫建立和呼叫管理-而我们把「建立和终止呼叫的过程-称为-信令-signaling-」"><a href="#IP电话的主要复杂之处在于-呼叫建立和呼叫管理-而我们把「建立和终止呼叫的过程-称为-信令-signaling-」" class="headerlink" title="IP电话的主要复杂之处在于 呼叫建立和呼叫管理  而我们把「建立和终止呼叫的过程 称为 信令(signaling)」"></a>IP电话的主要复杂之处在于 呼叫建立和呼叫管理  而我们把「建立和终止呼叫的过程 称为 信令(signaling)」</h3><p>电话中处理呼叫管理所采用的机制 就是<code>信令系统</code></p><p>为了和已有的电话系统兼容，我们需要和SS7(Signaling System 7)兼容 IETF剔除了 会话初启协议「Session Initiation Protocol，SIP」   </p><p><code>SDP（Session Description Protocol）是一个用来描述多媒体会话的应用层控制协议，它是一个基于文本的协议，用于会话建立过程中的媒体类型和编码方案的协商等</code></p><p><code>H.323 ITU定义的IP电话信令协议</code></p><h3 id="IP电话质量控制"><a href="#IP电话质量控制" class="headerlink" title="IP电话质量控制"></a>IP电话质量控制</h3><p>要求：</p><ul><li>使用光纤网络+特殊补偿算法 可以容忍最多30%的丢包率</li><li>电话通信端到端延时要求 &lt; 250ms。</li></ul><h2 id="SIP协议「Session-Initialization-Protocol」"><a href="#SIP协议「Session-Initialization-Protocol」" class="headerlink" title="SIP协议「Session Initialization Protocol」"></a>SIP协议「Session Initialization Protocol」</h2><p><code>用以一个或多个用户的会话建立、更改、管理、终止。不能单独完成多媒体通信的呼叫。</code></p><p>STP和SDP+RTP&#x2F;RTCP一起配合 组建完整的多媒体通信系统</p><h3 id="SIP功能："><a href="#SIP功能：" class="headerlink" title="SIP功能："></a>SIP功能：</h3><p>•用户定位：确定参加通信的终端用户位置。</p><p>•用户通信能力协商：确定通信的媒体类型和参 数。</p><p>•用户交互意愿：确定被叫加入通信的意愿。</p><p>•呼叫建立：建立主叫和被叫的会话参数。</p><p>•呼叫处理和控制：包括呼叫重定向、呼叫转移 ，终止呼叫等。</p><h3 id="SIP特点"><a href="#SIP特点" class="headerlink" title="SIP特点"></a>SIP特点</h3><ul><li>通过代理和重定向请求用户当前位置以支持用户移动性</li><li>独立于传输层协议，可以承载在不同的传输协议上 并扩展方便</li><li>只建立 更改 终止一个会话，和会话内容无关，这意味着其载体可以是任意的(甚至可以是视频和游戏)</li></ul><h3 id="SIP在网络中的主要实体："><a href="#SIP在网络中的主要实体：" class="headerlink" title="SIP在网络中的主要实体："></a>SIP在网络中的主要实体：</h3><ul><li><p>用户代理（ User Agent ）：用来发起或接收请求 的逻辑实体设备（如 IP 电话机、计算机、媒体网关等）。</p></li><li><p>用户代理客户 UAC （ User Agent Client ）：发 起请求的一方（如 SIP Phone ）；</p></li><li><p>用户代理服务器 UAS （ User Agent Server ）： 接收 请求，产生响应的一方。</p></li><li><p>定位 服务器（ Location Server ）：管理提供被 叫的位置数据库 , 如每个用户的 IP 地址集合（ IP 地址、电话号码、 email 地址）、用户订购业务 、用户偏好等，在呼叫过程中提供被叫用户的位 置信息</p></li><li><p>支持服务器（ Support Server ）：代理服务器、 重定向服务器、注册服务器，实际呼叫过程扩展 应用。 </p></li><li><p>代理服务器：作为一个实体转发用户代理客户 UAC 的请求至被叫（用户代理服务器 UAS ）或 一个代理服务器。</p></li><li><p>注册服务器：接收注册请求 , 将注册请求中的地 址映射关系更新到定位数据库中，并负责验证注 册请求和确保底层数据库一致性。</p></li><li><p>重定向服务器：为所收到的请求返回一个或多个 新的地址，用户代理客户 UAC 再向这些新的地址 发起请求。重定向服务器并不接收呼叫或拒绝呼 叫，主要完成路由重新定向，与注册过程配合可 以支持 SIP 终端的移动性</p></li></ul><h3 id="SIP协议消息类型"><a href="#SIP协议消息类型" class="headerlink" title="SIP协议消息类型"></a>SIP协议消息类型</h3><p>SIP分为请求和响应</p><hr><blockquote><p> <strong>试列举3-5种网络中可能产生的时延，什么是等时时延或非等时时延？</strong></p><p>可能的时延有 信号传播时延、信号处理时延、路由器存储转发时延、丢包重传时延、播放时延等。</p><p>等时时延&amp;非等时时延 ： </p><p>以信号传输为例 就是信号总在一段固定时间后到达，这其中的时延称为等时时延</p><p>如果每次传输信号会在不同的时间后到达，就将这段时延称为非等时时延</p></blockquote><blockquote><p><strong>在因特网丢包、乱序的状况下，分析比较对非实时email和实时IP电话所产生的影响？</strong></p><p>对于E-Mail来说，如果不使用可靠的传输协议，接收方很难收到正确、完整的信息。但由于其非实时性，借助SMTP等可靠传输协议实现差错检测和报文重传，客户发送的E-Mail几乎总能正确、完整的到达接收方处。</p><p>对于实时IP电话来说，由于音视频信号在网络上传输的特点，网络丢包、乱序导致网络抖动，使得还原出的信号产生失真。如果借助可靠传输，由于网络层丢包、乱序的状况，传输会不可避免的花费时间，会丧失实时性。如果实时传输并引入超时重传，在接收端已经收到并提取信息之后再把错误或丢失的数据包插播进来是毫无意义的。因此智能设计等时延、无抖动的网络结构 或者 设计补偿抖动的协议实现平滑重放。</p></blockquote><blockquote><p><strong>简述RTP协议中定义序列号、时标有什么作用？如何理解两者具有独立性。</strong></p><p>序列号 类似TCP序列号，用来检测是否丢包。</p><p>时间戳(时标) 反映RTP数据包中第一个数据的采样时刻，初始时间戳随机选择，随后则从单调、线性增加的时钟导出，以解决同步与抖动计算。</p><p>序列号所对应的是 分组顺序，时间戳对应的则是 时间顺序。两者之间不一定是线性相关的，因为信号的特点可能使得在一段时间内并无信号(数据帧)，或者出现可变长度视频编码(图像缓变)帧，而在这段时间内时间戳会一刻不停的累加。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>互联网原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about C++ numeric</title>
    <link href="/2020/12/05/about%20numeric%20%E5%BA%93/"/>
    <url>/2020/12/05/about%20numeric%20%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="c-numeric-库"><a href="#c-numeric-库" class="headerlink" title="c++ numeric 库"></a>c++ numeric 库</h1><p>accumulate 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">vector&lt;?&gt; a;<br><span class="hljs-built_in">accumulate</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), initValue);  <span class="hljs-comment">// 3参数累加时候的初始值 如果是字符串则是(string)&quot;&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SP edition 信息社会传奇</title>
    <link href="/2020/09/14/SP-edition-%E4%BF%A1%E6%81%AF%E7%A4%BE%E4%BC%9A%E4%BC%A0%E5%A5%87/"/>
    <url>/2020/09/14/SP-edition-%E4%BF%A1%E6%81%AF%E7%A4%BE%E4%BC%9A%E4%BC%A0%E5%A5%87/</url>
    
    <content type="html"><![CDATA[<h1 id="SP-edition-信息社会传奇"><a href="#SP-edition-信息社会传奇" class="headerlink" title="#SP edition 信息社会传奇"></a>#SP edition 信息社会传奇</h1><ul><li><strong>信息网络 能源 交通 是现代社会的三大基础</strong></li><li><strong>数据$\Rightarrow$  传输和存储的 可识别的数字符号</strong></li><li>信息交互 (一对一 一对多 多对多)<ul><li>有效性</li><li>安全性</li></ul></li><li><strong>计算机网络$\Rightarrow$ 将计算机或外部设备连接在一起，实现 <u>信息交互和应用服务</u>的设备 通信链路 通信规约和软件的集合</strong></li></ul><ul><li>因特网 $\Rightarrow$ 特指由美国创建和管理的全球互联网</li></ul><hr><h4 id="计算机网络发展-Web发展-x2F-快速发展期"><a href="#计算机网络发展-Web发展-x2F-快速发展期" class="headerlink" title="计算机网络发展(Web发展&#x2F;快速发展期)"></a>计算机网络发展(Web发展&#x2F;快速发展期)</h4><ul><li>Tim Berners-Lee 1989年提出了 Web， 1991年开通了第一个 WWW网站<a href="https://info.cern.ch/">https://info.cern.ch/</a>  1993年制定了全球信息浏览的Web规范</li><li>1994年8月11日 netMarket公司 建立了第一个电子商务网站并完成了全球第一笔网络零售交易</li><li>1995年 杰夫·贝佐斯创建了 Amazon</li><li>1994年4月20日 中国科学技术网成功和Internet连接(64k&#x2F;s)</li><li>1994年10月 Grand Juction公司推出第一套快速以太网</li><li>1995年3月 IEEE宣布了快速以太网标准 Fast Ethernet LAN进入100M时代</li><li>1997年6月 IEEE802.11标准出台 无线网络代替了有线网络实现高效 高速的联网方案 (WIFI)</li><li>1998～1999 高速以太网标准形成 </li><li>1998年9月7日 Google成立 &#x2F; qq出现</li><li>2001年 万兆以太网出现(有线)(用于组网核心 城域网)</li><li>2004年 Mark Zuckerberg 建立Facebook</li><li>2006年 Twitter出现</li><li>2007年6月29日 Steve Jobs的iPhone上市 移动互联网时代开启</li><li>2007年11月 Google发起的手机联盟推出Android 以Apache开源许可证的授权方式开放源代码</li></ul><hr><h4 id="计算机网络提供的服务"><a href="#计算机网络提供的服务" class="headerlink" title="计算机网络提供的服务"></a>计算机网络提供的服务</h4><p><strong><u>三大核心$\Rightarrow$应用 交互 管理</u></strong></p><ol><li>网络应用服务</li><li>具体联网和信息交互(解决不同速率 距离 成本需要的组网技术) 1973年 Vinton Cerf&#x2F;Robert Kahn指出不可能存在能满足所有需求的单一分组网络技术</li><li>大规模的组网和信息交互技术</li><li>网络辅助技术 解决网络运行时的问题</li></ol><hr><h4 id="计算机网络应用"><a href="#计算机网络应用" class="headerlink" title="计算机网络应用"></a>计算机网络应用</h4><p>互联网网络应用(服务) 建立在TCP&#x2F;IP协议之上的应用服务</p><p>连接 $\Rightarrow$ 联合</p><p>早期的Internet应用 Telnet(远程计算机访问) Email FTP(文件传送) Newsgroup(新闻组) BBS论坛</p><h5 id="应用的发展过程"><a href="#应用的发展过程" class="headerlink" title="应用的发展过程"></a>应用的发展过程</h5><p>E-mail FTP $\Rightarrow$ 静态网页 $\Rightarrow$ 动态网页 $\Rightarrow$ 网上营销 $\Rightarrow$ 电子商务 $\Rightarrow$ 移动应用服务</p><p>宏观来看 信息交互 $\Rightarrow$ 综合业务应用 多媒体应用 $\Rightarrow$ 物联网 云计算应用</p><h5 id="万维网-World-Wide-Web"><a href="#万维网-World-Wide-Web" class="headerlink" title="万维网 World Wide Web"></a>万维网 World Wide Web</h5><p>万维网起源于欧洲粒子物理研究中心CERN </p><p>核心创新： 广泛关联 文档定位 文档快速传输 多格式文档阅读</p><p>网页(超文本) 表达的不再是线性的信息 而是非线性 联想式 信息关联的信息网。 Web表示这种由超文本连接起来的信息网</p><p>网址 $\Rightarrow$ 统一资源定位符 URL (Uniform Resource Locator)</p><p><a href="http://www.baidu.com/view/25482.htm">http://www.baidu.com/view/25482.htm</a></p><p> $\Uparrow$                     $\Uparrow$                              $\Uparrow$</p><p>Protocol       Name of Computer    Index and File name</p><p>支持缺省输入(支持默认)</p><h6 id="指定URL后-如何传输？"><a href="#指定URL后-如何传输？" class="headerlink" title="指定URL后 如何传输？"></a>指定URL后 如何传输？</h6><p>浏览器按URL链接服务器 请求服务 $\Rightarrow$ 网页服务器应答 返回 $\Rightarrow$ 浏览器完成解析之后显示网页</p><p>使用超文本传输协议HTTP 让网站和浏览器协商进行网页传输</p><h6 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h6><p>基本功能 $\Rightarrow$ 输入选取URL时 向Web服务器发送请求 接收文档 进行解析和显示</p><hr><p>现代计算机网络创造了全新社会形态 </p>]]></content>
    
    
    
    <tags>
      
      <tag>互联网原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
