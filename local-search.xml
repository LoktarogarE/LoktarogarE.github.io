<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>A Brief Introduction to database</title>
    <link href="/2022/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93DB/"/>
    <url>/2022/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93DB/</url>
    
    <content type="html"><![CDATA[<p>第一章  数据库系统概述<br>1、四个概念：什么是数据?  什么是数据库? 什么是数据库管理系统（DBMS）？什么是数据库系统(DBS)？<br>2、熟记数据库系统的组成。<br>3、理解DBA是对数据库进行集中控制和管理的最重要人员。<br>4、实例和模式的对比（内容&#x2F;状态 vs 结构，变化 vs 稳定）<br>5、三级模式：物理模式（又称内模式、存储模式），逻辑模式（又称模式），和子模式（又称外模式）的含义是什么？一个数据库有几个物理模式，逻辑模式和子模式？ 三级模式间的两极映射，以及是由谁（DMBS）完成这种映射功能的？两级映射的作用（好处）是带来以下两种数据独立性——<br>6、两种数据独立性：什么是逻辑数据独立性？什么是物理数据独立性？用户或者应用程序面向的到底是哪一级数据库模式？<br>7、概念数据模型用于数据库设计，是对客观世界的第一层抽象。常见例子是E-R模型。</p><p>第二章 关系模型与关系运算<br>1、数据模型的三要素？关系模型的三要素？<br>2、关系的组成：什么是属性？什么是元组？什么是分量？ 度和基数。<br>3、理解关系有哪些性质？<br>4、理解关系的四种键及定义？数量（上限下限）？外部键的属性名可以和所对应的主键不同。外部键可以指向同一个关系的主键。例如：学生（学号，姓名，班长学号…）。外部键从E-R图的什么概念转化而来？<br>5、关系模式和关系实例的对比。<br>6、过程化和非过程化语言的区分和理解——看课件。<br>7、关系操作分为查询和更新操作。表示关系操作用某种查询语言：关系代数，关系演算（又分为元组关系演算和域关系演算）。关系代数是过程化的，关系演算是非过程化的。后面讲到的SQL是非过程化的。<br>8、掌握关系代数的各种运算（包括符号）。其中最基本的运算（不可替代）是哪些？<br>9、应用题型：用关系代数表达查询问题</p><p>第三章 关系数据库语言SQL<br>1、SQL的全名（中英文）。SQL是非过程化的语言。理解SQL的特点（基本功能特征）。<br>2、熟记SQL的四种功能。这些功能分别由哪些语句（动词）实现？<br>3、SQL对数据库三级模式的规定：每级模式由什么组成？<br>4、理解SQL中的系统数据类型，char&#x2F;varchar&#x2F;numeric等。<br>5、掌握SQL的各个数据定义语句（特别是新建表，建视图，修改表，删除表的语句）。<br>6、掌握SQL的Select数据查询语句。<br>7、掌握SQL的各个数据修改语句： Insert, Update, Delete。<br>8、空值的意义；掌握空值的运算规则（包括聚集函数忽略空值等），例如给出一个包含空值的式子，能计算最终结果。<br>9、理解视图的本质：命名的查询语句，只有这个才是真正存储在数据库里的；表象：虚拟表，与真正的表基本表相比有相同也有不同；动态变化）。<br>10、熟记视图的优点。<br>11、掌握定义视图的语句。理解对视图的查询以及对视图的更新系统在后台是怎样执行的（视图的查询：展开视图——替换视图为它所对应的查询。视图的修改：转化为对基本表的修改，这种转化可能因为缺少主键等原因失败，从而无法修改）。<br>12、嵌入式SQL不要求。<br>13、应用题型：用SQL表达数据查询(Select)和数据修改(Insert, Update, Delete)问题。用SQL建表(Create Table)，建视图(Create View)等数据定义操作。</p><p>第四章  关系数据库模式设计<br>1、熟记关系模式设计不当可能产生的四种问题：数据冗余和三种异常。<br>2、理解函数依赖的概念。三对特殊类型的函数依赖：平凡&#x2F;非平凡，部分&#x2F;完全，传递&#x2F;非传递。根据定义去理解和判定它们。<br>3、用函数依赖判断一个属性集是否超键，或者是否候选键的方法。<br>4、掌握计算属性集闭包的算法。以及由此判定一个函数依赖是否成立的方法。<br>5、掌握1NF、2NF、3NF、BCNF。并能够进行判定。<br>6、掌握规范化到1NF，3NF，BCNF的相关方法。关系模式应该至少规范化到3NF。规范化到3NF和规范化到BCNF相比，后者得到的关系模式属于更高级别，但是可能会丢失函数依赖。<br>7、应用题型：给出关系和函数依赖<br>a)寻找全部（可能不只一个）候选键，并给出判定证明。<br>b)判断某个函数依赖是否成立？<br>c)判断关系所属的最高范式，并给出证明。<br>d)将关系规范化到3NF，或者BCNF<br>e)判定一个分解（比如规范化后的结果）是否无损连接分解。</p><p>第五章 数据库设计<br>1、理解E-R模型的三要素：实体、属性和联系。以及在E-R图中的表示。<br>2、能判断二元联系的类型：一对一，一对多，多对多。以及在E-R图中的表示。<br>3、能将E-R图转化为关系模型。注意：多值属性的处理；1对1，1对多，多对1，多对多，三元以上联系各自的转化方式——不要张冠李戴。<br>4、熟记数据库设计的基本过程，包括在各个阶段分别要做的工作？<br>5、应用题型1：画E-R图（概念设计）。<br>6、应用题型2：将E-R图转化为关系模型（逻辑设计）。</p><p>第六章  数据库安全性与完整性<br>1、安全性是防止非法用户进入数据库，以及合法用户进入数据库后做了（未授权的）非法操作。完整性是防止非法数据进入数据库，即使是合法用户使用合法操作产生的。<br>2、掌握用SQL授予权限和回收、禁止权限的语句(grant, revoke, deny)。with grant option子句的作用。<br>3、理解常见权限的含义。（例如 insert on table S, update on view A等)<br>4、理解完整性的含义：正确、有效、相容。完整性约束（规则）是数据为保证完整性所必须满足的条件。<br>5、熟记关系模型中的三类完整性规则。各有什么要求？理解哪些（修改）操作会破坏这些规则？<br>6、掌握用SQL定义主键约束、外键约束、非空(not null)约束、唯一(unique)约束、域约束、检查(check)约束的语句？以及这些约束的含义、作用。<br>7、在定义外部键约束时，有哪几种参照动作？代表什么意义？<br>8、触发器是一种ECA规则，构成：Event事件，Condition条件，Action动作。触发器的事件主要有三类：INSERT,UPDATE,DELETE。</p><p>第七章 数据库事务管理。<br>1、深刻理解事务的概念。熟记事务的ACID性质（包括英文单词、解释、实现机制）。<br>2、掌握事务控制的多个SQL语句。两种结束方式（提交或回滚）的含义及区别。<br>3、熟记并发引起的三类数据不一致问题，它们是如何发生的（过程？）。产生不一致问题的根本原因是事务在并发执行（调度）时，没有保证隔离性。<br>4、并发执行（调度）的正确性准则：可串行化——效果等价于一个串行调度。<br>5、并发控制的任务：保证事务的并发执行（调度）是（尽量）正确的，避免不一致问题的产生。常见的一种实现方法是封锁。<br>6、封锁的基本类型：排他锁（写锁、X锁）、共享锁（读锁、S锁）。它们的相容关系？<br>7、有哪几种封锁协议？规则是什么？可分别解决哪些数据不一致性问题？两段封锁协议是可串行化调度的充分非必要条件。<br>8、数据库恢复技术的基本原理：冗余。建立冗余的两种方法：数据备份和登记日志文件。<br>9、静态备份 vs 动态备份（有否一致性；数据库是否可用，即是否允许用户运行事务来操作数据库）。完全备份 vs 增量备份（优缺点对比）。<br>10、日志文件：是用来记录事务对数据库进行修改操作的文件<br>11、日志文件的基本内容（事务开始一条；事务结束一条；事务若干次更新若干条）。在登记修改操作的日志记录时，修改前后的旧值与新值都要保存到日志记录中。<br>12、什么是运行记录优先（先写日志）原则？<br>13、熟记不同类型的数据库故障，包括它们的定义，故障的起因（例如死锁引起事务故障，停电引起系统故障，硬盘坏道引起介质故障等等…），影响范围（事务本身？DBMS系统？内存中的数据？磁盘上的数据？）、恢复策略（方法过程），每种故障类型的恢复过程，及由谁完成（系统自动 or 用户干预？）<br>14、理解检查点机制的原理（写检查点做了什么工作？按相对检查点的位置，把事务分成几类，哪些需要REDO&#x2F;UNDO，哪些不需要？）。检查点的作用（在恢复系统故障时，大大缩短需要扫描的日志文件的范围，这个范围是从哪里到哪里…）<br>15、熟记引入检查点后，系统故障的恢复过程，并与之前没有检查点时的恢复过程作对比。</p><hr><h3 id="Chapter1-数据库系统概论"><a href="#Chapter1-数据库系统概论" class="headerlink" title="Chapter1 数据库系统概论"></a>Chapter1 数据库系统概论</h3><ul><li><p>什么是数据：计算机能够处理的信息</p></li><li><p>DBS &#x3D; DB + DBMS + 计算机系统</p></li><li><h4 id="数据库的三级模式-amp-两级映像"><a href="#数据库的三级模式-amp-两级映像" class="headerlink" title="数据库的三级模式&amp;两级映像"></a>数据库的三级模式&amp;两级映像</h4><ul><li>Internal Scheme：物理模式。描述数据的物理结构&#x2F;存储方式。 由DBMS提供，每个数据库只有一种，通常不需要客户来关心如何实现。</li><li>Scheme：逻辑模式。所有用户的公共数据视图，描述数据的逻辑结构。<ul><li>这里需要了解DBMS中的三种语言：DD^Definition^L, DM^Manipulation^L, DC^Control^L</li><li>其中DML 控制增删查改， DCL负责数据完整性和安全性</li><li>DDL描述逻辑模式，定义数据的各类label</li><li>是<strong>全体数据</strong>的逻辑结构，一个数据库只有一个模式。</li></ul></li><li>External Scheme：是<strong>模式的子集或者某种变形</strong>,依用户&#x2F;应用的要求而定。<ul><li>每个数据库可以有很多个外模式</li></ul></li><li><strong>两级映像</strong> 实现了三种模式的转换，保证数据库系统的逻辑独立和物理独立性<ul><li>以外模式&#x2F;模式映像为例，简单来说，当<code>模式</code>改变时，只需要改变<code>映像</code>即可, 而不需要改变外模式， 从而保证了数据的逻辑独立性。</li><li>同理，如果内模式改变(比如用了更先进的数据结构)，只需要修改模式&#x2F;内模式映像，就可以让模式适应新的内模式。</li></ul></li></ul></li><li><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><ul><li>UML Unified Modeling Language:  分为功能模型，对象模型和动态模型。<ul><li>UML定义一个 面向对象的软件密集型系统的方法</li></ul></li><li>数据模型 &#x3D; 数据结构 + 数据操作 + 数据完整性约束<ul><li><strong>关系模型</strong>  是关系数据库采用的模型，很多其他模型是用图解来说明的，而关系模型则是使用 <strong>二维表格</strong>来表达实体和它们间的关系，也是我们接下来主要研究的模型，其应用是最广泛的。</li></ul></li><li>概念模型的几大概念：  概念模型用来描述概念和它们之间的关系<ul><li>属性 &#x3D;&gt; 实体的某一特性； 域 &#x3D;&gt; 属性的取值范围；码(key) &#x3D;&gt; 可以<strong>唯一</strong>标识一个实体的属性</li><li>E-R图表示概念模型 其中矩形为实体，椭圆为属性，菱形为联系，用无向边+菱形联系起两个实体，并在无向边上标识 1:1 或是1:n 或是m:n。 在每个实体的码下面划一条横线</li></ul></li></ul></li></ul><hr><h3 id="Chapter2-关系运算理论"><a href="#Chapter2-关系运算理论" class="headerlink" title="Chapter2 关系运算理论"></a>Chapter2 关系运算理论</h3><ul><li>不同域之间的笛卡尔积<ul><li>比如D1 {计算机系，日语系}； D2 {1班，2班}； D3 {张三，李四，王五}</li><li>三者相互组合，形如 <code>(计算机系，1班，张三)</code> 被我们看作一个<code>元组</code>(在实际的表格里，这就是一行), 3个域的笛卡尔积能形成 2 * 2 * 3共 12个元组，整个笛卡尔积则是 3(3个域) * 12(12个元组) 的表格。 <strong>应当注意的是，实际上的关系，则是取整个笛卡尔积中有效的部分</strong></li><li></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Computation tech</tag>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About Cloud Computing</title>
    <link href="/2022/03/11/About%20Cloud%20Computing/"/>
    <url>/2022/03/11/About%20Cloud%20Computing/</url>
    
    <content type="html"><![CDATA[<h1 id="About-Cloud-Computing"><a href="#About-Cloud-Computing" class="headerlink" title="About Cloud Computing"></a>About Cloud Computing</h1><p>​    <strong>什么是”云”</strong>：迁移至云端。在云中运行。在云中存储。从云端访问—-当今时代，似乎一切都在”云”中进行。但是，”云”究竟是一个什么样的概念？简单来说，<strong>云就是互联网连接的另一端</strong>，你可以从云端访问各种应用程序和服务，也可以在云端安全存储你的数据。”云”之所以如此强大，有以下三个原因：你不需要对”云”进行维护或管理；云端可以有效扩容至无限大，因此你无需担心云容量不够用；你可以随时随地访问基于云的各种应用程序和服务，而你只需要一台可以连接互联网的设备即可。借助云应用程序，你只需打开浏览器并登录，即可开始工作。</p><p>​    云是网络、互联网的一种比喻说法。过去在图中往往用云来表示电信网，后来也用来表示互联网和底层基础设施的抽象。因此，<a href="https://so.csdn.net/so/search?q=%E4%BA%91%E8%AE%A1%E7%AE%97&spm=1001.2101.3001.7020">云计算</a>甚至可以让你体验每秒10万亿次的运算能力，拥有这么强大的计算能力可以模拟核爆炸、预测气候变化和市场发展趋势。用户通过电脑、笔记本、手机等方式接入数据中心，按自己的需求进行运算。</p><p>​    <strong>云计算(Cloud Computing)的定义</strong>：</p><p>​    (1)、云计算是一种将可伸缩、弹性、共享的物理和虚拟资源池以按需自服务的方式供应和管理，并提供网络访问的模式。云计算模式由关键特征、云计算角色和活动、云能力类型和云服务分类、云部署模型、云计算共同关注点组成。</p><p>​    (2)、<strong>云计算是一种基于互联网的计算方式</strong>，通过这种方式，共享的软硬件资源和信息可以按需求提供给计算机各种终端和其它设备。</p><p>​    (3)、<strong>云计算是一种按使用量付费的模式</strong>，这种模式提供可用的、便捷的、按需的网络访问，进入可配置的计算资源共享池(资源包括网络，服务器，存储，应用软件，服务)，这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。</p><p>​    <strong>云计算是分布式计算(Distributed Computing)、并行计算(Parallel Computing)、效用计算(Utility Computing)、网络存储(Network Storage Technologies)、虚拟化(Virtualization)、负载均衡(Load Balance)、热备份冗余(High Available)等传统计算机和网络技术发展融合的产物</strong>。</p><p><strong>云计算的关键特征</strong>：</p><p>​    (1)、广泛的网络接入：可通过网络，采用标准机制访问物理和虚拟资源的特性。这里的标准机制有助于通过异构用户平台使用资源。这个关键特性强调云计算使用户更方便地访问物理和虚拟资源：用户可以从任何网络覆盖的地方，使用各种客户端设备，包括移动电话、平板、笔记本和工作站访问资源。</p><p>​    (2)、可测量的服务：通过可计量的服务交付使得服务使用情况可监控、控制、汇报和计费的特性。通过该特性，可优化并验证已交付的云服务。这个关键特性强调客户只需对使用的资源付费。从客户的角度看，云计算为用户带来了价值，将用户从低效率和低资产利用率的业务模式转变到高效率模式。</p><p>​    (3)、多租户：通过对物理或虚拟资源的分配保证多个租户以及他们的计算和数据彼此隔离和不可访问的特性。在典型的多租户环境下，组成租户的一组云服务用户同时也属于一个云服务客户组织。在某些情况下，尤其在公有云和社区云部署模型下，一组云服务用户由来自不同客户的用户组成。一个云服务客户组织和一个云服务提供者之间也可能存在多个不同的租赁关系。这些不同的租赁关系代表云服务客户组织内的不同小组。</p><p>​    (4)、按需自服务：云服务客户能根据需要自动，或通过与云服务提供者的最少交互，配置计算能力的特性。这个关键特性强调云计算为用户降低了时间成本和操作成本，因为该特性赋予了用户无需额外的人工交互，就能够在需要的时候做需要做的事情的能力。</p><p>​    (5)、快速的弹性和可扩展性：物理或虚拟资源能够快速、弹性，有时是自动化地供应，以达到快速增减资源目的的特性。对云服务客户来说，可供应的物理或虚拟资源无限多，可在任何时间购买任何数量的资源，购买量仅仅受服务协议的限制。这个关键特性强调云计算意味着用户无需再为资源量和容量规划担心。对客户来说，如果需要新资源，新资源就能立刻自动地获得。资源本身是无限的，资源的供应只受服务协议的限制。</p><p>​    (6)、资源池化：将云服务提供者的物理或虚拟资源进行集成，以便服务于一个或多个云服务客户的特性。这个关键特性强调云服务提供者既能支持多租户，又通过抽象对客户屏蔽了处理复杂性。对客户来说，他们仅仅知道服务在正常工作，但是他们通常并不知道资源是如何提供或分布的。资源池化将原本属于客户的部分工作，例如维护工作，移交给了提供者。需要指出的是，即使存在一定的抽象级别，用户仍然能够在某个更高的抽象级别指定资源位置。</p><p>​    <strong>云能力类型</strong>：是根据资源的使用情况，对为云服务客户提供的云服务的功能进行的分类。有三类不同的云能力类型：应用能力类型、基础设施能力类型和平台能力类型。这三类能力类型有不同的关注点，即相互之间的功能交叉最少。这些云能力类型不应与云服务类别混淆。</p><p>​    (1)、应用能力类型：云服务客户能使用云服务提供者的应用的一类云能力类型。</p><p>​    (2)、基础设施能力类型：云服务客户能配置和使用计算、存储和网络资源的一类云能力类型。</p><p>​    (3)、平台能力类型：云服务客户能使用云服务提供者支持的编程语言和执行环境，部署、管理和运行客户创建或客户获取的应用的一类云能力类型。</p><p>​     <strong>云服务类别</strong>：是拥有相同质量集的一组云服务。一种云服务类别可对应一种或多种云能力类型。典型的云服务类别包括：</p><p>​    (1)、通讯即服务(CaaS)：为云服务客户提供实时交互与协作能力的一种云服务类别。</p><p>​    (2)、计算即服务(CompaaS)：为云服务客户提供部署和运行软件所需的配置和使用计算资源能力的一种云服务类别。</p><p>​    (3)、数据存储即服务(DSaaS)：为云服务客户提供配置和使用数据存储相关能力的一种云服务类别。</p><p>​    (4)、基础设施即服务(Infrastructure as a Service, IaaS)：为云服务客户提供云能力类型中的基础设施能力类型的一种云服务类别。使用IaaS时，你以即用即付的方式从服务提供商处租用IT基础设施，如服务器和虚拟机(VM)、存储空间、网络和操作系统。IaaS的优点：无须自己投资硬件；可按需扩展基础设施规模，以便支持不断变化的工作负载；灵活、创新而且按需提供的服务。</p><p>​    (5)、网络即服务(NaaS)：为云服务客户提供传输连接和相关网络能力的一种云服务类别。</p><p>​    (6)、平台即服务(Platform as a Service, PaaS)：为云服务客户提供云能力类型中的平台能力类型的一种云服务类别。PaaS是指云计算服务，它们可以按需提供开发、测试、交付和管理软件应用程序所需的环境。PaaS旨在让开发人员能够更轻松地快速构建Web或移动应用，而无需考虑开发所必须的服务器、存储空间、网络和数据库基础设施进行设置或管理。PaaS的优点：开发应用，更快地打入市场；只需数分钟，就可以将新的Web应用程序部署到云中；使用中间件即服务，降低复杂性。</p><p>​    (7)、软件即服务(Software as a Service, SaaS)：为云服务客户提供云能力类型中的应用能力类型的一种云服务类别。在”软件即服务”的服务模式当中，用户能够访问服务软件及数据。服务提供者则维护基础设施及平台以维持服务正常运作。SaaS使得企业能够借由外包硬件、软件维护及支持服务给服务提供者来降低IT营运费用。另外，由于应用程序是集中供应的，更新可以即时的发布，无需用户手动更新或是安装新的软件。SaaS是通过Internet交付软件应用程序的方法，通常以订阅为基础按需提供。使用SaaS时，云提供商托管并管理软件应用程序和基础设施，并负责软件升级和安全修补等维护工作。用户(通常使用电话、平板电脑或PC上的Web浏览器)通过Internet连接到应用程序。SaaS的优点：你可以注册并快速开始使用创新的业务应用；在任何已连接的计算机上都可以访问应用和数据；如果你的计算机出现故障，数据也不会丢失，因为数据在云中；这种服务可以根据使用需要进行动态扩展。SaaS的缺陷在于用户的数据是存放在服务提供者的服务器之上，使得服务提供者有能力对这些数据进行未经授权的访问。</p><p>​    <strong>典型的云计算部署模式：</strong>云计算有四类典型的部署模式：”公有云”、”私有云”、”社区云”和”混合云”。具体描述如下：</p><p>​    (1)、公有云：云基础设施对公众或某个很大的业界群组提供云服务。公有云服务可通过网络及第三方服务供应者，开放给客户使用，”公有”一词并不一定代表”免费”，但也可能代表免费或相当廉价，公有云并不表示用户数据可供任何人查看，公有云供应者通常会对用户实施使用访问控制机制，公有云作为解决方案，既有弹性，又具备成本效益。公有云为第三方云服务提供商所拥有和运营，他们通过Internet提供其计算资源(如服务器和存储空间)。在公有云中，所有硬件、软件和其它支持性基础设施均为云提供商所拥有和管理。使用Web浏览器访问这些服务和管理你的账户。</p><p>​    (2)、私有云：云基础设施特定为某个组织运行服务，可以是该组织或某个第三方负责管理，可以是场内服务(on-premises)，也可以是场外服务(off-premises)。私有云具备许多公有云环境的优点，例如弹性、适合提供服务，两者差别在于私有云服务中，数据与程序皆在组织内管理，且与公有云服务不同，不会受到网络带宽、安全疑虑、法规限制影响；此外，私有云服务让供应者及用户更能掌控云基础架构、改善安全与弹性，因为用户与网络都受到特殊限制。私有云是指专供一个企业或组织使用的云计算资源。私有云可以实际位于公司的现场数据中心之上。某些公司还向第三方服务提供商付费托管其私有云。在私有云中，在专用网络上维护服务和基础设施。</p><p>​    (3)、社区云：云基础设施由若干个组织分享，以支持某个特定的社区。社区是指有共同诉求和追求的团体(例如使命、安全要求、政策或合规性考虑等)。和私有云类似，社区云可以是该组织或某个第三方负责管理，可以是场内服务，也可以是场外服务。社区云由众多利益相仿的组织掌控及使用，例如特定安全要求、共同宗旨等。社区成员共同使用云数据及应用程序。</p><p>​    (4)、混合云：云基础设施由两个或多个云(私有云、社区云或公有云)组成，独立存在，但是通过标准的或私有的技术绑定在一起，这些技术可促成数据和应用的可移植性(例如用于云之间负载分担的cloud bursting技术)。这个模式中，用户通常将非企业关键信息外包，并在公有云上处理，但同时掌控企业关键服务及数据。混合云通过允许在公有云和私有云之间共享数据和应用程序的技术将它们绑定到一起。通过允许数据和应用程序在私有云和公有云之间移动，混合云为企业提供更大的灵活性和更多的部署选项。</p><p>​    **云计算参考架构(Cloud Computing Reference Architecture，简称CCRA)**：CCRA从四个不同的视角描述了云计算：用户视角、功能视角、实现视角、部署视角。</p><p>​    (1)、用户视角涉及云计算活动，角色和子角色，参与方，云能力类型和云服务类别，云部署模型和共同关注点等云计算概念。其中，角色是一组具有相同目标的云计算活动的集合。其中云计算的角色包括：云服务客户，云服务提供者，云服务协作者。共同关注点指的是需要在不同角色之间协调，且在云计算系统中一致实现的行为或能力。共同关注点包含可审计性，可用性，治理，互操作性，维护和版本控制，性能，可移植性，隐私，法规，弹性，可复原性，安全，服务水平和服务水平协议等。</p><p>​    (2)、CCRA认为云计算功能架构用一组高层的功能组件来描述云计算。功能组件代表了为执行与云计算相关的各种角色和子角色的云计算活动的功能集合。功能架构通过分层框架来描述组件。在分层框架中，特定类型的功能被分组到各层中，相邻层次的组件之间通过接口交互。功能视图涵盖了功能组件，功能层和跨层功能等云计算概念。</p><p>​    (3)、CCRA的分层框架包括4 层，以及一个跨越各层的跨层功能集合。四层分别是：用户层、访问层、服务层、资源层。跨越各层的功能称为跨层功能。</p><p>​    <strong>云计算的7类主要支撑技术</strong>：</p><p>​    (1)、系统虚拟化：是指将一台物理计算机系统虚拟化为一台或多台虚拟计算机系统。每个虚拟计算机系统(简称虚拟机)都拥有自己的虚拟硬件(如CPU、内存和设备等)，来提供一个独立的虚拟机执行环境。通过虚拟化层的模拟，虚拟机中的操作系统认为自己仍然是独占一个系统在运行。每个虚拟机中的操作系统可以完全不同，并且它们的执行环境是完全独立的。这个虚拟化层被称为虚拟机监控器(Virtual Machine Monitor，简称VMM)。</p><p>​    虚拟机可以看作是物理机的一种高效隔离的复制。虚拟机具有三个典型特征：同质、高效和资源受控。同质指的是虚拟机运行环境和物理机环境在本质上需求是相同的，但是在表现上有一些差异。高效指的是虚拟机中运行的软件需要具有接近在物理机上直接运行的性能。资源受控指的是VMM需要对系统资源有完全控制能力和管理权限，包括资源的分配、监控和回收。</p><p>​    VMM对物理资源的虚拟可以归结为三个主要任务：CPU虚拟化、内存虚拟化和I&#x2F;O 虚拟化。CPU虚拟化是VMM中最核心的部分，决定了内存虚拟化和I&#x2F;O虚拟化的正确实现。CPU虚拟化包括指令的模拟、中断和异常的模拟及注入和对称多处理器技术的模拟。内存虚拟化一方面解决了VMM和客户机操作系统对物理内存认识上的差异，另一方面在虚拟机之间、虚拟机和VMM之间进行隔离，防止某个虚拟机内部的活动影响到其他的虚拟机甚至是VMM本身，从而造成安全上的漏洞。I&#x2F;O 虚拟化主要是为了满足多个客户机操作系统对外围设备的访问需求，通过访问截获、设备模拟和设备共享等方式复用外设。</p><p>​    按照VMM提供的虚拟平台类型可以将VMM分为两类：完全虚拟化和半虚拟化。完全虚拟化下，VMM虚拟的是现实存在的平台。在客户机操作系统看来，虚拟的平台和现实的平台是一样的，客户机操作系统觉察不到运行在一个虚拟平台上。这样的虚拟平台无需对现有的操作系统做任何修改。半虚拟化下，VMM虚拟的平台在现实中是不存在的。这样的虚拟平台需要对客户机操作系统进行修改使之适应虚拟环境。操作系统知道自己运行在虚拟平台上，并且会主动去适应。</p><p>​    当前主流的虚拟化技术实现结构可以分为三类：Hypervisor模型、宿主模型和混合模型。在Hypervisor模型中，VMM可以看作是一个扩充了虚拟化功能的操作系统，对底层硬件提供物理资源的管理功能，对上层的客户机操作系统提供虚拟环境的创建和管理功能。与Hypervisor不同，宿主模型中，VMM作为宿主操作系统独立的内核模块。物理资源由宿主机操作系统管理，VMM提供虚拟化管理。宿主模型和Hypervisor模型的优缺点恰好相反。宿主模型的最大优点是可以充分利用现有操作系统的设备驱动程序以及其它功能，缺点是虚拟化效率较低，安全性取决于宿主操作系统。而Hypervisor模型虚拟化效率高、安全，但是需要自行开发设备驱动和其它一些功能。混合模型集成了上述两类模型的优点。混合模型中，VMM让出大部分I&#x2F;O设备的控制权，将它们交由一个运行在特权虚拟机中的特权操作系统来控制。因此，混合模型下CPU和内存的虚拟化由VMM负责，而I&#x2F;O虚拟化由VMM和特权操作系统共同合作完成。</p><p>​    (2)、虚拟化资源管理：是云计算中最重要的组成部分之一，对虚拟化资源的管理水平直接影响云计算的可用性、可靠性和安全性。虚拟化资源管理主要包括对虚拟化资源的监控、分配和调度。</p><p>​    云资源池中应用的需求不断改变，在线服务的请求经常不可预测，这种动态的环境要求云计算的数据中心或计算中心能够对各类资源进行灵活、快速、动态的按需调度。云计算中的虚拟化资源与以往的网络资源相比，有以下特征：数量更为巨大；分布更为离散；调度更为频繁；安全性要求更高。</p><p>​    通过对虚拟化资源的特征分析以及目前网络资源管理的现状，确定虚拟化资源的管理应该满足以下准则：所有虚拟化资源都是可监控和可管理的；请求的参数是可监控的，监控结果可以被证实；通过网络标签可以对虚拟化资源进行分配和调度；资源能高效地按需提供服务；资源具有更高的安全性。</p><p>​    在虚拟化资源管理调度接口方面，表述性状态转移(Representational State Transfer，简称REST)有能力成为虚拟化资源管理强有力的支撑。REST实际上就是各种规范的集合，包括Http 协议、客户端&#x2F;服务器模式等。在原有规范的基础上增加新的规范，就会形成新的体系结构。而REST 正是这样一种体系结构，它结合了一系列的规范形成了一种新的基于Web的体系结构，使其更有能力来支撑云计算中虚拟化资源对管理的需求。</p><p>​    (3)、分布式数据存储：分布式数据存储技术包含非结构化数据存储和结构化数据存储。其中，非结构化数据存储主要采用文件存储和对象存储技术，而结构化数据存储主要采用分布式数据库技术，特别是NoSQL数据库。下面分别阐述这三方面的技术：</p><p>​    1)、分布式文件系统：为了存储和管理云计算中的海量数据，Google提出分布式文件系统GFS(Google File System)。GFS成为分布式文件系统的典型案例。Apache Hadoop项目的HDFS实现了GFS的开源版本。</p><p>​    Google GFS是一个大规模分布式文件存储系统，但是和传统分布式文件存储系统不同的是，GFS在设计之初就考虑到云计算环境的典型特点：结点由廉价不可靠PC构建，因而硬件失败是一种常态而非特例；数据规模很大，因而相应的文件I&#x2F;O单位要重新设计；大部分数据更新操作为数据追加，如何提高数据追加的性能成为性能优化的关键。相应的GFS在设计上有以下特点：</p><p>​    A、利用多副本自动复制技术，用软件的可靠性来弥补硬件可靠性的不足。</p><p>​    B、将元数据和用户数据分开，用单点或少量的元数据服务器进行元数据管理，大量的用户数据结点存储分块的用户数据，规模可以达到PB 级。</p><p>​    C、面向一次写多次读的数据处理应用，将存储与计算结合在一起，利用分布式文件系统中数据的位置相关性进行高效的并行计算。</p><p>​    GFS&#x2F;HDFS非常适于进行以大文件形式存储的海量数据的并行处理，但是，当文件系统的文件数量持续上升时，元数据服务器的可扩展性面临极限。以HDFS为例，只能支持千万级的文件数量，如果用于存储互联网应用的小文件则有困难。在这种应用场景面前，分布式对象存储系统更为有效。</p><p>​    2)、分布式对象存储系统：与分布式文件系统不同，分布式对象存储系统不包含树状名称空间(Namespace)，因此在数量增长时可以更有效地将元数据平衡地分布到多个结点上，提供理论上无限的可扩展性。</p><p>​    对象存储系统是传统的块设备的延伸，具有更高的”智能”：上层通过对象ID来访问对象，而不需要了解对象的具体空间分布情况。相对于分布式文件系统，在支撑互联网服务时，对象存储系统具有如下优势：</p><p>​    A、相对于文件系统的复杂API，分布式对象存储系统仅提供基于对象的创建、读取、更新、删除的简单接口，在使用时更方便而且语义没有歧义。</p><p>​    B、对象分布在一个平坦的空间中，而非文件系统那样的名称空间之中，这提供了很大的管理灵活性：既可以在所有对象之上构建树状逻辑结构；也可以直接用平坦的空间；还可以只在部分对象之上构建树状逻辑结构；甚至可以在同一组对象之上构建多个名称空间。</p><p>​    Amazon的S3就属于对象存储服务。S3通过基于Http REST的接口进行数据访问，按照用量和流量进行计费，其他的云服务商也都提供了类似的接口服务。很多互联网服务商，如Facebook等也都构建了对象存储系统，用于存储图片、照片等小型文件。</p><p>​    3)、分布式数据库管理系统：传统的单机数据库采用”向上扩展”的思路来解决计算能力和存储能力的问题，即增加CPU处理能力、内存和磁盘数量。这种系统目前最大能够支持几个TB 数据的存储和处理，远不能满足实际需求。采用集群设计的分布式数据库逐步成为主流。传统的集群数据库的解决方案大体分为以下两类：</p><p>​    A、Share-Everything(Share-Something)：数据库结点之间共享资源，例如磁盘、缓存等。当结点数量增大时，结点之间的通信将成为瓶颈；而且处理各个结点对数据的访问控制也为事务处理带来麻烦。</p><p>​    B、Share-Nothing：所有的数据库服务器之间并不共享任何信息。当任意一个结点接到查询任务时，都会将任务分解到其他所有的结点上面，每个结点单独处理并返回结果。但由于每个结点容纳的数据和规模并不相同，因此如何保证一个查询能够被均衡地分配到集群中成为一个关键问题。同时，结点在运算时可能从其他结点获取数据，这同样也延长了数据处理时间。在处理数据更新请求时，Share-Nothing数据库需要保证多结点的数据一致性，需要快速准确定位到数据所在结点。</p><p>​    云计算环境下，大部分应用不需要支持完整的SQL语义，而只需要Key-Value形式或略复杂的查询语义。在这样的背景下，进一步简化的各种NoSQL数据库成为云计算中的结构化数据存储的重要技术。</p><p>​    Google的BigTable是一个典型的分布式结构化数据存储系统。在表中，数据是以”列族”为单位组织的，列族用一个单一的键值作为索引，通过这个键值，数据和对数据的操作都可以被分布到多个结点上进行。</p><p>​    在开源社区中，Apache HBase使用了和BigTable类似的结构，基于Hadoop平台提供BigTable的数据模型，而Cassandra则采用了亚马逊Dynamo的基于DHT的完全分布式结构，实现更好的可扩展性。</p><p>​    (4)、并行计算模式：并行计算模型是提高海量数据处理效率的常用方法。常用的并行计算模型主要包括两类：一类是面向高性能计算的，如MPI(Message Passing Interface)模型；另一类是面向互联网数据密集型应用的并行编程模型，如Google的MapReduce模型、微软的Dryad模型。第二类并行计算模型更适用于云计算环境。云计算下把海量数据分布到多个结点(通常是廉价不可靠的PC机)上，将计算并行化，利用多机的计算资源，加快数据处理的速度。</p><p>​    云计算下的并行处理需要考虑以下关键问题：任务划分，使得任务能更加优化的被分解和并行执行；任务调度，操作尽量本地化，以保证在网络资源有限的情况下，最大程度地将计算任务在本地执行，减少通信开销；自动容错处理机制，保证在结点失效的情况下处理任务仍然能够正确地执行。下面分别阐述这三方面内容。</p><p>​    1)、任务划分：在MapReduce或Dryad中，数据以块的形式存储在集群的各个结点上，每个计算任务只需处理一部分数据，这样自然地实现了海量数据的并行处理。这种简单的根据存储位置进行任务划分的方式，只适用于不存在数据依赖关系的计算。而对于存在依赖关系的计算，MapReduce将复杂的计算转化为一系列单一的Map&#x2F;Reduce计算，串联起来完成多个Map&#x2F;Reduce任务来实现复杂计算。转化有两者方式：手工转化和利用Pig、Hive等工具进行自动转化。Dyrad将存在依赖关系的复杂计算表示为一个有向无环图，利用图论对计算自动进行依赖性分析和优化，最后转化为高效的子任务执行。</p><p>​    2)、任务调度：一个集群系统的存储和计算资源有两种组织方式：一是将存储和计算资源部署在相同结点上；另一种是存储和计算结点分开部署。MapReduce和Dryad采用前者，MPI采用后者。MapReduce和Dryad在调度任务时认为”移动计算比移动数据更合算”，优先把计算任务调度到数据所在的结点或者就近的结点，这样在进行计算时，大部分的输入数据都能从本地读取，减少了网络带宽的消耗，提高了整个系统的吞吐量。另外，MapReduce对于由于各种原因(例如硬盘出错)造成执行非常慢的子任务采用了备用任务的机制，当MapReduce操作接近完成时，调度备用任务进程来执行剩下的执行非常慢的子任务。</p><p>​    3)、自动容错处理机制：常用恢复机制有两类：任务重做(Task Re-execute)和检查点(Checkpoint)回滚方式。这两种机制各有优缺点，前者实现非常简单，但是重做的代价比较大；后者实现较复杂，需要周期性地记录所有进程状态，但是恢复较快。MapReduce和Dryad主要采用任务重做的方式来处理结点的失效，而MPI通常采用检查点回滚的机制。</p><p>​    (5)、用户交互技术：随着云计算的逐步普及，浏览器已经不仅仅是一个客户端的软件，而逐步演变为承载着互联网的平台。浏览器与云计算的整合技术主要体现在两个方面：浏览器网络化与浏览器云服务。</p><p>​    国内各家浏览器都将网络化作为其功能的标配之一，主要功能体现在用户可以登录浏览器，并通过自己的帐号将个性化数据同步到服务端。用户在任何地方，只需要登录自己的帐号，就能够同步更新所有的个性内容，包括浏览器选项配置、收藏夹、网址记录、智能填表、密码保存等。</p><p>​    目前的浏览器云服务主要体现在P2P下载、视频加速等单独的客户端软件中，主要的应用研究方向包括：基于浏览器的P2P下载、视频加速、分布式计算、多任务协同工作等。在多任务协同工作方面,AJAX(Asynchronous JavaScript and XML，异步JavaScript和XML)是一种创建交互式网页应用的网页开发技术，改变了传统网页的交互方式，改进了交互体验。</p><p>​    (6)、安全管理：安全问题是用户是否选择云计算的主要顾虑之一。传统集中式管理方式下也有安全问题，云计算的多租户、分布性、对网络和服务提供者的依赖性，为安全问题带来新的挑战。其中，主要的数据安全问题和风险包括：</p><p>​    1)、数据存储及访问控制：包括如何有效存储数据以避免数据丢失或损坏，如何避免数据被非法访问和篡改，如何对多租户应用进行数据隔离，如何避免数据服务被阻塞，如何确保云端退役(at rest)数据的妥善保管或销毁等等。</p><p>​    2)、数据传输保护：包括如何避免数据被窃取或攻击，如何保证数据在分布式应用中有效传递等。</p><p>​    3)、数据隐私及敏感信息保护：包括如何保护数据所有权、并可根据需要提供给受信方使用，如何将个人身份信息及敏感数据挪到云端使用等。</p><p>​    4)、数据可用性：包括如何提供稳定可靠的数据服务以保证业务的持续性，如何进行有效的数据容灾及恢复等。</p><p>​    5)、依从性管理：包括如何保证数据服务及管理符合法律及政策的要求等。</p><p>​    相应的数据安全管理技术包括：</p><p>​    1)、数据保护及隐私(Data Protection and Privacy)：包括虚拟镜像安全、数据加密及解密、数据验证、密钥管理、数据恢复、云迁移的数据安全等。</p><p>​    2)、身份及访问管理(Identity and Access Management,简称IAM)：包括身份验证、目录服务、联邦身份鉴别&#x2F;单点登陆(Single Sign on，简称SSO)、个人身份信息保护、安全断言置标语言、虚拟资源访问、多租用数据授权、基于角色的数据访问、云防火墙技术等。</p><p>​    3)、数据传输(Data Transportation)：包括传输加密及解密、密钥管理、信任管理等。</p><p>​    4)、可用性管理(Availability Management)：包括单点失败(Single Point of Failure，简称SPoF)、主机防攻击、容灾保护等。</p><p>​    5)、日志管理(Log Management)：包括日志系统、可用性监控、流量监控、数据完整性监控、网络入侵监控等。</p><p>​    6)、审计管理(Audit Management)：包括审计信任管理、审计数据加密等。</p><p>​    7)、依从性管理(Compliance Management)：包括确保数据存储和使用等符合相关的风险管理和安全管理的规定要求。</p><p>​    (7)、运营支撑管理：为了支持规模巨大的云计算环境，需要成千上万台服务器来支撑。如何对数以万计的服务器进行稳定高效地运营管理，成为云服务被用户认可的关键因素之一。下面从云的部署、负载管理和监控、计量计费、服务水平协议(Service Level Agreement，简称SLA)、能效评测这五个方面分别阐述云的运营管理。</p><p>​    1)、云的部署：包括两个方面：云本身的部署和应用的部署。如前所述，云一方面规模巨大，另一方面要求很好的服务健壮性、可扩展性和安全性。因此，云的部署是一个系统性的工程，涉及到机房建设、网络优化、硬件选型、软件系统开发和测试、运维等各个方面。为了保证服务的健壮性，需要将云以一定冗余部署在不同地域的若干机房。为了应对规模的不断增长，云要具备便利的、近乎无限的扩展能力，因而从数据存储层、应用业务层到接入层都需要采用相应的措施。为了保护云及其应用的安全，需要建立起各个层次的信息安全机制。除此之外，还需要部署一些辅助的子系统，如管理信息系统(MIS)、数据统计系统、安全系统、监控和计费系统等，他们帮助云的部署和运营管理达到高度自动化和智能化的程度。</p><p>​    云本身的部署对云的用户来说是透明的。一个设计良好的云，应使得应用的部署对用户也是透明和便利的。这依赖云提供部署工具(或API)帮助用户自动完成应用的部署。一个完整的部署流程通常包括注册、上传、部署和发布四个过程。</p><p>​    2)、负载管理和监控：云的负载管理和监控是一种大规模集群的负载管理和监控技术。在单个结点粒度，它需要能够实时地监控集群中每个结点的负载状态，报告负载的异常和结点故障，对出现过载或故障的结点采取既定的预案。在集群整体粒度，通过对单个结点、单个子系统的信息进行汇总和计算，近乎实时地得到集群的整体负载和监控信息，为运维、调度和成本提供决策。与传统的集群负载管理和监控相比，云对负载管理和监控有新的要求：首先，新增了应用粒度，即以应用为粒度来汇总和计算该应用的负载和监控信息，并以应用为粒度进行负载管理。应用粒度是可以再细分的。粒度甚至精细到API调用的粒度。其次，监控信息的展示和查询现在要作为一项服务提供给用户，而不仅仅是少量的专业集群运维人员，这需要高性能的数据流分析处理平台的支持。</p><p>​    3)、计量计费：<strong>云的主要商业运营模式是采取按量计费的收费方式</strong>，即便对于私有云，其运营企业或组织也可能有按不同成本中心进行成本核算的需求。为了精确的度量”用了多少”，就需要准确的、及时的计算云上的每一个应用服务使用了多少资源，这称为服务计量。</p><p>​    服务计量是一个云的支撑子系统，它独立于具体的应用服务，像监控一样能够在后台自动地统计和计算每一个应用在一定时间点的资源使用情况。对于资源的衡量维度主要是：应用的上行(in)&#x2F;下行(out)流量、外部请求响应次数、执行请求所花费的CPU时间、临时和永久数据存储所占据的存储空间、内部服务API调用次数等。也可认为，任何应用使用或消耗的云的资源，只要可以被准确的量化，就可以作为一种维度来计量。实践中，计量通常既可以用单位时间内资源使用的多少来衡量，如每天多少字节流量；也可以用累积的总使用量来衡量，如数据所占用的存储空间字节大小。</p><p>​    在计量的基础上，选取若干合适的维度组合，制定相应的计费策略，就能够进行计费。计费子系统将计量子系统的输出作为输入，并将计费结果写入帐号子系统的财务信息相关模块，完成计费。计费子系统还产生可供审计和查询的计费数据。</p><p>​    4)、SLA：是在一定开销下为保障服务的性能和可靠性，服务提供商与用户间定义的一种双方认可的协定。对于云服务而言，SLA是必不可缺的，因为用户对云服务的性能和可靠性有不同的要求。从用户的角度而言，也需要从云服务提供商处得到具有法律效力的承诺，来保证支付费用之后得到应有的服务质量。从目前的实践看，国外的大型云服务提供商均提供了SLA。</p><p>​    一个完整的SLA 同时也是一个具有法律效力的合同文件，它包括所涉及的当事人、协定条款、违约的处罚、费用和仲裁机构等。当事人通常是云服务提供商与用户。协定条款包含对服务质量的定义和承诺。服务质量一般包括性能、稳定性等指标，如月均稳定性指标、响应时间、故障解决时间等。实际上，SLA的保障是以一系列服务水平目标(Service Level Object，简称SLO)的形式定义的。SLO是一个或多个有限定的服务组件的测量的组合。一个SLO被实现是指那些有限定的组件的测量值在限定范围里。通过前述的对云及应用的监控和计量，可以计算哪些SLO被实现或未被实现，如果一个SLO未被实现，即SLA的承诺未能履行，就可以按照”违约的处罚”对当事人(一般是云服务提供商)进行处罚。通常采取的方法是减免用户已缴纳或将缴纳的费用。</p><p>​    5)、能效评测：云计算提出的初衷是将资源和数据尽可能放在云中，通过资源共享、虚拟化技术和按需使用的方式提高资源利用率，降低能源消耗。但是在实际应用中，大型数据中心的散热问题造成了大量的能源消耗。如何有效降低能源消耗构建绿色数据中心成为云服务提供商迫切需要解决的问题之一。</p><p>​    云计算数据中心的能耗测试评价按照不同的维度有不同测试手段和方法。针对传统的数据中心它有显性评价体系和隐性评价体系两个方面。</p><p>​    显性的能耗测试评价可以参照传统数据中心的评价体系，具体包括：能源效率指标、IT 设备的能效比、IT设备的工作温度和湿度范围、机房基础设施的利用率指标。能源效率指标用于评估一个数据中心使用的能源中有多少用于生产，还有多少被浪费。在这方面，绿色网格组织的电能利用率(Power Usage Effectiveness，简称PUE)指标影响力较大。PUE值越小，意味着机房的节能性越好。目前，国内绝大多数的数据中心PUE值为3左右，而欧美一些国家数据中心的PUE平均值为2左右。</p><p>​    隐性能耗测试评价包括云计算服务模式节省了多少社会资源，由于客户需求的不同，云吞吐量的变化节省了多少IT设备的投资和资源的重复建设。这些的测试评价很多时候是不能量化或者不能够进行精准地评价。</p><p>​    为了实现对数据中心能源的自动调节，满足相关的节能要求，一些IT厂商和标准化组织纷纷推出节能技术及能耗检测工具，如惠普公司的动态功率调整技术(Dynamic Power Saver，简称DPS)、IBM的Provisioning软件。</p><p>​    <strong>云计算应用</strong>：</p><p>​    (1)、云教育：教育在云技术平台上的开发和应用，被称为”教育云”。云教育从信息技术的应用方面打破了传统教育的垄断和固有边界。通过教育走向信息化，使教育的不同参与者—-教师、学生、家长、教育部门等在云技术平台上进行教育、教学、娱乐、沟通等功能。同时可以通过视频云计算的应用对学校特色教育课程进行直播和录播，并将信息储存至流存储服务器上，便于长时间和多渠道享受教育成果。</p><p>​    (2)、云物联：物联网是新一代信息技术浪潮的生力军。物联网通过智能感知、识别技术与普适计算广泛应用于互联网各方面。物联网作为互联网的业务和应用，随着其深入的发展和流量的增加，对数据储存和计算量的要求将带来对云计算的需求增加。并且在物联网的高级阶段，必将需要虚拟云计算技术的进一步应用。</p><p>​    (3)、云社交：是一种虚拟社交应用。它以资源分享作为主要目标，将物联网、云计算和移动互联网相结合，通过其交互作用创造新型社交方式。云社交把社会资源进行测试、分类和集成，并向有需求的用户提供相应的服务。用户流量越大，资源集成越多，云社交的价值就越大。目前云社交已经具备了初步模型。</p><p>​    (4)、云安全：是云计算在互联网安全领域的应用。云安全融合了并行处理、网络技术、未知病毒等新兴技术，通过分布在各领域的客户端对互联网中存在异常的情况进行监测，获取最新病毒程序信息，将信息发送至服务端进行处理并推送最便捷的解决建议。通过云计算技术使整个互联网变成了终极安全卫士。</p><p>​    (5)、云政务：云计算应用于政府部门中，为政府部门降低成本提高效率做出贡献。由于云计算具有集约、共享、高效的特点，所以其应用将为政府部门降低20%至80%的成本。所以在电子商务延伸至电子政务的背景下，各国政府部门都在着力进行电子政务改革，研究云计算普遍应用的可能性。伴随政府改革的进行，政府部门也开始从自建平台到购买电信运营商的服务，这将为促进云计算的进一步发展并为电信运营商带来商机。</p><p>​    (6)、云存储：是云计算的一个新的发展浪潮。云存储不是某一个具体的存储设备，而是互联网中大量的存储设备通过应用软件共同作用协同发展，进而带来的数据访问服务。云计算系统要运算和处理海量数据，为支持云计算系统需要配置大量的存储设备，这样云技术系统就自动转化为云存储系统。故而，云存储是在云计算的概念的延伸。</p><p>​    如果没有云计算，生活将会非常不同。云计算已经成为我们日常生活中不可或缺的一部分，大多数人甚至在没有意识到的情况下就在使用它了。事实上，如果没有云平台的存在，人们的生活将会无法想像：没有云，就不会有Facebook、Twitter、Gmail和Spotify。</p><p>​    <strong>“云”为何会如此强大</strong>：</p><p>​    (1)、部署速度快：如果你曾参与过新应用程序的部署，你就会知道，从安装到运行要耗费几个月甚至是几年的时间。而有了基于云端的应用程序，这一切变得不再那么复杂。在多数情况下，你可以即刻登录并开始使用应用程序。至于各企业通用的大多数应用程序，则在几天或几周内就可以完成部署和运行，不再需要几个月或几年的时间。</p><p>​    (2)、无需预付费：在过去，部署新的应用程序要支出高额费用购置新设备，另外还要支付许可证费用、集成费用，并且不可避免的还要支付顾问咨询费。而有了云计算软件，这些费用会大幅下降，甚至完全不需要支付此类费用。你只需按月支付固定的服务费用即可使用。如此一来，原本无法预期的巨额支出旋即转变为可预测的运营费用。</p><p>​    (3)、即时可扩展：随着时间的推移，你可以根据需要的变化选择增加或减少使用云应用程序的用户数量。这意味着，你按需付费即可，而且不必再担心云端容量不足。</p><p>​    (4)、用户无需维护：你的IT员工每个月都需要花费几天的时间来修补、升级和测试应用程序，但使用云应用程序之后，则不必再执行这些操作。这是因为一切都由我们在云端处理，从而让你的员工有更多的时间从事新项目和进行创新。</p><p>​    (5)、随时随地访问：云应用程序的设计，旨在让人们随时随地都可通过任何设备安全访问。</p><p>​    (6)、更具安全性：据2010年的一项研究发现，企业平均每年会遗失263台笔记本电脑。如果电脑中包含机密数据，每一次遗失都会带来严重的安全隐患。但使用云应用程序后，你的数据安全地被存储在云中。因此，遗失笔记本电脑只是会带来不便，并不会带来潜在灾害。</p><p>​    <strong>云计算面临的挑战</strong>：缺乏统一的技术标准；缺乏统一的运营服务标准；服务的可用性问题；运营管理问题；能效管理问题；信用和安全管理；海量数据的产生。</p><p>​    <strong>云计算的隐私安全问题主要包括</strong>：</p><p>​    (1)、在未经授权的情况下，他人以不正当的方式进行数据侵入，获得用户数据。</p><p>​    (2)、政府部门或其他权利机构为达到目的对云计算平台上的信息进行检查，获取相应的资料以达到监管和控制的目的。</p><p>​    (3)、云计算提供商为获取商业利益对用户信息进行收集和处理。</p><p>​    以上内容主要摘自： 《云计算标准化白皮书》、<a href="https://zh.wikipedia.org/wiki/%E9%9B%B2%E7%AB%AF%E9%81%8B%E7%AE%97">维基百科</a>、 <a href="https://www.salesforce.com/cn/cloudcomputing/">Salesforce</a> </p>]]></content>
    
    
    
    <tags>
      
      <tag>computation tech</tag>
      
      <tag>Cloud Computing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About Homomorphic encryption, MPC &amp; Crypten</title>
    <link href="/2022/03/08/About-Homomorphic-encryption,-MPC-&amp;-Crypten/"/>
    <url>/2022/03/08/About-Homomorphic-encryption,-MPC-&amp;-Crypten/</url>
    
    <content type="html"><![CDATA[<h1 id="About-Homomorphic-Encryption-MPC-amp-Crypten"><a href="#About-Homomorphic-Encryption-MPC-amp-Crypten" class="headerlink" title="About Homomorphic Encryption, MPC &amp; Crypten"></a>About Homomorphic Encryption, MPC &amp; Crypten</h1><h3 id="homomorphic-encrytion"><a href="#homomorphic-encrytion" class="headerlink" title="homomorphic encrytion"></a><a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86">homomorphic encrytion</a></h3><p>对密文进行特定形式的代数运算后 仍然是加密的结果，这样解密得到的结果和明文进行同样的运算结果一样。 也就是说，这项技术能够在 数据加密的情况下进行诸如 检索、比较等操作，并且得出正确的结果。  这项技术的意义就是从根本上解决数据被委托给第三方时的保密问题。  </p><p>同态加密在以往都只能实现部分操作，全同态加密的可行性是由09年 斯坦福大学的 Craig Gentry 的 <a href="https://www.cs.cmu.edu/~odonnell/hits09/gentry-homomorphic-encryption.pdf">《Fully Homomorphic encryption Using Ideal Lattices》</a>一文中，从数学角度上证明了全同态加密的可行性。</p><hr><h3 id="MPC-Secure-multi-party-computation"><a href="#MPC-Secure-multi-party-computation" class="headerlink" title="MPC   Secure multi-party computation"></a>MPC   Secure multi-party computation</h3><p>Multiparty Computation (MPC) is a research area within cryptography whose application is generally limited to preserving the privacy of participants to a conversation from each other, rather than to preventing eavesdropping by an outsider.</p><ul><li><p>MPC 用到的三种安全模型： 理想模型(全是好人) ，半诚实模型(不破坏规则，但会推理出额外信息)，恶意模型</p></li><li><p>在无可信第三方的情况下，如何安全的计算一个约定函数(这可能有点像diffie Hellman)</p></li><li><p>Zero-Knowledge Proof 不向验证者提供有效信息的情况下使验证者相信你的论断</p></li><li><p>differential privacy 差分隐私 「利用噪声来实现安全(计算上安全)，而非加密手段」</p></li></ul><p>可以拿出以下这个例子： 两个百万富翁比财产(他们不想让任何人知道自己有多少钱)</p><p>假设两人的财富都是1kw ～ 10kw  拿来10个编号的箱子，编号代表kw数(比如3kw 就是3号箱)，甲会对这10个箱子，每一个的编号对应的钱数 少于自己的 放入苹果，和自己一样的，放入香蕉，多于自己的，放入梨。 然后将10个箱子寄给乙。 乙选出自己对应财富的箱子，并销毁其他的箱子和编号。  这时打开箱子，甲和乙就能知道谁更富有。</p><p>「这个例子 基于半诚实模型，同时也有<code>不经意传输 Obivious Transfer</code>的影子, 即发送方向接收方发送信息中的一个部分，接收方可以正确的接收到信息，但不知道这个信息属于整体的哪个部分」</p><h4 id="MPC的两种应用形式：-外包计算-x2F-多方计算-此处望文生义即可"><a href="#MPC的两种应用形式：-外包计算-x2F-多方计算-此处望文生义即可" class="headerlink" title="MPC的两种应用形式： 外包计算 &#x2F; 多方计算    此处望文生义即可"></a>MPC的两种应用形式： 外包计算 &#x2F; 多方计算    此处望文生义即可</h4><hr><h3 id="Crypten-「Privacy-Preserving-Machine-Learning」"><a href="#Crypten-「Privacy-Preserving-Machine-Learning」" class="headerlink" title="Crypten  「Privacy Preserving Machine Learning」"></a><a href="https://crypten.readthedocs.io/en/latest/">Crypten</a>  「Privacy Preserving Machine Learning」</h3><ul><li>目前是实验用，只支持MAC和Linux系统，不支持Windows和GPU训练. Crypten 分别训练</li></ul><p><a href="https://blog.csdn.net/u012386311/article/details/105264884?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2.pc_relevant_paycolumn_v3&utm_relevant_index=5">Crypten核心代码分析</a></p><p><a href="https://blog.csdn.net/u012386311/article/details/104650936">Crypten 环境变量配置</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Cryptography</tag>
      
      <tag>Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机技术杂谈</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机技术杂谈"><a href="#计算机技术杂谈" class="headerlink" title="计算机技术杂谈"></a>计算机技术杂谈</h1><h3 id="大数据与云计算"><a href="#大数据与云计算" class="headerlink" title="大数据与云计算"></a>大数据与云计算</h3><p>大数据不是数据存储技术，而是和海量数据相关的抽取、集成、管理、分析、解释方法，是一个庞大的框架系统。宏观上讲，对数据进行映射和提炼，发现其数据特征并加以利用。从技术上说，是通过<strong>获取、存储、分析，从大容量数据里挖掘价值的</strong>技术架构。</p><p>大数据的量级在 PB(1024TB)或者EB级，其关键特点有 Volume(量)、Variety、**Velocity(时效性短)**、Value(价值密度低)</p><p>云计算：这种基于互联网的计算方式，可以更好的对软硬计算资源进行整合，在我看来，这个概念有些类似操作系统中提供虚拟化资源的概念，相当于是面向互联网计算的虚拟计算环境，使用户能够方便、有效地共享和利用网络上的资源</p><hr><h3 id="前端-amp-后端"><a href="#前端-amp-后端" class="headerlink" title="前端 &amp; 后端"></a>前端 &amp; 后端</h3><ul><li>广义上说，任何和UI直接相关的工作，都属于前端，狭义上讲，前端就是网页端</li><li>后端 是具体实现功能的地方，<strong>并且负责关键的 状态维护 和 控制权限</strong>，这些控制机制不能被放在前端</li></ul><h3 id="JavaScript，CSS与HTML的关系"><a href="#JavaScript，CSS与HTML的关系" class="headerlink" title="JavaScript，CSS与HTML的关系"></a>JavaScript，CSS与HTML的关系</h3><ul><li><strong>HTML定义页面结构和核心内容，CSS则为这些内容加上样式，JS则可以同时做到这两件事。</strong><ul><li>抽象的说，html是骨，负责将信息结构化，CSS则是肉，负责添加装饰性内容</li><li>CSS可以更简单的完成一些html完成很麻烦的工作，比如将所有的标题居中。</li></ul></li><li>JS可以完成html和css的工作，但复杂一些，其主要功能是 <strong>指导浏览器如何动态建立结构和作用样式，也就是负责控制逻辑</strong></li></ul><hr><h4 id="SSL-amp-SSH"><a href="#SSL-amp-SSH" class="headerlink" title="SSL &amp; SSH"></a>SSL &amp; SSH</h4><p>在原本的HTTP协议中，内容是明文形式传输，而HTTPS &#x3D;&gt; <strong>SSL&#x2F;TLS</strong>(Secure Sockets Layer &#x2F; Transport Layer Security) 协议，默认为443端口，本身可以看作是传输层的附加层。有三个好处</p><ul><li>加密。防窃听</li><li>校验。防篡改</li><li>证书。防冒充</li></ul><p>其基本思路在于 **使用<code>公钥加密</code>加密<code>会话密钥</code>**，注意：会话密钥本身是对称加密的密钥，实际上https客户端和服务器的通信是使用对称加密的，这样更快。</p><h4 id="注意区分SSL和SSH-Secure-Shell"><a href="#注意区分SSL和SSH-Secure-Shell" class="headerlink" title="注意区分SSL和SSH Secure Shell"></a>注意区分SSL和SSH Secure Shell</h4><p>两者间建立一条加密通道，将数据加密并且压缩传输。  SSL并非协议，而SSH则是建立在SSL基础上的协议。 SSH可以代替telnet 和 ftp</p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>Computation tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Brief Introduction to Artificial Intelligence</title>
    <link href="/2022/03/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    <url>/2022/03/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><a href="https://easyai.tech/">AI概念的基础科普</a></p><p>百度智能云 调库用 (<a href="https://cloud.baidu.com/">https://cloud.baidu.com</a>)</p><p><a href="https://www.paddlepaddle.org.cn/tutorials/projectdetail/2496128">https://www.paddlepaddle.org.cn/tutorials/projectdetail/2496128</a>)</p><h3 id="机器学习的常见算法"><a href="#机器学习的常见算法" class="headerlink" title="机器学习的常见算法"></a>机器学习的常见算法</h3><ul><li>supervised learning &amp; unsupervised learning 「main」</li><li>Reinforcement learning，recommender systems</li></ul><h3 id="机器学习的三大问题"><a href="#机器学习的三大问题" class="headerlink" title="机器学习的三大问题"></a>机器学习的三大问题</h3><h4 id="regression-problem-回归问题"><a href="#regression-problem-回归问题" class="headerlink" title="regression problem 回归问题"></a>regression problem 回归问题</h4><ul><li>样本由离散的点构成，我们需要利用模型来拟合它，从而对连续的每个值都给出预测</li><li>常见情况下 模型分为：linear model 和 polynomial model 两种</li><li><img src="/Users/natsumi/Library/Application Support/typora-user-images/image-20220114193515388.png" alt="image-20220114193515388" style="zoom:50%;" /></li></ul><h4 id="classification-problem-分类问题"><a href="#classification-problem-分类问题" class="headerlink" title="classification problem 分类问题"></a>classification problem 分类问题</h4><ul><li>和回归问题不同的地方在于 其产出是离散的 常见情况是 下判断</li></ul><h4 id="Clustering-problem-聚类问题"><a href="#Clustering-problem-聚类问题" class="headerlink" title="Clustering problem 聚类问题"></a>Clustering problem 聚类问题</h4><h3 id="Three-Basic-ML-method"><a href="#Three-Basic-ML-method" class="headerlink" title="Three Basic ML method"></a>Three Basic ML method</h3><p>Supervised Learning 「给出正确的答案，算法的目的是产生更多正确答案」</p><ul><li>a data set with right answers given,  the task of the algorithm is to <strong>produce more of these right answers.</strong> </li><li>由监督学习引出的两种问题是 分类问题和回归问题(两者的区别在连续和离散)</li><li>强监督和弱监督  如果你对每组数据都给出完整、正确的标签，那么就是强监督学习 <ul><li>弱监督学习分为三类： 「周志华老师  A brief Introduction to Weakly Supervised Learning」   这三类并非我们人为选择，而是在实际操作中可能会同时发生的。<ul><li><p>Incomplete su 不完全监督： 只对一部分数据给出label</p><ul><li>解决方案： <ul><li>Active L 主动学习 &#x3D;&gt; 先训练标注过的数据，剩下的自动查询。 有人工干预</li><li>Semi-su L半监督学习 &#x3D;&gt; 观察未被标注的数据分布，比如说在一个positive和一个negative中间的，如果他附近的样本点很多为正，那么可以认为它大概率为正</li></ul></li></ul></li><li><p>Inexact su 不确切监督：给出的标签是粗粒度的，一个包里的示例只给了一个标签</p><ul><li>解决方案：<ul><li>Multi-instance L 多实例学习 &#x3D;&gt; 实际上几乎所有机器学习算法都有其多实例对等体，这个的应用非常广泛</li></ul></li></ul></li><li><p>Inaccurate su不精确监督： 给出的标签可能有错误</p><ul><li>解决方案：<ul><li>L with label noise 带噪学习 &#x3D;&gt; 基本思想是 识别潜在的误分类样本然后修正。在系统中建立相邻关系表，如果某个点和其相邻的点不同，它就可能被判定为可疑点，系统可能会将其删除或重新标记</li></ul></li></ul></li></ul></li></ul></li></ul><p>Unsupervised Learning 「数据不含标签，算法的目的是找到数据中的结构 我们不知道正确答案」</p><ul><li>a data set with no labels, the task of the algorithm is to find some structure in the data, the key is we don’t know how to divide the data in advance.<ul><li>cluster algorithm (organize computing clusters or social network analysis)</li><li>cocktail party problem</li></ul></li><li>由非监督学习引出的问题则是 聚类问题，将训练数据分成几个类，自己去寻找结构</li></ul><p>Reinforcement learning  RL</p><p>强调探索和利用的平衡，通过某种奖惩机制刺激，逐步产生获得最大利益的习惯性行为。</p><hr><p>周志华 🍉📖 index</p><figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir">目录<br>第<span class="hljs-number">1</span>章 <span class="hljs-number">1</span><br><span class="hljs-number">1.1</span> 引言 <span class="hljs-number">1</span><br><span class="hljs-number">1.2</span> 基本术 <span class="hljs-number">2</span><br><span class="hljs-number">1.3</span> 假设空间 <span class="hljs-number">4</span><br><span class="hljs-number">1.4</span> 归纳偏好 <span class="hljs-number">6</span><br><span class="hljs-number">1.5</span> 发展历程 <span class="hljs-number">10</span><br><span class="hljs-number">1.6</span> 应用现状 <span class="hljs-number">13</span><br><span class="hljs-number">1.7</span> 阅读材料 <span class="hljs-number">16</span><br>习题 <span class="hljs-number">19</span><br>参考文献 <span class="hljs-number">20</span><br>休息一会儿 <span class="hljs-number">22</span><br>第<span class="hljs-number">2</span>章 模型评估与选择 <span class="hljs-number">23</span><br><span class="hljs-number">2.1</span> 经验误差与过拟合 <span class="hljs-number">23</span><br><span class="hljs-number">2.2</span> 评估方法 <span class="hljs-number">24</span><br><span class="hljs-number">2.2</span>.<span class="hljs-number">1</span> 留出法 <span class="hljs-number">25</span><br><span class="hljs-number">2.2</span>.<span class="hljs-number">2</span> 交叉验证法 <span class="hljs-number">26</span><br><span class="hljs-number">2.2</span>.<span class="hljs-number">3</span> 自助法 <span class="hljs-number">27</span><br><span class="hljs-number">2.2</span>.<span class="hljs-number">4</span> 调参与最终模型 <span class="hljs-number">28</span><br><span class="hljs-number">2.3</span> 性能度量 <span class="hljs-number">28</span><br><span class="hljs-number">2.3</span>.<span class="hljs-number">1</span> 错误率与精度 <span class="hljs-number">29</span><br><span class="hljs-number">2.3</span>.<span class="hljs-number">2</span> 查准率、查全率与F1 <span class="hljs-number">30</span><br><span class="hljs-number">2.3</span>.<span class="hljs-number">3</span> ROC与AUC <span class="hljs-number">33</span><br><span class="hljs-number">2.3</span>.<span class="hljs-number">4</span> 代价敏感错误率与代价曲线 <span class="hljs-number">35</span><br><span class="hljs-number">2.4</span> 比较检验 <span class="hljs-number">37</span><br><span class="hljs-number">2.4</span>.<span class="hljs-number">1</span> 假设检验 <span class="hljs-number">37</span><br><span class="hljs-number">2.4</span>.<span class="hljs-number">2</span> 交叉验证t检验 <span class="hljs-number">40</span><br><span class="hljs-number">2.4</span>.<span class="hljs-number">3</span> McNemar检验 <span class="hljs-number">41</span><br><span class="hljs-number">2.4</span>.<span class="hljs-number">4</span> Friedman检验与后续检验<span class="hljs-number">42</span><br><span class="hljs-number">2.5</span> 偏差与方差 <span class="hljs-number">44</span><br><span class="hljs-number">2.6</span> 阅读材料 <span class="hljs-number">46</span><br>习题 <span class="hljs-number">48</span><br>参考文献 <span class="hljs-number">49</span><br>休息一会儿 <span class="hljs-number">51</span><br>第<span class="hljs-number">3</span>章 线性模型 <span class="hljs-number">53</span><br><span class="hljs-number">3.1</span> 基本形式 <span class="hljs-number">53</span><br><span class="hljs-number">3.2</span> 线性回归 <span class="hljs-number">53</span><br><span class="hljs-number">3.3</span> 对数几率回归 <span class="hljs-number">57</span><br><span class="hljs-number">3.4</span> 线性判别分析 <span class="hljs-number">60</span><br><span class="hljs-number">3.5</span> 多分类学习 <span class="hljs-number">63</span><br><span class="hljs-number">3.6</span> 类别不平衡问题 <span class="hljs-number">66</span><br><span class="hljs-number">3.7</span> 阅读材料 <span class="hljs-number">67</span><br>习题 <span class="hljs-number">69</span><br>参考文献 <span class="hljs-number">70</span><br>休息一会儿 <span class="hljs-number">72</span><br>第<span class="hljs-number">4</span>章 决策树 <span class="hljs-number">73</span><br><span class="hljs-number">4.1</span> 基本流程 <span class="hljs-number">73</span><br><span class="hljs-number">4.2</span> 划分选择 <span class="hljs-number">75</span><br><span class="hljs-number">4.2</span>.<span class="hljs-number">1</span> 信息增益 <span class="hljs-number">75</span><br><span class="hljs-number">4.2</span>.<span class="hljs-number">2</span> 增益率 <span class="hljs-number">77</span><br><span class="hljs-number">4.2</span>.<span class="hljs-number">3</span> 基尼指数 <span class="hljs-number">79</span><br><span class="hljs-number">4.3</span> 剪枝处理 <span class="hljs-number">79</span><br><span class="hljs-number">4.3</span>.<span class="hljs-number">1</span> 预剪枝 <span class="hljs-number">80</span><br><span class="hljs-number">4.3</span>.<span class="hljs-number">2</span> 后剪枝 <span class="hljs-number">82</span><br><span class="hljs-number">4.4</span> 连续与缺失值 <span class="hljs-number">83</span><br><span class="hljs-number">4.4</span>.<span class="hljs-number">1</span> 连续值处理 <span class="hljs-number">83</span><br><span class="hljs-number">4.4</span>.<span class="hljs-number">2</span> 缺失值处理 <span class="hljs-number">85</span><br><span class="hljs-number">4.5</span> 多变量决策树 <span class="hljs-number">88</span><br><span class="hljs-number">4.6</span> 阅读材料 <span class="hljs-number">92</span><br>习题 <span class="hljs-number">93</span><br>参考文献 <span class="hljs-number">94</span><br>休息一会儿 <span class="hljs-number">95</span><br>第<span class="hljs-number">5</span>章 神经网络 <span class="hljs-number">97</span><br><span class="hljs-number">5.1</span> 神经元模型 <span class="hljs-number">97</span><br><span class="hljs-number">5.2</span> 感知机与多层网络 <span class="hljs-number">98</span><br><span class="hljs-number">5.3</span> 误差逆传播算法 <span class="hljs-number">101</span><br><span class="hljs-number">5.4</span> 全局最小与局部极小 <span class="hljs-number">106</span><br><span class="hljs-number">5.5</span> 其他常见神经网络 <span class="hljs-number">108</span><br><span class="hljs-number">5.5</span>.<span class="hljs-number">1</span> RBF网络 <span class="hljs-number">108</span><br><span class="hljs-number">5.5</span>.<span class="hljs-number">2</span> ART网络 <span class="hljs-number">108</span><br><span class="hljs-number">5.5</span>.<span class="hljs-number">3</span> SOM网络 <span class="hljs-number">109</span><br><span class="hljs-number">5.5</span>.<span class="hljs-number">4</span> 级联相关网络 <span class="hljs-number">110</span><br><span class="hljs-number">5.5</span>.<span class="hljs-number">5</span> Elman网络 <span class="hljs-number">111</span><br><span class="hljs-number">5.5</span>.<span class="hljs-number">6</span> Boltzmann机 <span class="hljs-number">111</span><br><span class="hljs-number">5.6</span> 深度学习 <span class="hljs-number">113</span><br><span class="hljs-number">5.7</span> 阅读材料 <span class="hljs-number">115</span><br>习题 <span class="hljs-number">116</span><br>参考文献 <span class="hljs-number">117</span><br>休息一会儿 <span class="hljs-number">120</span><br>第<span class="hljs-number">6</span>章 支持向量机 <span class="hljs-number">121</span><br><span class="hljs-number">6.1</span> 间隔与支持向量 <span class="hljs-number">121</span><br><span class="hljs-number">6.2</span> 对偶问题 <span class="hljs-number">123</span><br><span class="hljs-number">6.3</span> 核函数 <span class="hljs-number">126</span><br><span class="hljs-number">6.4</span> 软间隔与正则化 <span class="hljs-number">129</span><br><span class="hljs-number">6.5</span> 支持向量回归 <span class="hljs-number">133</span><br><span class="hljs-number">6.6</span> 核方法 <span class="hljs-number">137</span><br><span class="hljs-number">6.7</span> 阅读材料 <span class="hljs-number">139</span><br>习题 <span class="hljs-number">141</span><br>参考文献 <span class="hljs-number">142</span><br>休息一会儿 <span class="hljs-number">145</span><br>第<span class="hljs-number">7</span>章 贝叶斯分类器 <span class="hljs-number">147</span><br><span class="hljs-number">7.1</span> 贝叶斯决策论 <span class="hljs-number">147</span><br><span class="hljs-number">7.2</span> 极大似然估计 <span class="hljs-number">149</span><br><span class="hljs-number">7.3</span> 朴素贝叶斯分类器 <span class="hljs-number">150</span><br><span class="hljs-number">7.4</span> 半朴素贝叶斯分类器 <span class="hljs-number">154</span><br><span class="hljs-number">7.5</span> 贝叶斯网 <span class="hljs-number">156</span><br><span class="hljs-number">7.5</span>.<span class="hljs-number">1</span> 结构 <span class="hljs-number">157</span><br><span class="hljs-number">7.5</span>.<span class="hljs-number">2</span> 学习 <span class="hljs-number">159</span><br><span class="hljs-number">7.5</span>.<span class="hljs-number">3</span> 推断 <span class="hljs-number">161</span><br><span class="hljs-number">7.6</span> EM算法 <span class="hljs-number">162</span><br><span class="hljs-number">7.7</span> 阅读材料 <span class="hljs-number">164</span><br>习题 <span class="hljs-number">166</span><br>参考文献 <span class="hljs-number">167</span><br>休息一会儿 <span class="hljs-number">169</span><br>第<span class="hljs-number">8</span>章 集成学习 <span class="hljs-number">171</span><br><span class="hljs-number">8.1</span> 个体与集成 <span class="hljs-number">171</span><br><span class="hljs-number">8.2</span> Boosting <span class="hljs-number">173</span><br><span class="hljs-number">8.3</span> Bagging与随机森林 <span class="hljs-number">178</span><br><span class="hljs-number">8.3</span>.<span class="hljs-number">1</span> Bagging <span class="hljs-number">178</span><br><span class="hljs-number">8.3</span>.<span class="hljs-number">2</span> 随机森林 <span class="hljs-number">179</span><br><span class="hljs-number">8.4</span> 结合策略 <span class="hljs-number">181</span><br><span class="hljs-number">8.4</span>.<span class="hljs-number">1</span> 平均法 <span class="hljs-number">181</span><br><span class="hljs-number">8.4</span>.<span class="hljs-number">2</span> 投票法 <span class="hljs-number">182</span><br><span class="hljs-number">8.4</span>.<span class="hljs-number">3</span> 学习法 <span class="hljs-number">183</span><br><span class="hljs-number">8.5</span> 多样性 <span class="hljs-number">185</span><br><span class="hljs-number">8.5</span>.<span class="hljs-number">1</span> 误差--分歧分解 <span class="hljs-number">185</span><br><span class="hljs-number">8.5</span>.<span class="hljs-number">2</span> 多样性度量 <span class="hljs-number">186</span><br><span class="hljs-number">8.5</span>.<span class="hljs-number">3</span> 多样性增强 <span class="hljs-number">188</span><br><span class="hljs-number">8.6</span> 阅读材料 <span class="hljs-number">190</span><br>习题 <span class="hljs-number">192</span><br>参考文献 <span class="hljs-number">193</span><br>休息一会儿 <span class="hljs-number">196</span><br>第<span class="hljs-number">9</span>章 聚类 <span class="hljs-number">197</span><br><span class="hljs-number">9.1</span> 聚类任务 <span class="hljs-number">197</span><br><span class="hljs-number">9.2</span> 性能度量 <span class="hljs-number">197</span><br><span class="hljs-number">9.3</span> 距离计算 <span class="hljs-number">199</span><br><span class="hljs-number">9.4</span> 原型聚类 <span class="hljs-number">202</span><br><span class="hljs-number">9.4</span>.<span class="hljs-number">1</span> k均值算法 <span class="hljs-number">202</span><br><span class="hljs-number">9.4</span>.<span class="hljs-number">2</span> 学习向量量化 <span class="hljs-number">204</span><br><span class="hljs-number">9.4</span>.<span class="hljs-number">3</span> 高斯混合聚类 <span class="hljs-number">206</span><br><span class="hljs-number">9.5</span> 密度聚类 <span class="hljs-number">211</span><br><span class="hljs-number">9.6</span> 层次聚类 <span class="hljs-number">214</span><br><span class="hljs-number">9.7</span> 阅读材料 <span class="hljs-number">217</span><br>习题 <span class="hljs-number">220</span><br>参考文献 <span class="hljs-number">221</span><br>休息一会儿 <span class="hljs-number">224</span><br>第<span class="hljs-number">10</span>章 降维与度量学习 <span class="hljs-number">225</span><br><span class="hljs-number">10.1</span> k近邻学习 <span class="hljs-number">225</span><br><span class="hljs-number">10.2</span> 低维嵌入 <span class="hljs-number">226</span><br><span class="hljs-number">10.3</span> 主成分分析 <span class="hljs-number">229</span><br><span class="hljs-number">10.4</span> 核化线性降维 <span class="hljs-number">232</span><br><span class="hljs-number">10.5</span> 流形学习 <span class="hljs-number">234</span><br><span class="hljs-number">10.5</span>.<span class="hljs-number">1</span> 等度量映射 <span class="hljs-number">234</span><br><span class="hljs-number">10.5</span>.<span class="hljs-number">2</span> 局部线性嵌入 <span class="hljs-number">235</span><br><span class="hljs-number">10.6</span> 度量学习 <span class="hljs-number">237</span><br><span class="hljs-number">10.7</span> 阅读材料 <span class="hljs-number">240</span><br>习题 <span class="hljs-number">242</span><br>参考文献 <span class="hljs-number">243</span><br>休息一会儿 <span class="hljs-number">246</span><br>第<span class="hljs-number">11</span>章 特征选择与稀疏学习 <span class="hljs-number">247</span><br><span class="hljs-number">11.1</span> 子集搜索与评价 <span class="hljs-number">247</span><br><span class="hljs-number">11.2</span> 过滤式选择 <span class="hljs-number">249</span><br><span class="hljs-number">11.3</span> 包裹式选择 <span class="hljs-number">250</span><br><span class="hljs-number">11.4</span> 嵌入式选择与L<span class="hljs-variable">$_1</span><span class="hljs-variable">$正</span>则化 <span class="hljs-number">252</span><br><span class="hljs-number">11.5</span> 稀疏表示与字典学习 <span class="hljs-number">254</span><br><span class="hljs-number">11.6</span> 压缩感知 <span class="hljs-number">257</span><br><span class="hljs-number">11.7</span> 阅读材料 <span class="hljs-number">260</span><br>习题 <span class="hljs-number">262</span><br>参考文献 <span class="hljs-number">263</span><br>休息一会儿 <span class="hljs-number">266</span><br>第<span class="hljs-number">12</span>章 计算学习理论 <span class="hljs-number">267</span><br><span class="hljs-number">12.1</span> 基础知识 <span class="hljs-number">267</span><br><span class="hljs-number">12.2</span> PAC学习 <span class="hljs-number">268</span><br><span class="hljs-number">12.3</span> 有限假设空间 <span class="hljs-number">270</span><br><span class="hljs-number">12.3</span>.<span class="hljs-number">1</span> 可分情形 <span class="hljs-number">270</span><br><span class="hljs-number">12.3</span>.<span class="hljs-number">2</span> 不可分情形 <span class="hljs-number">272</span><br><span class="hljs-number">12.4</span> VC维 <span class="hljs-number">273</span><br><span class="hljs-number">12.5</span> Rademacher复杂度 <span class="hljs-number">279</span><br><span class="hljs-number">12.6</span> 稳定性 <span class="hljs-number">284</span><br><span class="hljs-number">12.7</span> 阅读材料 <span class="hljs-number">287</span><br>习题 <span class="hljs-number">289</span><br>参考文献 <span class="hljs-number">290</span><br>休息一会儿 <span class="hljs-number">292</span><br>第<span class="hljs-number">13</span>章 半监督学习 <span class="hljs-number">293</span><br><span class="hljs-number">13.1</span> 未标记样本 <span class="hljs-number">293</span><br><span class="hljs-number">13.2</span> 生成式方法 <span class="hljs-number">295</span><br><span class="hljs-number">13.3</span> 半监督SVM <span class="hljs-number">298</span><br><span class="hljs-number">13.4</span> 图半监督学习 <span class="hljs-number">300</span><br><span class="hljs-number">13.5</span> 基于分歧的方法 <span class="hljs-number">304</span><br><span class="hljs-number">13.6</span> 半监督聚类 <span class="hljs-number">307</span><br><span class="hljs-number">13.7</span> 阅读材料 <span class="hljs-number">311</span><br>习题 <span class="hljs-number">313</span><br>参考文献 <span class="hljs-number">314</span><br>休息一会儿 <span class="hljs-number">317</span><br>第<span class="hljs-number">14</span>章 概率图模型 <span class="hljs-number">319</span><br><span class="hljs-number">14.1</span> 隐马尔可夫模型 <span class="hljs-number">319</span><br><span class="hljs-number">14.2</span> 马尔可夫随机场 <span class="hljs-number">322</span><br><span class="hljs-number">14.3</span> 条件随机场 <span class="hljs-number">325</span><br><span class="hljs-number">14.4</span> 学习与推断 <span class="hljs-number">328</span><br><span class="hljs-number">14.4</span>.<span class="hljs-number">1</span> 变量消去 <span class="hljs-number">328</span><br><span class="hljs-number">14.4</span>.<span class="hljs-number">2</span> 信念传播 <span class="hljs-number">330</span><br><span class="hljs-number">14.5</span> 近似推断 <span class="hljs-number">331</span><br><span class="hljs-number">14.5</span>.<span class="hljs-number">1</span> MCMC采样 <span class="hljs-number">331</span><br><span class="hljs-number">14.5</span>.<span class="hljs-number">2</span> 变分推断 <span class="hljs-number">334</span><br><span class="hljs-number">14.6</span> 话题模型 <span class="hljs-number">337</span><br><span class="hljs-number">14.7</span> 阅读材料 <span class="hljs-number">339</span><br>习题 <span class="hljs-number">341</span><br>参考文献 <span class="hljs-number">342</span><br>休息一会儿 <span class="hljs-number">345</span><br>第<span class="hljs-number">15</span>章 规则学习 <span class="hljs-number">347</span><br><span class="hljs-number">15.1</span> 基本概念 <span class="hljs-number">347</span><br><span class="hljs-number">15.2</span> 序贯覆盖 <span class="hljs-number">349</span><br><span class="hljs-number">15.3</span> 剪枝优化 <span class="hljs-number">352</span><br><span class="hljs-number">15.4</span> 一阶规则学习 <span class="hljs-number">354</span><br><span class="hljs-number">15.5</span> 归纳逻辑程序设计 <span class="hljs-number">357</span><br><span class="hljs-number">15.5</span>.<span class="hljs-number">1</span> 最小一般泛化 <span class="hljs-number">358</span><br><span class="hljs-number">15.5</span>.<span class="hljs-number">2</span> 逆归结 <span class="hljs-number">359</span><br><span class="hljs-number">15.6</span> 阅读材料 <span class="hljs-number">363</span><br>习题 <span class="hljs-number">365</span><br>参考文献 <span class="hljs-number">366</span><br>休息一会儿 <span class="hljs-number">369</span><br>第<span class="hljs-number">16</span>章 强化学习 <span class="hljs-number">371</span><br><span class="hljs-number">16.1</span> 任务与奖赏 <span class="hljs-number">371</span><br><span class="hljs-number">16.2</span> <span class="hljs-variable">$K</span><span class="hljs-variable">$-</span>摇臂赌博机 <span class="hljs-number">373</span><br><span class="hljs-number">16.2</span>.<span class="hljs-number">1</span> 探索与利用 <span class="hljs-number">373</span><br><span class="hljs-number">16.2</span>.<span class="hljs-number">2</span> <span class="hljs-variable">$\</span>epsilon <span class="hljs-variable">$-</span>贪心 <span class="hljs-number">374</span><br><span class="hljs-number">16.2</span>.<span class="hljs-number">3</span> Softmax <span class="hljs-number">375</span><br><span class="hljs-number">16.3</span> 有模型学习 <span class="hljs-number">377</span><br><span class="hljs-number">16.3</span>.<span class="hljs-number">1</span> 策略评估 <span class="hljs-number">377</span><br><span class="hljs-number">16.3</span>.<span class="hljs-number">2</span> 策略改进 <span class="hljs-number">379</span><br><span class="hljs-number">16.3</span>.<span class="hljs-number">3</span> 策略迭代与值迭代 <span class="hljs-number">381</span><br><span class="hljs-number">16.4</span> 免模型学习 <span class="hljs-number">382</span><br><span class="hljs-number">16.4</span>.<span class="hljs-number">1</span> 蒙特卡罗强化学习 <span class="hljs-number">383</span><br><span class="hljs-number">16.4</span>.<span class="hljs-number">2</span> 时序差分学习 <span class="hljs-number">386</span><br><span class="hljs-number">16.5</span> 值函数近似 <span class="hljs-number">388</span><br><span class="hljs-number">16.6</span> 模仿学习 <span class="hljs-number">390</span><br><span class="hljs-number">16.6</span>.<span class="hljs-number">1</span> 直接模仿学习 <span class="hljs-number">391</span><br><span class="hljs-number">16.6</span>.<span class="hljs-number">2</span> 逆强化学习 <span class="hljs-number">391</span><br><span class="hljs-number">16.7</span> 阅读材料 <span class="hljs-number">393</span><br>习题 <span class="hljs-number">394</span><br>参考文献 <span class="hljs-number">395</span><br>休息一会儿 <span class="hljs-number">397</span><br>附录 <span class="hljs-number">399</span><br>A 矩阵 <span class="hljs-number">399</span><br>B 优化 <span class="hljs-number">403</span><br>C 概率分布 <span class="hljs-number">409</span><br>后记 <span class="hljs-number">417</span><br>索引 <span class="hljs-number">419</span><br></code></pre></div></td></tr></table></figure><hr><h2 id="AI必知必会基础"><a href="#AI必知必会基础" class="headerlink" title="AI必知必会基础"></a>AI必知必会基础</h2><p><a href="https://easyai.tech/">面向产品经理的AI科普</a></p><h3 id="人工智能概论"><a href="#人工智能概论" class="headerlink" title="人工智能概论"></a>人工智能概论</h3><h4 id="人工智能的描述"><a href="#人工智能的描述" class="headerlink" title="人工智能的描述"></a>人工智能的描述</h4><ul><li>可以感知“环境”，并且根据环境变化做出决策或者行动，从而达成目标的程序。(AI 的所谓学习，可以被解释成一种 优化)</li><li><code>为什么GPU为机器学习提供了支撑？</code>： GPU一开始被设计成方便图形开发，在渲染图形时候需要大量浮点运算，并且GPU可以大量并行的进行浮点运算</li></ul><h4 id="弱、强、超人工智能的含义"><a href="#弱、强、超人工智能的含义" class="headerlink" title="弱、强、超人工智能的含义"></a>弱、强、超人工智能的含义</h4><ul><li>弱人工智能 指的是专注于且只能解决特定问题的AI， AlphaGo、Siri这种也只能叫弱人工智能</li><li>强人工智能 又叫完全人工智能，可以胜任人类所有工作的人工智能，目前还无法实现。<ul><li>在我看来，一方面是由于人工智能的<strong>复杂决策和对不确定因素的推理能力</strong>还不成熟，另一方面，人工智能伦理问题也难以解决。</li></ul></li><li>超人工智能 比人类社会最聪明的人还要更逆天的存在</li><li>人工智能与岗位的关系：不可避免的替代掉一部分人的工作，但在历史上也有先例，会产生更好的工作 解放人类生产力。  决策信息量小，过程简单的重复性工作，可能会被替代。</li></ul><h4 id="人工智能几个基本概念"><a href="#人工智能几个基本概念" class="headerlink" title="人工智能几个基本概念"></a>人工智能几个基本概念</h4><ul><li><p>向量 &#x3D;&gt; 二维    平面 &#x3D;&gt; 矩阵   多维 &#x3D;&gt; 张量(tensor)</p></li><li><h5 id="训练集、验证集-训练好之后用来调整参数-、测试集-用来评估"><a href="#训练集、验证集-训练好之后用来调整参数-、测试集-用来评估" class="headerlink" title="训练集、验证集(训练好之后用来调整参数)、测试集(用来评估)"></a>训练集、验证集(训练好之后用来调整参数)、测试集(用来评估)</h5><ul><li>注意，三者其实都是数据集的划分而已，并不是独立的，一般的分配比例是 6 2 2(小型系统)<ul><li>每一个数据看作一个 包， 每个包里可以有多个instance.</li></ul></li></ul></li><li><p>随机梯度下降法 Stochastic Gradient Descent</p></li></ul><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>机器学习7大步骤</p><p>收集数据 $\rightarrow$ 数据准备 $\rightarrow$ 选择模型 $\rightarrow$ 训练 $\rightarrow$ 评估 $\rightarrow$ 参数调整 $\rightarrow$ 预估</p><img src="/Users/natsumi/Library/Application Support/typora-user-images/image-20220305002212922.png" alt="image-20220305002212922" style="zoom:50%;" /><p><strong>宏观上说，还是将现实问题抽象为数学问题，并利用计算机建立模型解决，最后评估模型的合理性。从过程上说，通过训练集，不断识别和提取特征，不断完善模型，最终形成有效模型的过程，就可以称为机器学习。</strong></p><h4 id="机器学习的评估指标-以男女预测为例"><a href="#机器学习的评估指标-以男女预测为例" class="headerlink" title="机器学习的评估指标 (以男女预测为例)"></a>机器学习的评估指标 (以男女预测为例)</h4><ul><li>Accuracy<ul><li>正确数&#x2F;总预测数    问题在于样本不平衡时(比如9成样本结果一样，那么即使全预测一样的结果仍然可能取得9成的准确率)</li></ul></li><li>Precision<ul><li>以男女预测为例，这个指的是，比如预测为男的结果里，实际上确实为男的比率，而Accuracy 指的是，所有的预测结果里，预测正确的比率。</li></ul></li><li>Recall  召回率&#x2F;查全率<ul><li>实际为男的样本，确实被预测为男的概率</li><li>为什么需要这个指标：有些系统必须找出全部含有某种特征的点, 比如必须找到所有欠债的人，至于有的人没欠债却被认为欠了，没关系。</li></ul></li><li>PR曲线 &#x2F; F1分数  「将精准率和召回率做出二维曲线」<ul><li>P和R 并不能都同时达到高位，因此综合两者的表现，出现了F1分数 &#x3D; (2 x p x r) &#x2F; (p + r)</li></ul></li><li>ROC 曲线 「TP率 和 FP率 真正率 &#x2F; 假正率」<ul><li>我觉得这个不是很好懂，姑且记住 <strong>ROC曲线越陡说明模型的性能越好</strong></li></ul></li><li>AUC 曲线下面积</li></ul><p>深度学习的兴起在2006年《一种深度置信网络的快速学习算法》</p><blockquote><p>为什么深度学习和机器学习会兴起：</p><p>​    归根到底互联网行业和硬件产业的发展，互联网的迅速发展形成了大量数据，而硬件产业(尤其是GPU的不断成熟)的发展则为存储、分析这些数据成为可能。</p></blockquote><p>深度学习相比普通机器学习而言，需要更多的数据，并且受数据规范性的影响更大。</p>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>Computation tech</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vscode为什么这么多奇怪问题</title>
    <link href="/2022/02/28/Vscode%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/28/Vscode%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%A4%9A%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Vscode"><a href="#Vscode" class="headerlink" title="Vscode"></a>Vscode</h1><ul><li><h4 id="SyntaxError-Non-ASCII-character-39-xe6-39-in-file"><a href="#SyntaxError-Non-ASCII-character-39-xe6-39-in-file" class="headerlink" title="SyntaxError: Non-ASCII character &#39;\xe6&#39; in file"></a><code>SyntaxError: Non-ASCII character &#39;\xe6&#39; in file</code></h4><ul><li>解决方案：主文件输入 <code>-\*- coding: utf-8 -* </code></li><li>原理：未知</li></ul></li><li><h4 id="python无法找到本就存在的库-no-import-module-named-quot-xxx-quot"><a href="#python无法找到本就存在的库-no-import-module-named-quot-xxx-quot" class="headerlink" title="python无法找到本就存在的库  no import module named &quot;xxx&quot;"></a>python无法找到本就存在的库  <code>no import module named &quot;xxx&quot;</code></h4><ul><li><p>解决方案1： 其实是无法链接的问题，引入ssl库进行链接即可</p><ul><li>import ssl</li><li>ssl._create_default_https_context &#x3D; ssl._create_unverified_context</li></ul></li><li><p>解决方案2 ： Vscode的coderunner扩展有问题，它的默认python路径是python2.7, 所以检测不出库</p><p>在setting.json 中添加这个条目即可。</p><figure class="highlight json"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;code-runner.executorMap&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;python&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;python3 -u&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>About hexo blog</title>
    <link href="/2022/02/21/about-hexo-blog/"/>
    <url>/2022/02/21/about-hexo-blog/</url>
    
    <content type="html"><![CDATA[<h2 id="About-hexo-个人博客"><a href="#About-hexo-个人博客" class="headerlink" title="About hexo 个人博客"></a>About hexo 个人博客</h2><p><a href="https://hexo.io/zh-cn/">hexo</a>, 基于node.js的网站开发框架，无论是各种配置还是部署都足够的方便且容易。<br><a href="https://www.yousazoe.top/">我喜欢的动态图样，准备过段时间加上</a></p><p><a href="https://www.haoyizebo.com/">同样是fluid，差距有、大</a></p><blockquote><p>几个标准命令</p><ul><li>n new <ul><li>hexo new post  <code>filename</code></li><li>hexo new page <code>pagename</code></li></ul></li><li>c clean up buffet</li><li>g generate</li><li>s server (localhost4000 deploy, 是实时的)</li><li>d deploy  不要随便deploy 先在本地看一下</li></ul></blockquote><h3 id="Problem-amp-Solve"><a href="#Problem-amp-Solve" class="headerlink" title="Problem &amp; Solve"></a>Problem &amp; Solve</h3><ul><li><p>博客页面404</p><ul><li>缺少index.html 非常基础的问题<ul><li><a href="https://www.jianshu.com/p/2349c763cc02">解决方案</a></li></ul></li></ul></li><li><p>deploy失败</p><blockquote><p>一般情况下只要localhost工作正常就可不需调整，一般是服务器缓存的问题，需要等待</p></blockquote></li><li><p>tag词云</p><ul><li><p>在 package.json下添加一条依赖<code>hexo-tag-cloud :&quot;^2.1.x&quot;</code>，然后在配置文件中找到<code>tags.ejs</code></p></li><li><p>将tags.ejs 进行修改，加入词云配置，同时一些调整也是在这个ejs文件中进行的</p><ul><li>如果想调整非运动字体的大小 调整min_font 和max_font</li><li>如果要调整动画字体， 调整 width 和 height</li><li>目前使用的这个方式有点小糊， 使用css绘制有可能可以解决这个问题</li></ul><p>以下是原本的文件</p><p>&lt;%<br>page.layout &#x3D; “tags”<br>page.title &#x3D; theme.tag.title || __(‘tag.title’)<br>page.subtitle &#x3D; theme.tag.subtitle || __(‘tag.subtitle’)<br>page.banner_img &#x3D; theme.tag.banner_img<br>page.banner_img_height &#x3D; theme.tag.banner_img_height<br>page.banner_mask_alpha &#x3D; theme.tag.banner_mask_alpha</p><p>var min_font &#x3D; theme.tag.tagcloud.min_font || 15<br>var max_font &#x3D; theme.tag.tagcloud.max_font || 30<br>var unit &#x3D; theme.tag.tagcloud.unit || ‘px’<br>var start_color &#x3D; theme.tag.tagcloud.start_color || ‘#BBBBEE’<br>var end_color &#x3D; theme.tag.tagcloud.end_color || ‘#337ab7’<br>%&gt;<br>&lt;div class&#x3D;”text-center tagcloud”&gt;<br>  &lt;%- tagcloud({<br>    min_font: min_font,<br>    max_font: max_font,<br>    amount: 999,<br>    unit: unit,<br>    color: true,<br>    start_color,<br>    end_color<br>  }) %&gt;<br>&lt;&#x2F;div&gt;</p></li></ul></li><li><p>部署域名</p><ul><li>先去申请域名，在DNS解析时候记得多填入两个解析方式。</li><li>然后进入repo找到setting，选择<code>Pages</code>，然后填入你的URL即可</li></ul></li><li><p>配置域名后出现404现象</p><ul><li>问题原因: hexo d 会把public目录中的文件和目录推送到_config.yml中指定的远端仓库和分支里，并且完全覆盖该分支下已有内容。由于本地的public分支下没有CNAME文件，而我创建重定向时是在远端配置的，因此CNAME文件就被删除了，从而导致404。</li></ul></li><li><p>博客迁移</p><ul><li><p><a href="https://blog.csdn.net/y_fCrazy/article/details/111590803?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_aa&utm_relevant_index=1">由于github实在是有点太慢了，准备将整个blog迁移去gitee，但短时间内没时间弄了 先放着hh</a></p></li><li><p><a href="https://gitee.com/help/articles/4284#article-header0">github 仓库迁移至gitee的方法</a></p></li></ul></li></ul><h4 id="主题推荐："><a href="#主题推荐：" class="headerlink" title="主题推荐："></a>主题推荐：</h4><ul><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a> 非常细致的配置文件，方便调整<ul><li><a href="https://hexo.fluid-dev.com/docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97">具体教程</a></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dynamic Programming Leetcode</title>
    <link href="/2021/08/09/Chapter%202%20Dynamic%20Programming/"/>
    <url>/2021/08/09/Chapter%202%20Dynamic%20Programming/</url>
    
    <content type="html"><![CDATA[<h1 id="5-最长回文子串「Medium」"><a href="#5-最长回文子串「Medium」" class="headerlink" title="5. 最长回文子串「Medium」"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串「Medium」</a></h1><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">optimize</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; dp, string&amp; s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        dp[i][i] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; len; j++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; j; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                <span class="hljs-keyword">if</span> (j - i &lt; <span class="hljs-number">3</span>) dp[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="72-编辑距离「Hard」"><a href="#72-编辑距离「Hard」" class="headerlink" title="72. 编辑距离「Hard」"></a><a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离「Hard」</a></h1><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;<br>输出：3<br>解释：<br>horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)<br>rorse -&gt; rose (删除 &#x27;r&#x27;)<br>rose -&gt; ros (删除 &#x27;e&#x27;)<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;<br>输出：5<br>解释：<br>intention -&gt; inention (删除 &#x27;t&#x27;)<br>inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)<br>enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)<br>exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)<br>exection -&gt; execution (插入 &#x27;u&#x27;)<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><ol><li><p>状态：<code>dp[i][j]</code> 表示 <code>word1</code> 的前 <code>i</code> 个字母和 <code>word2</code> 的前 <code>j</code> 个字母之间的编辑距离。</p></li><li><p>状态转移方程：</p><ul><li>当 &#x3D;&#x3D;<code>word1[i - 1] == word2[j - 1]</code>&#x3D;&#x3D; 时，不需要转换，编辑距离为 &#x3D;&#x3D;<code>dp[i] [j] = dp[i - 1] [j - 1]</code>&#x3D;&#x3D;.</li><li>当 &#x3D;&#x3D;<code>word1[i - 1] != word2[j - 1]</code>&#x3D;&#x3D; 时，分三种情况讨论：<ul><li>插入一个字符，&#x3D;&#x3D;<code>dp[i] [j - 1]</code>&#x3D;&#x3D;：为 <code>A</code> 的前 <code>i</code> 个字符和 <code>B</code> 的前 <code>j - 1</code> 个字符编辑距离的子问题。即对于 <code>B</code> 的第 <code>j</code> 个字符，我们在 <code>A</code> 的末尾添加了一个相同的字符</li><li>删除一个字符，&#x3D;&#x3D;<code>dp[i - 1] [j]</code>&#x3D;&#x3D;：为 <code>A</code> 的前 <code>i - 1</code> 个字符和 <code>B</code> 的前 <code>j</code> 个字符编辑距离的子问题。即对于 <code>A</code> 的第 <code>i</code> 个字符，我们在 <code>B</code> 的末尾添加了一个相同的字符</li><li>替换一个字符，&#x3D;&#x3D;<code>dp[i - 1] [j - 1]</code>&#x3D;&#x3D;：为 <code>A</code> 前 <code>i - 1</code> 个字符和 <code>B</code> 的前 <code>j - 1</code> 个字符编辑距离的子问题。即对于 <code>B</code> 的第 <code>j</code> 个字符，我们修改 <code>A</code> 的第 <code>i</code> 个字符使它们相同</li></ul></li><li>对于这三种情况，我们去其中编辑距离的最小值再加一，即 &#x3D;&#x3D;<code>dp[i][j] = min(dp[i - 1] [j - 1], dp[i - 1] [j], dp[i] [j - 1]) + 1</code>&#x3D;&#x3D;.</li></ul></li><li><p>边界条件：</p><img src="/Users/wanglei/Library/Application Support/typora-user-images/image-20210206201135253.png" alt="image-20210206201135253" style="zoom:50%;" /></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        <span class="hljs-comment">// dp[i][j] 表示 word1 的前 i 个字母和 word2 的前 j 个字母之间的编辑距离。</span><br>        <span class="hljs-type">int</span> len1 = (<span class="hljs-type">int</span>)word1.<span class="hljs-built_in">length</span>(), len2 = (<span class="hljs-type">int</span>)word2.<span class="hljs-built_in">length</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len1 + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2 + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1 + <span class="hljs-number">1</span>; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len2 + <span class="hljs-number">1</span>; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len1 + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; len2 + <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示删除操作，dp[i][j-1] 表示插入操作</span><br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len1][len2];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="338-比特位计数「Medium」"><a href="#338-比特位计数「Medium」" class="headerlink" title="338. 比特位计数「Medium」"></a><a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数「Medium」</a></h1><p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p><p><strong>示例 1:</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">输入: <span class="hljs-number">2</span><br>输出: [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br></code></pre></div></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入: 5<br>输出: [0,1,1,2,1,2]<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><ol><li>状态：<code>bit[i]</code> 表示 <code>i</code> 的「比特数」</li><li>状态转移方程：对于正整数 $x$，如果可以知道最大的正整数 $y$ 使得 $y≤x$ 且 $y$ 是 $2$ 的整数次幂，则 $y$ 的二进制表示中只有最高位是 $1$，其余都是 $0$，此时称 $y$ 为 $x$ 的「最高有效位」。也就是说 <code>bit[x] = bit[y - x] + 1</code></li><li>边界条件：判断「最高有效位」看上题，<code>(i &amp; (i - 1)) == 0</code>.</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">bits</span><span class="hljs-params">(num + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> highBit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;<br>            <span class="hljs-keyword">if</span> ((i &amp; (i - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>) &#123;<br>                highBit = i;<br>            &#125;<br>            bits[i] = bits[i - highBit] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bits;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="132-分割回文串-II「Hard」"><a href="#132-分割回文串-II「Hard」" class="headerlink" title="132. 分割回文串 II「Hard」"></a><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">132. 分割回文串 II「Hard」</a></h1><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。</p><p>返回符合要求的 <strong>最少分割次数</strong> </p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：s = &quot;aab&quot;<br>输出：1<br>解释：只需一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p>&#x3D;&#x3D;Step1：定义状态&#x3D;&#x3D;</p><p>设 $f[i]$ 表示字符串的前缀 $s[0…i]$ 的<strong>最少</strong>分割次数。</p><p>&#x3D;&#x3D;Step2：状态转移方程&#x3D;&#x3D;</p><p>要想得出 $f[i]$ 的值，我们可以考虑枚举 $s[0…i]$ 分割出的最后一个回文串，这样我们就可以写出状态转移方程：</p><p>$f[i]&#x3D;min_{0≤j&lt;i}(f[j])+1$，其中 $s[j+1,i]$ 是一个回文串.</p><p>即我们枚举最后一个回文串的起始位置 $j+1$，保证 $s[j+1,i]$ 是一个回文串，那么 $f[i]$ 就可以从 $f[j]$ 转移而来，附加 $1$ 次额外的分割次数。</p><p>&#x3D;&#x3D;Step3：边界情况&#x3D;&#x3D;</p><p>注意到上面的状态转移方程中，我们还少考虑了一种情况，即 $s[0…i]$ 本身就是一个回文串。此时其不需要进行任何分割，即：$f[i]&#x3D;0$.</p><p>那么我们如何知道 $s[j+1,i]$ or  $s[0…i]$ 是否为回文串呢？我们可以使用 $dp$ 的预处理解决.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">optimize</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; dp, string&amp; s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            dp[i][i] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; len; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; j; i++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                    <span class="hljs-keyword">if</span> (j - i &lt; <span class="hljs-number">3</span>) dp[i][j] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">else</span> dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCut</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n));<br>        <span class="hljs-built_in">optimize</span>(dp, s);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n, n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (dp[<span class="hljs-number">0</span>][i]) f[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (dp[j + <span class="hljs-number">1</span>][i]) &#123;<br>                        f[i] = <span class="hljs-built_in">min</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="115-不同的子序列「Hard」"><a href="#115-不同的子序列「Hard」" class="headerlink" title="115. 不同的子序列「Hard」"></a><a href="https://leetcode-cn.com/problems/distinct-subsequences/">115. 不同的子序列「Hard」</a></h1><p>给定一个字符串 <code>s</code> 和一个字符串 <code>t</code> ，计算在 <code>s</code> 的子序列中 <code>t</code> 出现的个数。</p><p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串.</p><p>( 例如，<code>&quot;ACE&quot;</code> 是 <code>&quot;ABCDE&quot;</code> 的一个子序列，而 <code>&quot;AEC&quot;</code> 不是 )</p><p>题目数据保证答案符合 32 位带符号整数范围。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;<br>输出：3<br>解释：<br>如下图所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。<br>(上箭头符号 <span class="hljs-built_in">^</span> 表示选取的字母)<br>rabbbit<br>^^^<span class="hljs-built_in">^</span> ^^<br>rabbbit<br>^^ ^^^<span class="hljs-built_in">^</span><br>rabbbit<br>^^^ ^^^<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：s = &quot;babgbag&quot;, t = &quot;bag&quot;<br>输出：5<br>解释：<br>如下图所示, 有 5 种可以从 s 中得到 &quot;bag&quot; 的方案。 <br>(上箭头符号 <span class="hljs-built_in">^</span> 表示选取的字母)<br>babgbag<br>^^ <span class="hljs-built_in">^</span><br>babgbag<br>^^    <span class="hljs-built_in">^</span><br>babgbag<br><span class="hljs-built_in">^</span>    ^^<br>babgbag<br>  <span class="hljs-built_in">^</span>  ^^<br>babgbag<br>    ^^^<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p>Preface：</p><p>假设字符串 <code>s</code> 和 <code>t</code> 的长度分别为 <code>m</code> 和 <code>n</code>，只有当 <code>m ≥ n</code> 的时候才有意义，当 <code>m &lt; n</code> 时返回 <code>0</code>.</p><ol><li><p>定义状态</p><p>创建二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示 <code>s[i:]</code> 的子序列中 <code>t[j:]</code> 出现的个数.</p></li><li><p>状态转移方程</p><p>当 <code>i &lt; m</code> 且 <code>j &lt; n</code> 时， 我们考虑 <code>dp[i][j]</code> 的计算.</p><ul><li><p>当 <code>s[i] = t[j]</code> 时，<code>dp[i][j]</code> 由两部分组成：</p><ul><li><p>如果 <code>s[i]</code> 和 <code>t[j]</code> 匹配，则考虑 <code>t[j + 1:]</code> 作为 <code>s[i + 1:]</code> 的子序列，</p><p>子序列数为 <code>dp[i + 1][j + 1]</code>.</p></li><li><p>如果 <code>s[i]</code> 不和 <code>t[j]</code> 匹配，则考虑 <code>t[j:]</code> 作为 <code>s[i + 1:]</code> 的子序列，</p><p>子序列数为 <code>dp[i + 1][j]</code>.</p></li></ul><p>因此当 <code>s[i] = t[j]</code> 时，有 <code>dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]</code>.</p></li><li><p>当 <code>s[i] ≠ t[j]</code> 时，<code>s[i]</code> 不和 <code>t[j]</code> 匹配，因此只考虑 <code>t[j:]</code> 作为 <code>s[i + 1:]</code> 的子序列，</p><p>子序列数为 <code>dp[i + 1][j]</code>.</p><p>因此当 <code>s[i] ≠ t[j]</code> 时，<code>dp[i][j] = dp[i + 1][j]</code>.</p></li></ul><p>最终计算得到 <code>dp[0][0]</code> 即为在 <code>s</code> 的子序列中 <code>t</code> 出现的个数.</p></li><li><p>边界情况</p><ul><li>当 <code>j = n</code> 时，<code>t[j:]</code> 为空字符串，由于空字符串是任何字符串的子序列，因此对任意 <code>0 ≤ i ≤ m</code>，有 <code>dp[i][n] = 1</code>.</li><li>当 <code>i = m</code> 且 <code>j &lt; n</code> 时，<code>s[i:]</code> 为空字符串，<code>t[j:]</code> 为非空字符串，由于非空字符串不是空字符串的子序列，因此对任意 <code>0 ≤ j &lt; n</code>，有 <code>dp[m][j] = 0</code>.</li></ul></li></ol></blockquote><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(s, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(t)<br>    <span class="hljs-keyword">if</span> m &lt; n &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>        dp[i][n] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>            <span class="hljs-keyword">if</span> s[i] == t[j] &#123;<br>                dp[i][j] = dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + dp[i + <span class="hljs-number">1</span>][j]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = dp[i + <span class="hljs-number">1</span>][j]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="53-最大子序和「Easy」"><a href="#53-最大子序和「Easy」" class="headerlink" title="53. 最大子序和「Easy」"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子序和「Easy」</a></h1><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p> <strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><ol><li><p>定义状态</p><p>我们令 $f(i)$ 为以第 $i$ 个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：$max_{0≤i&lt;n}f(i)$.</p></li><li><p>状态转移方程</p><p>$f(i)&#x3D;max(f(i-1)+nums[i],nums[i])$.</p></li><li><p>无边界情况</p></li></ol><p>$DP$ 算法优化：</p><p>​    每一次的状态只与前一次的状态有关，所以可以利用「滚动数组」思想优化空间，设置一个变量 $pre$ 表示前一个解的值.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    pre, maxn := <span class="hljs-number">0</span>, nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> nums &#123;<br>        pre = max(pre + v, v)<br>        maxn = max(maxn, pre)<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxn<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="198-打家劫舍「Medium」"><a href="#198-打家劫舍「Medium」" class="headerlink" title="198. 打家劫舍「Medium」"></a><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍「Medium」</a></h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><ol><li><p>定义状态：</p><p>由于当前考虑的房屋有两种选择：「偷」和「不偷」。我们用 <code>0</code> 表示「不偷」，用 <code>1</code> 表示「偷」，即：</p><ul><li><code>dp[i][0]</code> 表示：考虑区间 <code>[0..i]</code> ，并且下标为 <code>i</code> 的这个房间不偷，能够偷窃到的最高金额；</li><li><code>dp[i][1]</code> 表示：考虑区间 <code>[0..i]</code> ，并且下标为 <code>i</code> 的这个房间偷，能够偷窃到的最高金额。</li></ul></li><li><p>状态转移方程：</p><ul><li>不偷：<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][i])</code></li><li>偷：<code>dp[i][1] = dp[i - 1][0] + nums[i]</code></li></ul></li><li><p>边界情况：</p><ul><li><code>dp[0][0] = 0</code></li><li><code>dp[0][1] = nums[0]</code></li></ul></li></ol><p>算法优化：</p><p>每层算法只与其上一层的状态有关，所以可以使用「滚动数组」来节省空间.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> norob = <span class="hljs-number">0</span>, rob = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-type">int</span> temp = norob;<br>            norob = <span class="hljs-built_in">max</span>(norob, rob);<br>            rob = temp + nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(norob, rob);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h1><p>有 <code>n</code> 种物品，物品 <code>i</code> 的体积为 $v_i$ ，价值为 $w_i$，有一个体积限制 $V$，<strong>每种物品只有 1 个，只有选或者不选</strong>，而没有选几个的问题，此问题称为 01 背包问题。</p><blockquote><ol><li><p>状态：</p><p><code>dp[i][j]</code> :&#x3D; 考虑了 <code>[0..i]</code>  里的物品，占用了 <code>j</code> 空间，所能取得的最大价值.</p></li><li><p>状态转移方程：</p><p>转移方式有两种，一种是放入，一种是不放入。</p><p>如果放，则区间 <code>[0...i-1]</code> 只能占 <code>j - v[i]</code> 空间；</p><p>如果不放，则区间 <code>[0...i-1]</code> 的物品还是占了 <code>j</code> 空间。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] 当前物品不选<br>           dp[i - <span class="hljs-number">1</span>][j - v[i]] + w[i] 当前物品选，j - v[i] 要大于等于 <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure></li><li><p>边界情况：</p><p>初始化时将所有状态置为 $0$ 即可.</p></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ZeroOnePack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; weights, vector&lt;<span class="hljs-type">int</span>&gt;&amp; values, <span class="hljs-type">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>)weights.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(capacity + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= capacity; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                dp[i][j] = j &lt; weights[i] ? <span class="hljs-number">0</span> : values[i];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &lt; weights[i]) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weights[i]] + values[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">back</span>();<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="32-最长有效括号「Hard」"><a href="#32-最长有效括号「Hard」" class="headerlink" title="32. 最长有效括号「Hard」"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号「Hard」</a></h1><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：s = &quot;(()&quot;<br>输出：2<br>解释：最长有效括号子串是 &quot;()&quot;<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：s = &quot;)()())&quot;<br>输出：4<br>解释：最长有效括号子串是 &quot;()()&quot;<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><ol><li><p>状态：</p><p><code>dp[i]</code> 表示以下标 <code>i</code> 为字符结尾的最长有效字符串的长度.</p></li><li><p>状态转移方程：</p><ul><li><p>以 <code>(</code> 结尾的子字符串不考虑，因为不可能构成合法括号</p></li><li><p><code>if s[i] == &#39;)&#39;</code></p><ul><li><p><code>s[i - 1] == &#39;(&#39;</code>，也就是字符串形如 <code>“……()”</code>，我们可以推出：<code>dp[i] = dp[i − 2] + 2</code>.</p></li><li><p><code>s[i - 1] == &#39;)&#39;</code>，也就是字符串形如 <code>“.......))”</code>，我们可以推出：</p><p><code>if s[i - dp[i - 1] - 1] == &#39;(&#39;</code>，<code>dp[i] = dp[i − 1] + dp[i − dp[i − 1] − 2] + 2</code></p><p>因为如果倒数第二个 <code>)</code>是一个有效子字符串的一部分（记为<code>subs</code>），我们此时需要判断 <code>subs</code> 前面一个符号是不是 <code>(</code> ，如果恰好是<code>(</code>，我们就用 <code>subs</code> 的长度( <code>dp[i - 1]</code> ) 加上 2 去更新<code>dp[i]</code>。除此以外，我们也会把子字符串 <code>subs</code> 前面的有效字符串的长度加上，也就是 <code>dp[i − dp[i − 1] − 2]</code>.</p></li></ul></li></ul></li><li><p>边界情况：</p><ul><li><code>i - 2</code> 有可能小于零越界了，这种情况下就是只有 <code>()</code> ，前面记为 0 就好了.</li><li><code>i - dp[i - 1] - 1</code> 和 <code>i - dp[i - 1] - 2</code> 都可能越界，越界了当成 0 来计算就可以了.</li></ul></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.length())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = (i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> ? dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br>            maxLen = <span class="hljs-built_in">fmax</span>(dp[i], maxLen);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="1143-最长公共子序列「Medium」"><a href="#1143-最长公共子序列「Medium」" class="headerlink" title="1143. 最长公共子序列「Medium」"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列「Medium」</a></h1><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> </p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; <br>输出：3  <br>解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。<br></code></pre></div></td></tr></table></figure><blockquote><p>注：本题过于经典，算法比较简单，不多赘述了.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1 <span class="hljs-type">string</span>, text2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(text1), <span class="hljs-built_in">len</span>(text2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m + <span class="hljs-number">1</span>)x2<br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>] &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])<br>            &#125; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="91-解码方法「Medium」"><a href="#91-解码方法「Medium」" class="headerlink" title="91. 解码方法「Medium」"></a><a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法「Medium」</a></h1><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">&#x27;A&#x27; -&gt; 1<br>&#x27;B&#x27; -&gt; 2<br>...<br>&#x27;Z&#x27; -&gt; 26<br></code></pre></div></td></tr></table></figure><p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li></ul><p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p><p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p><ul><li><code>s</code> 只包含数字，并且可能包含前导零。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：s = &quot;12&quot;<br>输出：2<br>解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：s = &quot;226&quot;<br>输出：3<br>解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><ol><li><p>状态：</p><p>$dp[i]$ 表示字符串的前 $i$ 个字符可能的组合数.</p></li><li><p>状态转移方程：</p><p>对于当前位 $i≠0$，则可以对前一项进行转移：<code>dp[i] += dp[i - 1]</code>.</p><p>考虑 $i$ 和 $i - 1$ 能否组成合法数字，如果可以的话也可以转移：<code>dp[i] += dp[i - 2]</code>.</p></li><li><p>边界情况：</p><p>第 $i - 1$ 位的时候要考虑是否字符 <code>&#39;0&#39;</code>，若是，则此项不进行转移；同理，第 $i - 2$ 位的时候亦是如此.</p><p>细节点：我们如何判断不合法的字符到最后一定是 $0$ 呢？</p><p>若是当前字符为 <code>&#39;0&#39;</code>，我们就不会考虑前一项了，若是前一项与当前项组成的数字也是不合法的，我们也不会做加法，因此迭代下去则会一直是零.</p></li><li><p>优化：</p><p>使用变量来代替迭代元素</p></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                dp[i] += dp[i - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> s[i - <span class="hljs-number">2</span>] != <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-built_in">and</span> ((s[i - <span class="hljs-number">2</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span> &lt;= <span class="hljs-number">26</span>)) &#123;<br>                dp[i] += dp[i - <span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// a = dp[i - 2], b = dp[i - 1], c = dp[i]</span><br>        <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, c;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            c = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                c += b;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span> &amp;&amp; s[i - <span class="hljs-number">2</span>] != <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ((s[i - <span class="hljs-number">2</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) &lt;= <span class="hljs-number">26</span>)) &#123;<br>                c += a;<br>            &#125;<br>            <span class="hljs-built_in">tie</span>(a, b) = &#123;b, c&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sliding Window Leetcode</title>
    <link href="/2021/08/09/Chapter%201%20Sliding%20Window/"/>
    <url>/2021/08/09/Chapter%201%20Sliding%20Window/</url>
    
    <content type="html"><![CDATA[<h1 id="424-替换后的最长重复字符「Medium」"><a href="#424-替换后的最长重复字符「Medium」" class="headerlink" title="424. 替换后的最长重复字符「Medium」"></a><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符「Medium」</a></h1><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 <em>k</em> 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><p><strong>注意：</strong>字符串长度 和 <em>k</em> 不会超过 $10^4$。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：s = &quot;ABAB&quot;, k = 2<br>输出：4<br>解释：用两个&#x27;A&#x27;替换为两个&#x27;B&#x27;,反之亦然。<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：s = &quot;AABABBA&quot;, k = 1<br>输出：4<br>解释：<br>将中间的一个&#x27;A&#x27;替换为&#x27;B&#x27;,字符串变为 &quot;AABBBBA&quot;。<br>子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p>​    我们可以枚举字符串中的每一个位置作为右端点，然后找到其最远的左端点的位置，满足该区间内除了出现次数最多的那一类字符之外，剩余的字符（即非最长重复字符）数量不超过 $k$ 个。</p><p>​    这样我们可以想到使用双指针维护这些区间，每次右指针右移，如果区间仍然满足条件，那么左指针不移动，否则左指针至多右移一格，保证区间长度不减小。</p><p>​    虽然这样的操作会导致部分区间不符合条件，即该区间内非最长重复字符超过了 $k$ 个。但是这样的区间也同样不可能对答案产生贡献。当我们右指针移动到尽头，左右指针对应的区间的长度必然对应一个长度最大的符合条件的区间。</p><p>​    实际代码中，由于字符串中仅包含大写字母，我们可以使用一个长度为 $26$ 的数组维护每一个字符的出现次数。每次区间右移，我们更新右移位置的字符出现的次数，然后尝试用它&#x3D;&#x3D;更新重复字符出现次数的历史最大值&#x3D;&#x3D;，最后我们&#x3D;&#x3D;使用该最大值计算出区间内非最长重复字符的数量&#x3D;&#x3D;，以此判断左指针是否需要右移即可。</p></blockquote><p>变式「Medium 简单版」：<a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">characterReplacement</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> maxn = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            num[s[right] - <span class="hljs-string">&#x27;A&#x27;</span>]++;<br>            maxn = <span class="hljs-built_in">max</span>(maxn, num[s[right] - <span class="hljs-string">&#x27;A&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> - maxn &gt; k) &#123;<br>                num[s[left] - <span class="hljs-string">&#x27;A&#x27;</span>]--;<br>                left++;<br>            &#125;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right - left;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="1423-可获得的最大点数「Medium」"><a href="#1423-可获得的最大点数「Medium」" class="headerlink" title="1423. 可获得的最大点数「Medium」"></a><a href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/">1423. 可获得的最大点数「Medium」</a></h1><p>几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。</p><p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。</p><p>你的点数就是你拿到手中的所有卡牌的点数之和。</p><p>给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。</p><p><strong>示例 1：</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">输入：cardPoints = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">12</span><br>解释：第一次行动，不管拿哪张牌，你的点数总是 <span class="hljs-number">1</span> 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 <span class="hljs-number">1</span> + <span class="hljs-number">6</span> + <span class="hljs-number">5</span> = <span class="hljs-number">12</span> 。<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">输入：cardPoints = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">4</span><br>解释：无论你拿起哪两张卡牌，可获得的点数总是 <span class="hljs-number">4</span> 。<br></code></pre></div></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">输入：cardPoints = [<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>], k = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">55</span><br>解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。<br></code></pre></div></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">输入：cardPoints = [<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 <span class="hljs-number">1</span> 。 <br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p>我们考虑到每次拿牌都是从首尾拿一张，总共拿 <code>k</code> 张，与其去想拿首或者尾的一张，那么不妨逆向思维一下，拿走 <code>k</code> 张之后还剩下 <code>n - k</code> 张，我们只需要保证剩下的 <code>n - k</code> 张牌的点数之和<strong>最小</strong>，这样就可以保证拿走的牌的点数之和最大，这样，我们就可以维护一个滑动窗口来求剩下点数的最小值。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(cardPoints []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(cardPoints)<br>    sum := <span class="hljs-number">0</span><br>    windowSize := n - k<br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> cardPoints[:windowSize] &#123;<br>        sum += val<br>    &#125;<br>    minSum := sum<br>    <span class="hljs-keyword">for</span> i := windowSize; i &lt; n; i++ &#123;<br>        sum += cardPoints[i] - cardPoints[i - windowSize]<br>        minSum = min(minSum, sum)<br>    &#125;<br>    total := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> cardPoints &#123;<br>        total += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> total - minSum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="42-接雨水「Hard」"><a href="#42-接雨水「Hard」" class="headerlink" title="42. 接雨水「Hard」"></a><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水「Hard」</a></h1><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="picture"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">输入：height = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><ol><li>我们维护两个指针分别指向首尾两端 $\Rightarrow$ $left&#x3D;0,~right&#x3D;n-1$ 以及两个变量维护左边和右边的最大高度 $\Rightarrow$ $left_most$ 和 $right_most$.</li><li>此时我们依次遍历，可以分两种情况讨论：<ul><li>当 $left_most&lt;right_most$ 时，当前位置能存储的水的最大高度取决于 $left_most$，无论中间的柱子情况如何，我们此时一定可以存储 $left_most-nums[i]$ 高度的水，直至在左边遇到高度大于 $left_most$ 的柱子，然后更新 $left_most$ 的值。</li><li>当 $left_most&gt;&#x3D;right_most$ 时，当前位置能存储的水的最大高度取决于 $right_most$，无论中间的柱子情况如何，我们此时一定可以存储 $right_most-nums[i]$ 高度的水，直至在右边遇到高度大于  $right_most$ 的柱子，然后更新 $right_most$ 的值。</li></ul></li><li>运行至 $left&#x3D;right$ 结束。</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> left_most = <span class="hljs-number">0</span>, right_most = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>                height[left] &gt;= left_most ? left_most = height[left] : count += left_most - height[left];<br>                ++left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                height[right] &gt;= right_most ? right_most = height[right] : count += right_most - height[right];<br>                --right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="76-最小覆盖子串「Hard」"><a href="#76-最小覆盖子串「Hard」" class="headerlink" title="76. 最小覆盖子串「Hard」"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串「Hard」</a></h1><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 “” 。</p><p>注意：如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;<br>输出：&quot;BANC&quot;<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p>本问题要求我们返回字符串 <code>s</code> 中包含字符串 <code>t</code> 的全部字符的<strong>最小</strong>窗口。我们称包含 <code>t</code> 的全部字母的窗口为「可行」窗口。</p><p>我们考虑使用滑动窗口来解决此问题，维护两个指针 $left$ 和 $right$，其中 &#x3D;&#x3D;$right$ 用来「延展」窗口，$left$ 用来 「收缩」窗口&#x3D;&#x3D;。</p><p>我们的遍历在字符串 <code>s</code> 中进行，会出现以下几种情况：</p><ul><li>首先，不断右移 $right$ 指针，直至目前的子串完全包含 <code>t</code> 中的所有字符.</li><li>其次，我们开始收缩 $left$ 指针，直至 $[left,~right]$ 区间内<strong>不完全</strong>包含 <code>t</code> 中所有字符，其中我们使用变量 <code>begin</code> 保存答案字符串的开头位置，<code>len</code> 表示符合条件字符串的长度.</li><li>当 $right$ 指针遍历至 <code>s</code> 的末尾，遍历结束.</li></ul><p>Details：</p><p>我们使用两个哈希表 <code>SFreq</code> 和 <code>TFreq</code> 来存储各个出现字符的次数，<code>check()</code> 函数用于判断这两个哈希表之间是否具有<strong>包含关系</strong>.</p><p><strong>算法缺陷</strong>：</p><p>每次左指针 $left$ 移动我们都需要判断两个哈希表之间的差异，造成了时间上的浪费，因此我们可以做一些优化.</p><p>&#x3D;&#x3D;优化算法&#x3D;&#x3D;：</p><p>我们使用一个变量 <code>distant</code> 来维护目前滑动窗口中出现了与 <code>t</code> 字符串中的匹配数目，当 <code>distant == tlen</code> 的时候，我们此时就可以移动 $left$ 指针了，移动的过程中更新答案字符串的开头和长度，直至 $[left,~right]$ 区间内<strong>不完全</strong>包含 <code>t</code> 中所有字符.</p><p>Details：</p><p>要清楚答案字符串的长度是 $right - left+1$ 还是 $right-left$，这个长度取决于 $right$ 的自加过程是在「收缩」阶段的前面或者后面，具体细节自己体会.</p><p><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a> 是本题的简单版，可以作为练习加深印象.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; SFreq, TFreq;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;p: TFreq) &#123;<br>            <span class="hljs-keyword">if</span> (SFreq[p.first] &lt; p.second) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; c : t) &#123;<br>            ++TFreq[c];<br>        &#125;<br>        <span class="hljs-type">int</span> begin = <span class="hljs-number">-1</span>, slen = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> len = INT_MAX;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; slen) &#123;<br>           <span class="hljs-keyword">if</span> (TFreq.<span class="hljs-built_in">count</span>(s[++right])) &#123;<br>                ++SFreq[s[right]];<br>            &#125;<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">check</span>() <span class="hljs-keyword">and</span> left &lt;= right) &#123;<br>                <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &lt; len) &#123;<br>                    len = right - left + <span class="hljs-number">1</span>;<br>                    begin = left;<br>                &#125;<br>               <span class="hljs-keyword">if</span> (TFreq.<span class="hljs-built_in">count</span>(s[left])) &#123;<br>                    --SFreq[s[left]];<br>                &#125;<br>                ++left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> begin == <span class="hljs-number">-1</span> ? <span class="hljs-built_in">string</span>() : s.<span class="hljs-built_in">substr</span>(begin, len);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>优化代码：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; SFreq, TFreq;<br>        <span class="hljs-type">int</span> slen = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">size</span>(), tlen = (<span class="hljs-type">int</span>)t.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (slen == <span class="hljs-number">0</span> || tlen == <span class="hljs-number">0</span> || slen &lt; tlen) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c : t) &#123;<br>            ++TFreq[c];<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> distant = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> len = slen + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// [left, right)</span><br>        <span class="hljs-keyword">while</span> (right &lt; slen) &#123;<br>            <span class="hljs-keyword">if</span> (TFreq[s[right]] == <span class="hljs-number">0</span>) &#123;<br>                ++right;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (SFreq[s[right]] &lt; TFreq[s[right]]) &#123;<br>                distant++;<br>            &#125;<br>            <br>            SFreq[s[right]]++;<br>            right++;<br>            <br>            <span class="hljs-keyword">while</span> (distant == tlen) &#123;<br>                <span class="hljs-keyword">if</span> (right - left &lt; len) &#123;<br>                    len = right - left;<br>                    begin = left;<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span> (TFreq[s[left]] == <span class="hljs-number">0</span>) &#123;<br>                    ++left;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span> (SFreq[s[left]] == TFreq[s[left]]) &#123;<br>                    distant--;<br>                &#125;<br>                <br>                SFreq[s[left]]--;<br>                left++;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> len == slen + <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> : s.<span class="hljs-built_in">substr</span>(begin, len);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="992-K-个不同整数的子数组「Hard」"><a href="#992-K-个不同整数的子数组「Hard」" class="headerlink" title="992. K 个不同整数的子数组「Hard」"></a><a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/">992. K 个不同整数的子数组「Hard」</a></h1><p>给定一个正整数数组 <code>A</code>，如果 <code>A</code> 的某个子数组中不同整数的个数恰好为 <code>K</code>，则称 <code>A</code> 的这个连续、不一定独立的子数组为<em>好子数组</em>。</p><p>( 例如，<code>[1,2,3,1,2]</code> 中有 <code>3</code> 个不同的整数：<code>1</code>，<code>2</code>，以及 <code>3</code>。)</p><p>返回 <code>A</code> 中<em>好子数组</em>的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：A = [1,2,1,2,3], K = 2<br>输出：7<br>解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：A = [1,2,1,3,4], K = 3<br>输出：3<br>解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].<br></code></pre></div></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= A.length &lt;= 20000</code></li><li><code>1 &lt;= A[i] &lt;= A.length</code></li><li><code>1 &lt;= K &lt;= A.length</code></li></ul><blockquote><p>算法分析：</p><p>滑动窗口的&#x3D;&#x3D;思维定势&#x3D;&#x3D;：</p><p>我们一般考虑滑动窗口的时候都是每轮循环使 $right$ 向右移动一位，然后固定 $right$，然后「收缩」$left$，但是考虑本题，$right$ 指针其实并不固定：</p><p>对于一个固定的左边界来说，满足「恰好存在 <code>K</code> 个不同整数的子区间」的右边界 <strong>不唯一</strong>，且形成区间。</p><p>示例：左边界固定的时候，恰好存在 $2$ 个不同整数的子区间为 <code>[1, 2], [1, 2, 1], [1, 2, 1, 2]</code>，总数为 $3$。</p><img src="https://pic.leetcode-cn.com/1612775858-VWbhYR-image.png" alt="picture" style="zoom:67%;" /><p>但是本题是&#x3D;&#x3D;「恰好存在 <code>K</code> 个不同整数的子区间」&#x3D;&#x3D;，所以我们需要找到左边界固定的情况下，满足「恰好存在 <code>K</code> 个不同整数的子区间」最小右边界和最大右边界。</p><p>对比以前我们做过的，使用「滑动窗口」解决的问题的问法基本都会出现「最小」、「最大」这样的字眼。那么这题如何解决呢？对此，我们可以进行一定的转换：</p><p>把「<strong>恰好</strong>」改成「<strong>最多</strong>」就可以使用双指针一前一后交替向右的方法完成，这是因为 <strong>对于每一个确定的左边界，最多包含</strong> $K$ <strong>种不同整数的右边界是唯一确定的</strong>，并且在左边界向右移动的过程中，右边界或者在原来的地方，或者在原来地方的右边。</p><p>而「最多存在 $K$ 个不同整数的子区间的个数」与「恰好存在 <code>K</code> 个不同整数的子区间的个数」的差恰好等于「最多存在 $K-1$ 个不同整数的子区间的个数」。</p><p><img src="https://pic.leetcode-cn.com/1612776085-sZFGqE-image.png" alt="picture"></p><p>因此原问题就可以转换为求解「最多存在 $K$ 个不同整数的子区间的个数」和 「最多存在 $K-1$ 个不同整数的子区间的个数」。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 主求解函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subarraysWithKDistinct</span><span class="hljs-params">(A []<span class="hljs-type">int</span>, K <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> atMostKDistinct(A, K) - atMostKDistinct(A, K - <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">atMostKDistinct</span><span class="hljs-params">(A []<span class="hljs-type">int</span>, K <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(A)<br>    <span class="hljs-comment">// count 代表 [left, right) 里不同整数的个数</span><br>    res, count, left, right := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    freq := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment">// [left, right) 包含不同整数的个数小于等于 K</span><br>    <span class="hljs-keyword">for</span> right &lt; n &#123;<br>        <span class="hljs-keyword">if</span> freq[A[right]] == <span class="hljs-number">0</span> &#123;<br>            count++<br>        &#125;<br>        <br>        freq[A[right]]++<br>        right++<br>        <br>        <span class="hljs-keyword">for</span> count &gt; K &#123;<br>            freq[A[left]]--<br>            <span class="hljs-keyword">if</span> freq[A[left]] == <span class="hljs-number">0</span> &#123;<br>                count--<br>            &#125;<br>            left++<br>        &#125;<br>        <br>        <span class="hljs-comment">// [left, right) 区间的长度就是对结果的贡献</span><br>        res += right - left<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="995-K-连续位的最小翻转次数「Hard」"><a href="#995-K-连续位的最小翻转次数「Hard」" class="headerlink" title="995. K 连续位的最小翻转次数「Hard」"></a><a href="https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/">995. K 连续位的最小翻转次数「Hard」</a></h1><p>在仅包含 <code>0</code> 和 <code>1</code> 的数组 <code>A</code> 中，一次 <code>K</code> 位翻转包括选择一个长度为 <code>K</code> 的（连续）子数组，同时将子数组中的每个 <code>0</code> 更改为 <code>1</code>，而每个 <code>1</code> 更改为 <code>0</code>。</p><p>返回所需的 <code>K</code> 位翻转的最小次数，以便数组没有值为 <code>0</code> 的元素。如果不可能，返回 <code>-1</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：A = [0,1,0], K = 1<br>输出：2<br>解释：先翻转 A[0]，然后翻转 A[2]。<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：A = [0,0,0,1,0,1,1,0], K = 3<br>输出：3<br>解释：<br>翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]<br>翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]<br>翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]<br></code></pre></div></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 30000</code></li><li><code>1 &lt;= K &lt;= A.length</code></li></ol><blockquote><p>算法分析：</p><p>&#x3D;&#x3D;<strong>方法一：差分数组</strong>&#x3D;&#x3D;</p><p>由于对同一个子数组执行两次翻转操作不会改变该子数组，所以对每个长度为 $K$ 的子数组，应至多执行一次翻转操作。</p><p>对于若干个 $K$ 位翻转操作，改变先后顺序并不影响最终翻转的结果。不妨从 $A[0]$ 开始考虑，若 $A[0]&#x3D;0$，则必定要翻转从位置 $0$ 开始的子数组；若 $A[0]&#x3D;1$，则不翻转从位置 $0$ 开始的子数组。</p><p>按照这一策略，我们从左到右地执行这些翻转操作。由于翻转操作是唯一的，若最终数组元素均为 $1$，则执行的翻转次数就是最小的。</p><p>若直接模拟上述过程，复杂度将会是 $O(NK)$ 的。考虑优化问题：</p><p>考虑不去翻转数字，而是统计每个数字需要翻转的次数。对于一次翻转操作，相当于把子数组中所有数字的翻转次数加 $1$.</p><p>这启发我们用<strong>差分数组</strong>的思想来计算当前数字需要翻转的次数。我们可以维护一个差分数组 $diff$，其中 $diff[i]$ 表示两个相邻元素 $A[i-1]$ 和 $A[i]$ 的翻转次数的差，对于区间 $[l,r]$，将其元素全部加 $1$，只会影响到 $l$ 和 $r+1$ 处的差分值，故 <code>diff[l]++ &amp;&amp; diff[r + 1]--</code>.</p><p>通过累加差分数组可以得到当前位置需要翻转的次数，我们用变量 $revCnt$ 来表示这一累加值。</p><p>遍历到 $A[i]$ 时，&#x3D;&#x3D;若 $A[i]+revCnt$ 是偶数，则说明当前元素的实际值为 $0$，需要翻转区间 $[i,i+K-1]$&#x3D;&#x3D; ，我们可以直接将 $revCnt$ 增加 $1$，$diff[i+K]$ 减少 $1$.</p><p>注意到若 $i+K&gt;n$ 则无法执行翻转操作，此时应返回 $-1$.</p><p>&#x3D;&#x3D;<strong>方法二：滑动窗口</strong>&#x3D;&#x3D;</p><p>我们考虑能否将空间复杂度简化为 $O(1)$ ?</p><p>回顾方法一的代码，当遍历到位置 $i$ 时，若能知道位置 $i-K$ 上发生了翻转操作，便可以直接修改 $revCnt$ 从而去掉 $diff$ 数组。</p><p>注意到 $0≤A[i]≤1$，我们可以&#x3D;&#x3D;用 $A[i]$ 范围<strong>之外</strong>的数来表达「是否翻转过」的含义&#x3D;&#x3D;。</p><p>具体来说，若要翻转从位置 $i$ 开始的子数组，可以将 $A[i]$ 加 $2$，这样当遍历到位置 $i’$ 时，若有 $A[i’-K]&gt;1$，则说明在位置 $i’-K$ 上发生了翻转操作。</p></blockquote><p>方法一：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minKBitFlips</span><span class="hljs-params">(A []<span class="hljs-type">int</span>, K <span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    n := <span class="hljs-built_in">len</span>(A)<br>    diff := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    revCnt := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> A &#123;<br>        revCnt += diff[i]<br>        <span class="hljs-keyword">if</span> (v + revCnt) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> i + K &gt; n &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>            &#125;<br>            ans++<br>            revCnt++<br>            diff[i + K]--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于模 $2$ 意义下的加减法与异或等价，我们也可以用异或改写上面的代码。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minKBitFlips</span><span class="hljs-params">(A []<span class="hljs-type">int</span>, K <span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    n := <span class="hljs-built_in">len</span>(A)<br>    diff := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    revCnt := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> A &#123;<br>        revCnt ^= diff[i]<br>        <span class="hljs-keyword">if</span> v == revCnt &#123; <span class="hljs-comment">// v ^ revCnt == 0</span><br>            <span class="hljs-keyword">if</span> i + K &gt; n &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>            &#125;<br>            ans++<br>            revCnt ^= <span class="hljs-number">1</span><br>            diff[i + K] ^= <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>方法二：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minKBitFlips</span><span class="hljs-params">(A []<span class="hljs-type">int</span>, K <span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    n := <span class="hljs-built_in">len</span>(A)<br>    revCnt := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> A &#123;<br>        <span class="hljs-keyword">if</span> i &gt;= K &amp;&amp; A[i - K] &gt; <span class="hljs-number">1</span> &#123;<br>            revCnt ^= <span class="hljs-number">1</span><br>            A[i - K] -= <span class="hljs-number">2</span> <span class="hljs-comment">// 复原数组元素，若允许修改数组 A，则可以省略</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> v == revCnt &#123;<br>            <span class="hljs-keyword">if</span> i + K &gt; n &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>            &#125;<br>            ans++<br>            revCnt ^= <span class="hljs-number">1</span><br>            A[i] += <span class="hljs-number">2</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="220-存在重复元素-III「Medium」"><a href="#220-存在重复元素-III「Medium」" class="headerlink" title="220. 存在重复元素 III「Medium」"></a><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/">220. 存在重复元素 III「Medium」</a></h1><p>给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和 <code>t</code> 。请你判断是否存在 <strong>两个不同下标</strong> <code>i</code> 和 <code>j</code>，使得 <code>abs(nums[i] - nums[j]) &lt;= t</code> ，同时又满足 <code>abs(i - j) &lt;= k</code>.</p><p>如果存在则返回 <code>true</code>，不存在返回 <code>false</code>.</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：nums = [1,2,3,1], k = 3, t = 0<br>输出：true<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：nums = [1,0,1,1], k = 1, t = 2<br>输出：true<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p>&#x3D;&#x3D;方法一：滑动窗口 &amp; 有序集合&#x3D;&#x3D;</p><p>根据题意，对于任意一个位置 $i$ ( 假设其值为 $u$ )，我们其实是希望在下标范围为 $[max(0,~i-k),i]$ 内找到值范围在 $[u-t,u+t]$ 的数.</p><p>因此我们可以使用一个「有序集合」去维护长度为 $k$ 的滑动窗口内的数.</p><p>每次都在「有序集合」中应用「二分查找」，找到「小于等于 $u$ 的最大值」和「大于等于 $u$ 的最小值」，即「有序集合」中的最接近 $u$ 的数。然后判断两值是否落在 $[u-t,u+t]$ 范围内.</p><p>![image-20210417135650323](&#x2F;Users&#x2F;wanglei&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210417135650323.png)</p><p>由于我们希望对「有序集合」应用「二分」，找到最接近 $u$ 的数，因此我们需要使用 $TreeSet$ 数据结构（基于红黑树，因此查找和插入都具有折半的效率），并且由于 $nums$ 中的数较大，会存在 $int$ 溢出问题，我们需要使用 $long$ 来存储.</p><ul><li>时间复杂度： $TreeSet$ 基于红黑树，查找和插入都是 $O(\log k)$ 复杂度。整体复杂度为 $O(n\log k)$.</li><li>空间复杂度：$O(k)$.</li></ul><p>&#x3D;&#x3D;方法二：桶排序&#x3D;&#x3D;</p><p>上述解法无法做到线性的原因是：我们需要在大小为 $k$ 的滑动窗口所在的「有序集合」中找到与 $u$ 接近的数.</p><p>如果我们能够将 $k$ 个数字分到 $k$ 个桶的话，那么我们就能 $O(1)$ 的复杂度确定是否有 $[u-t,u+t]$ 的数字 ( 检查目标桶是否有元素 ).</p><p>具体的做法为：令桶的大小为 $size &#x3D; t+1$，根据 $u$ 计算所在桶编号：</p><ul><li>如果已经存在该桶，说明前面已有 $[u-t,u+t]$ 的数字，返回 $true$.</li><li>如果不存在该桶，则检查相邻两个桶的元素是有 $[u-t,u+t]$ 的数字，如有返回 $true$.</li><li>建立目标桶，并删除下标范围不在 $[max(0,~i-k),i]$ 内的桶</li></ul></blockquote><p>方法一：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>        set&lt;<span class="hljs-type">long</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">auto</span> lb = st.<span class="hljs-built_in">lower_bound</span>((<span class="hljs-type">long</span>)nums[i] - t);<br>            <span class="hljs-keyword">if</span> (lb != st.<span class="hljs-built_in">end</span>() <span class="hljs-keyword">and</span> *lb &lt;= (<span class="hljs-type">long</span>)nums[i] + t) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            st.<span class="hljs-built_in">insert</span>(nums[i]);<br>            <span class="hljs-keyword">if</span> (i &gt;= k) &#123;<br>                st.<span class="hljs-built_in">erase</span>(nums[i - k]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>方法二：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">long</span> size;<br>  <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(vector &lt;<span class="hljs-type">int</span>&gt; &amp; nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        map&lt;<span class="hljs-type">long</span>, <span class="hljs-type">long</span>&gt; m;<br>        size = t + <span class="hljs-number">1L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">long</span> u = nums[i] * <span class="hljs-number">1L</span>;<br>            <span class="hljs-type">long</span> idx = <span class="hljs-built_in">getIdx</span>(u);<br>            <span class="hljs-comment">// 目标桶已存在（桶不为空），说明前面已有 [u - t, u + t] 范围的数字</span><br>            <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">find</span>(idx) != m.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 检查相邻的桶</span><br>            <span class="hljs-type">long</span> l = idx - <span class="hljs-number">1</span>, r = idx + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">find</span>(l) != m.<span class="hljs-built_in">end</span>() &amp;&amp; <span class="hljs-built_in">abs</span>(u - m[l]) &lt;= t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">find</span>(r) != m.<span class="hljs-built_in">end</span>() &amp;&amp; <span class="hljs-built_in">abs</span>(u - m[r]) &lt;= t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 建立目标桶</span><br>            m.<span class="hljs-built_in">insert</span>(&#123;idx, u&#125;);<br>            <span class="hljs-comment">// 移除下标范围不在 [max(0, i - k), i) 内的桶</span><br>            <span class="hljs-keyword">if</span> (i &gt;= k) m.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">getIdx</span>(nums[i - k]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">getIdx</span><span class="hljs-params">(<span class="hljs-type">long</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> u &gt;= <span class="hljs-number">0</span> ? u / size : (u + <span class="hljs-number">1</span>) / size - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Greedy Leetcode</title>
    <link href="/2021/08/09/Chapter%204%20Greedy/"/>
    <url>/2021/08/09/Chapter%204%20Greedy/</url>
    
    <content type="html"><![CDATA[<h1 id="1749-任意子数组和的绝对值的最大值「Medium」"><a href="#1749-任意子数组和的绝对值的最大值「Medium」" class="headerlink" title="1749. 任意子数组和的绝对值的最大值「Medium」"></a><a href="https://leetcode-cn.com/problems/maximum-absolute-sum-of-any-subarray/">1749. 任意子数组和的绝对值的最大值「Medium」</a></h1><p>给你一个整数数组 nums 。一个子数组 $[nums_l, nums_{l+1}\cdots,nums_{r-1},nums_r]$ 的 <strong>和的绝对值</strong> 为 $abs(nums_l+nums_{l+1}+\cdots+nums_{r-1}+nums_r)$.</p><p>请你找出 nums 中 <strong>和的绝对值</strong> 最大的任意子数组（<strong>可能为空</strong>），并返回该 <strong>最大值</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：nums = [1,-3,2,3,-4]<br>输出：5<br>解释：子数组 [2,3] 和的绝对值最大，为 abs(2+3) = abs(5) = 5 。<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p>我们使用一个 $sum$ 数组来保存前缀和，然后&#x3D;&#x3D;使用 $maxn$ 和 $minn$ 来保存遍历过程中前缀和的最大值和最小值&#x3D;&#x3D;，这样相当于丢弃 $maxn$ 或 $minn$ 前面的子数组，可以使得目前的 $sum[i]-maxn$ 可能得到一个较大的负值 ( 也许是正值 )，$sum[i] - minn$ 可能得到一个较大的正值 ( 也许是负值 )，然后更新答案变量即可.</p><p>值得注意的细节：</p><p>前缀和数组 $sum$ 我们申请多一个空间，这样就不需要单独判断 $0$ 这个可能溢出的点了，&#x3D;&#x3D;子区间 $[i,j]$ 的和为 $sum[j + 1]-sum[i]$&#x3D;&#x3D;.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAbsoluteSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>) nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            sum[i] = sum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, maxn = <span class="hljs-number">0</span>, minn = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">abs</span>(sum[i] - maxn));<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">abs</span>(sum[i] - minn));<br>            maxn = <span class="hljs-built_in">max</span>(maxn, sum[i]);<br>            minn = <span class="hljs-built_in">min</span>(minn, sum[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr><h1 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a><a href="https://leetcode-cn.com/problems/largest-number/">179. 最大数</a></h1><p>给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p><p><strong>注意：</strong>输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：nums = [10,2]<br>输出：&quot;210&quot;<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：nums = [3,30,34,5,9]<br>输出：&quot;9534330&quot;<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p>由题意，我们可以知道，开头位越大的数字拼接起来越大，我们可以使用排序来解决此问题.</p><p>字符串拼接容易理解，但是题目中给出的是 int 型的数据类型，这样就涉及一个基础的问题了，如何实现整数拼接？</p><p>我们可以将两个数的位数分别拉长，再将对方的数加上，最后再比大小.</p><p>举个例子： $(x&#x3D;442,<del>y&#x3D;4)</del>\Rightarrow~~ (x&#x3D;4420,<del>y&#x3D;4000)</del>\Rightarrow<del>(x&#x3D;4424,</del>y&#x3D;4442)$.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">largestNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;y) &#123;<br>            <span class="hljs-type">long</span> sx = <span class="hljs-number">10</span>, sy = <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">while</span> (sx &lt;= x) &#123;<br>                sx *= <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (sy &lt;= y) &#123;<br>                sy *= <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> sy * x + y &gt; sx * y + x;<br>        &#125;);<br>        <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        string ret;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;x : nums) &#123;<br>            ret += <span class="hljs-built_in">to_string</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about Hash map</title>
    <link href="/2021/06/03/about%20Hash%20map/"/>
    <url>/2021/06/03/about%20Hash%20map/</url>
    
    <content type="html"><![CDATA[<h1 id="Hash-map"><a href="#Hash-map" class="headerlink" title="Hash map"></a>Hash map</h1><h3 id="Notifications"><a href="#Notifications" class="headerlink" title="Notifications"></a>Notifications</h3><ul><li><h4 id="C-17-hash-table-遍历-迭代器遍历则应当注意我们不能通过迭代器更改元素值"><a href="#C-17-hash-table-遍历-迭代器遍历则应当注意我们不能通过迭代器更改元素值" class="headerlink" title="C++ 17 hash table 遍历 (迭代器遍历则应当注意我们不能通过迭代器更改元素值)"></a>C++ 17 hash table 遍历 (迭代器遍历则应当注意我们不能通过迭代器更改元素值)</h4><p>for (auto&amp; [_, c] : cnt) {            maxCnt &#x3D; max(maxCnt, c);        } &#x2F;&#x2F; first 和 second, 用 <code>_</code> 也可以不命名</p></li><li><h3 id="请务必使用-mp-count-element-来查看是否存在某个元素-使用-mp-element-存在很大问题"><a href="#请务必使用-mp-count-element-来查看是否存在某个元素-使用-mp-element-存在很大问题" class="headerlink" title="请务必使用(mp.count(element)) 来查看是否存在某个元素, 使用 !mp[element] 存在很大问题."></a>请务必使用(mp.count(element)) 来查看是否存在某个元素, 使用 !mp[element] 存在很大问题.</h3><blockquote><p>e.g <a href="https://leetcode-cn.com/problems/contiguous-array/">525. 连续数组</a></p></blockquote></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about 位运算</title>
    <link href="/2021/05/11/about%20%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2021/05/11/about%20%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="about-位运算-运算符"><a href="#about-位运算-运算符" class="headerlink" title="about 位运算 (运算符)"></a>about 位运算 (运算符)</h1><h3 id="uint32-t-32位二进制整数-一般情况下-左移就是除二"><a href="#uint32-t-32位二进制整数-一般情况下-左移就是除二" class="headerlink" title="uint32_t   32位二进制整数  一般情况下 左移就是除二"></a>uint32_t   32位二进制整数  一般情况下 左移就是除二</h3><h5 id="x-amp-x-1-可以检测是否是2的整数次幂-x-amp-x-1-可以清除最右边的1-如果这个1是第一位的1-那这个数就变为0"><a href="#x-amp-x-1-可以检测是否是2的整数次幂-x-amp-x-1-可以清除最右边的1-如果这个1是第一位的1-那这个数就变为0" class="headerlink" title="x &amp; x-1 可以检测是否是2的整数次幂  (x&amp;x-1 可以清除最右边的1,如果这个1是第一位的1, 那这个数就变为0)"></a>x &amp; x-1 可以检测是否是2的整数次幂  (x&amp;x-1 可以清除最右边的1,如果这个1是第一位的1, 那这个数就变为0)</h5><h4 id="n-amp-1-在32位下-1是-00000····001-而不是111···1-用来检测奇偶性-最后一位是否为1-偶数结果为0"><a href="#n-amp-1-在32位下-1是-00000····001-而不是111···1-用来检测奇偶性-最后一位是否为1-偶数结果为0" class="headerlink" title="n &amp; 1 (在32位下 1是 00000····001 而不是111···1)   用来检测奇偶性(最后一位是否为1)   偶数结果为0"></a>n &amp; 1 (在32位下 1是 00000····001 而不是111···1)   用来检测奇偶性(最后一位是否为1)   偶数结果为0</h4><h4 id="对于x-取其第i位的二进制-rightarrow-x-gt-gt-i-amp-1-比如在477-汉明距离总和-我们有时候可以将每一个二进制位分开来看"><a href="#对于x-取其第i位的二进制-rightarrow-x-gt-gt-i-amp-1-比如在477-汉明距离总和-我们有时候可以将每一个二进制位分开来看" class="headerlink" title="对于x , 取其第i位的二进制 $\rightarrow$ (x &gt;&gt; i) &amp; 1,  比如在477. 汉明距离总和 我们有时候可以将每一个二进制位分开来看"></a>对于x , 取其第i位的二进制 $\rightarrow$ (x &gt;&gt; i) &amp; 1,  比如在<a href="https://leetcode-cn.com/problems/total-hamming-distance/">477. 汉明距离总和</a> 我们有时候可以将每一个二进制位分开来看</h4><h3 id="builtin-popcount-i-计算32位整型里-1的个数"><a href="#builtin-popcount-i-计算32位整型里-1的个数" class="headerlink" title="__builtin_popcount(i) 计算32位整型里 1的个数"></a>__builtin_popcount(i) 计算32位整型里 1的个数</h3><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与操作，按二进制位进行”与”运算。                                                             运算规则：<code>0&amp;0=0;    0&amp;1=0;     1&amp;0=0;      1&amp;1=1;</code></td><td>(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td>|</td><td>按位或运算符，按二进制位进行”或”运算。                                                         运算规则：&#96;0</td><td>0&#x3D;0;    0</td></tr><tr><td>^</td><td>异或运算符，按二进制位进行”异或”运算。                                                         运算规则：<code>0^0=0;    0^1=1;    1^0=1;   1^1=0;</code></td><td>(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td>~</td><td>取反运算符，按二进制位进行”取反”运算。                                                         运算规则：<code>~1=-2;    ~0=1;</code></td><td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td>二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）</td><td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</td><td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr></tbody></table><h3 id="位运算也有赋值运算符"><a href="#位运算也有赋值运算符" class="headerlink" title="位运算也有赋值运算符"></a>位运算也有赋值运算符</h3><table><thead><tr><th>&lt;&lt;&#x3D;</th><th>左移且赋值运算符</th><th>C &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2</th></tr></thead><tbody><tr><td>&gt;&gt;&#x3D;</td><td>右移且赋值运算符</td><td>C &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2</td></tr><tr><td>&amp;&#x3D;</td><td>按位与且赋值运算符</td><td>C &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2</td></tr><tr><td>^&#x3D;</td><td>按位异或且赋值运算符</td><td>C ^&#x3D; 2 等同于 C &#x3D; C ^ 2</td></tr><tr><td>|&#x3D;</td><td>按位或且赋值运算符</td><td>C |&#x3D; 2 等同于 C &#x3D; C | 2</td></tr></tbody></table><h3 id="杂项运算符"><a href="#杂项运算符" class="headerlink" title="杂项运算符"></a>杂项运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>sizeof</td><td><a href="https://www.runoob.com/cplusplus/cpp-sizeof-operator.html">sizeof 运算符</a>返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。</td></tr><tr><td>Condition ? X : Y</td><td><a href="https://www.runoob.com/cplusplus/cpp-conditional-operator.html">条件运算符</a>。如果 Condition 为真 ? 则值为 X : 否则值为 Y。</td></tr><tr><td>,</td><td><a href="https://www.runoob.com/cplusplus/cpp-comma-operator.html">逗号运算符</a>会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</td></tr><tr><td>.（点）和 -&gt;（箭头）</td><td><a href="https://www.runoob.com/cplusplus/cpp-member-operators.html">成员运算符</a>用于引用类、结构和共用体的成员。</td></tr><tr><td>Cast</td><td><a href="https://www.runoob.com/cplusplus/cpp-casting-operators.html">强制转换运算符</a>把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。</td></tr><tr><td>&amp;</td><td><a href="https://www.runoob.com/cplusplus/cpp-pointer-operators.html">指针运算符 &amp;</a> 返回变量的地址。例如 &amp;a; 将给出变量的实际地址。</td></tr><tr><td>*</td><td><a href="https://www.runoob.com/cplusplus/cpp-pointer-operators.html">指针运算符 *</a> 指向一个变量。例如，*var; 将指向变量 var。</td></tr></tbody></table><h3 id="运算符优先级-「由高到低」"><a href="#运算符优先级-「由高到低」" class="headerlink" title="运算符优先级 「由高到低」"></a>运算符优先级 「由高到低」</h3><table><thead><tr><th>类别</th><th>运算符</th><th>结合性</th></tr></thead><tbody><tr><td>后缀</td><td>() [] -&gt; . ++ - -</td><td>从左到右</td></tr><tr><td>一元</td><td>+ - ! ~ ++ - - (type)* &amp; sizeof</td><td>从右到左</td></tr><tr><td>乘除</td><td>* &#x2F; %</td><td>从左到右</td></tr><tr><td>加减</td><td>+ -</td><td>从左到右</td></tr><tr><td>移位</td><td>&lt;&lt; &gt;&gt;</td><td>从左到右</td></tr><tr><td>关系</td><td>&lt; &lt;&#x3D; &gt; &gt;&#x3D;</td><td>从左到右</td></tr><tr><td>相等</td><td>&#x3D;&#x3D; !&#x3D;</td><td>从左到右</td></tr><tr><td>位与 AND</td><td>&amp;</td><td>从左到右</td></tr><tr><td>位异或 XOR</td><td>^</td><td>从左到右</td></tr><tr><td>位或 OR</td><td>|</td><td>从左到右</td></tr><tr><td>逻辑与 AND</td><td>&amp;&amp;</td><td>从左到右</td></tr><tr><td>逻辑或 OR</td><td>||</td><td>从左到右</td></tr><tr><td>条件</td><td>?:</td><td>从右到左</td></tr><tr><td>赋值</td><td>&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D;&gt;&gt;&#x3D; &lt;&lt;&#x3D; &amp;&#x3D; ^&#x3D; |&#x3D;</td><td>从右到左</td></tr><tr><td>逗号</td><td>,</td><td>从左到右</td></tr></tbody></table><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0xaaaaaaaa</span> = <span class="hljs-number">10101010101010101010101010101010</span> (偶数位为<span class="hljs-number">1</span>，奇数位为<span class="hljs-number">0</span>）<br><span class="hljs-attribute">0x55555555</span> = <span class="hljs-number">1010101010101010101010101010101</span> (偶数位为<span class="hljs-number">0</span>，奇数位为<span class="hljs-number">1</span>）<br><span class="hljs-attribute">0x33333333</span> = <span class="hljs-number">110011001100110011001100110011</span> (<span class="hljs-number">1</span>和<span class="hljs-number">0</span>每隔两位交替出现)<br><span class="hljs-attribute">0xcccccccc</span> = <span class="hljs-number">11001100110011001100110011001100</span> (<span class="hljs-number">0</span>和<span class="hljs-number">1</span>每隔两位交替出现)<br><span class="hljs-attribute">0x0f0f0f0f</span> = <span class="hljs-number">00001111000011110000111100001111</span> (<span class="hljs-number">1</span>和<span class="hljs-number">0</span>每隔四位交替出现)<br><span class="hljs-attribute">0xf0f0f0f0</span> = <span class="hljs-number">11110000111100001111000011110000</span> (<span class="hljs-number">0</span>和<span class="hljs-number">1</span>每隔四位交替出现)<br></code></pre></td></tr></table></figure><hr><h3 id="190-颠倒二进制位-「-gt-gt-x3D-和-gt-gt-的区别」"><a href="#190-颠倒二进制位-「-gt-gt-x3D-和-gt-gt-的区别」" class="headerlink" title="190. 颠倒二进制位  「&gt;&gt;&#x3D; 和 &gt;&gt; 的区别」"></a><a href="https://leetcode-cn.com/problems/reverse-bits/">190. 颠倒二进制位</a>  「&gt;&gt;&#x3D; 和 &gt;&gt; 的区别」</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// res 一开始为0, 每次我们都将 res左移, 将n右移</span><br><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>&#123;<br>        <span class="hljs-type">uint32_t</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i) &#123;<br>            res = (res &lt;&lt; <span class="hljs-number">1</span>) | (n &amp; <span class="hljs-number">1</span>);   <br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h3 id="XOR-异或运算的性质"><a href="#XOR-异或运算的性质" class="headerlink" title="XOR 异或运算的性质:"></a>XOR 异或运算的性质:</h3><ol><li><p>x⊕x&#x3D;0 ,  x⊕0 &#x3D; x</p></li><li><h4 id="x⊕y-x3D-y⊕x-交换律"><a href="#x⊕y-x3D-y⊕x-交换律" class="headerlink" title="x⊕y&#x3D;y⊕x (交换律)"></a>x⊕y&#x3D;y⊕x (交换律)</h4></li><li><p>(x⊕y)⊕z&#x3D;x⊕(y⊕z) (结合律)    「不支持分配律」</p></li><li><p>x⊕y⊕y&#x3D;x (自反性)</p></li><li><p>∀i∈Z，有 4i⊕(4i+1)⊕(4i+2)⊕(4i+3)&#x3D;0</p></li></ol><hr><h4 id="在342-4的幂-偶数位上是1的32位整形-0xaaaaaaaa"><a href="#在342-4的幂-偶数位上是1的32位整形-0xaaaaaaaa" class="headerlink" title="在342. 4的幂  偶数位上是1的32位整形, 0xaaaaaaaa"></a>在<a href="https://leetcode-cn.com/problems/power-of-four/">342. 4的幂</a>  偶数位上是1的32位整形, 0xaaaaaaaa</h4><hr><h3 id="如何取按照要求-取一个整型中的某些二进制位？"><a href="#如何取按照要求-取一个整型中的某些二进制位？" class="headerlink" title="如何取按照要求 取一个整型中的某些二进制位？"></a>如何取按照要求 取一个整型中的某些二进制位？</h3><ul><li><h4 id="对于x-取其第i位的二进制-rightarrow-x-gt-gt-i-amp-1-从0开始"><a href="#对于x-取其第i位的二进制-rightarrow-x-gt-gt-i-amp-1-从0开始" class="headerlink" title="对于x , 取其第i位的二进制 $\rightarrow$ (x &gt;&gt; i) &amp; 1 (从0开始)"></a>对于x , 取其第i位的二进制 $\rightarrow$ (x &gt;&gt; i) &amp; 1 (从0开始)</h4></li><li><p>如果我们框定了x的范围，比如我们确认x &lt;&#x3D; 1024 那么32位中必然只需要使用其中最右边的10位</p><ul><li>想取 高4位(即10位中左边的4位) 那显然 res &#x3D; x &gt;&gt; 6</li><li>想取 低6位 则不需要移位，可以通过&#x3D;&#x3D;与运算(和全1与)&#x3D;&#x3D;直接取 比如这里 2^6 -1   res &#x3D; x &amp; 63;</li></ul></li></ul><h4 id="关于进制转换问题"><a href="#关于进制转换问题" class="headerlink" title="关于进制转换问题"></a>关于进制转换问题</h4><ul><li>我们使用的进制转换是<strong>短除法</strong>的进制转换，因此最后有一个 reverse 操作，不要忘记</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetcodeNotes</title>
    <link href="/2021/05/11/LeetcodeNotes/"/>
    <url>/2021/05/11/LeetcodeNotes/</url>
    
    <content type="html"><![CDATA[<h1 id="资料库"><a href="#资料库" class="headerlink" title="资料库"></a><a href="https://github.com/bigbigwanglei/Algorithm/blob/master/Sort.md">资料库</a></h1><h1 id="leetcode-1370-上下字符串"><a href="#leetcode-1370-上下字符串" class="headerlink" title="leetcode 1370 上下字符串"></a>leetcode 1370 上下字符串</h1><p>index 从后往前遍历的时候 千万要注意 删除操作 对于index的位移</p><hr><h3 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290. 单词规律"></a><a href="https://leetcode-cn.com/problems/word-pattern/">290. 单词规律</a></h3><p><code>如果我们有 两个对象 他们必须一一对应 我们最好创建两个哈希表</code></p><p>实现这种一一对应的关系</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">    <span class="hljs-comment">//assume A is char and B is int | C is char too</span><br>    <span class="hljs-comment">//simulate A =&gt; B and C also =&gt; B</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; dict;<br>    <span class="hljs-type">char</span> A = <span class="hljs-string">&#x27;A&#x27;</span>, C = <span class="hljs-string">&#x27;C&#x27;</span>;<br>    <span class="hljs-type">int</span> B = <span class="hljs-number">17</span>;<br>    dict[B] = A;<br>    dict[B] = C;     <span class="hljs-comment">//只有 hash key是被保护的对象 被保护对象不可以重复</span><br><span class="hljs-comment">// 如果两者都是被保护对象 那只能建立两个hash table</span><br></code></pre></td></tr></table></figure><hr><ul><li><h3 id="我们将环岛划分为-n-个结点，要走过所有的结点，会漏下一段，想要求最短行进距离，只要漏下的最长即可"><a href="#我们将环岛划分为-n-个结点，要走过所有的结点，会漏下一段，想要求最短行进距离，只要漏下的最长即可" class="headerlink" title="我们将环岛划分为 n 个结点，要走过所有的结点，会漏下一段，想要求最短行进距离，只要漏下的最长即可"></a>我们将环岛划分为 n 个结点，要走过所有的结点，会漏下一段，想要求最短行进距离，只要漏下的最长即可</h3></li></ul><hr><h2 id="leetcode-387-找到第一个唯一字符"><a href="#leetcode-387-找到第一个唯一字符" class="headerlink" title="leetcode 387 找到第一个唯一字符"></a>leetcode 387 找到第一个唯一字符</h2><p>如题 我们要在一个字符串里找到<strong>第一个</strong> 不和后面任何字符重复的唯一出现一次的字符</p><ul><li>队列 + 延迟删除(每次检测到出现重复字符都会触发一个循环删除操作(当然 这其实挺慢的))</li></ul><p>由于队列的 FIFO属性 如果想找到第一个符合要求的元素 使用队列是方便的</p><hr><h3 id="2021-2-7｜665-非递减序列"><a href="#2021-2-7｜665-非递减序列" class="headerlink" title="2021. 2. 7｜665 非递减序列"></a><a href="https://leetcode-cn.com/problems/non-decreasing-array/">2021. 2. 7｜665 非递减序列</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 4 2 5</span><br><span class="hljs-comment">// 1 4 2 5</span><br><span class="hljs-comment">// 3 4 2 5  3种情况</span><br><span class="hljs-comment">// 当我们发现nums[i] &lt; nums[i-1] 时 应该优先调整num[i-1]的值 因为nums[i]变大会影响之后的判断</span><br><span class="hljs-comment">// 所以我们只需要知道 nums[i-1]最小能变到多小 显然，就是nums[i-2]的大小。</span><br><span class="hljs-comment">// 但如果nums[i]比nums[i-2]更小， 这意味着我们不得不调整nums[i]的值使得它和nums[i-1]一样。</span><br></code></pre></td></tr></table></figure><h3 id="2-7｜5674-构造字典序最大的合并字符串"><a href="#2-7｜5674-构造字典序最大的合并字符串" class="headerlink" title="2.7｜5674 构造字典序最大的合并字符串"></a><a href="https://leetcode-cn.com/problems/largest-merge-of-two-strings/">2.7｜5674 构造字典序最大的合并字符串</a></h3><blockquote><h3 id="总之两边每次都拿最大的那个，问题在于-如果说两个字符串的头都一样大，应当拿的是子字符串最大的那个-「使用-substr-i-」"><a href="#总之两边每次都拿最大的那个，问题在于-如果说两个字符串的头都一样大，应当拿的是子字符串最大的那个-「使用-substr-i-」" class="headerlink" title="总之两边每次都拿最大的那个，问题在于 如果说两个字符串的头都一样大，应当拿的是子字符串最大的那个 「使用 substr(i)」"></a>总之两边每次都拿最大的那个，问题在于 如果说两个字符串的头都一样大，应当拿的是子字符串最大的那个 「使用 substr(i)」</h3></blockquote><hr><h3 id="2-8｜978最长湍流子数组-和交替子序列比起来，这个是要求连续最长的-需要进行互相继承-优化了dp"><a href="#2-8｜978最长湍流子数组-和交替子序列比起来，这个是要求连续最长的-需要进行互相继承-优化了dp" class="headerlink" title="2.8｜978最长湍流子数组  和交替子序列比起来，这个是要求连续最长的 需要进行互相继承 优化了dp"></a>2.8｜978最长湍流子数组  和<code>交替子序列</code>比起来，这个是要求连续最长的 需要进行互相继承 优化了dp</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxTurbulenceSize</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-comment">// 摆动上升记为up，摆动下降记为down  这个其实是动态规划的优化版本</span><br>        <span class="hljs-type">int</span> up = <span class="hljs-number">1</span>, down = <span class="hljs-number">1</span>, n = arr.<span class="hljs-built_in">size</span>(), res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-comment">// 我们应当注意的是 虽然up好像被清零了，但实际上它的值被继承到了down里，它们两个是交替继承到</span><br>            <span class="hljs-comment">// 建议先完全理解动态规划方法解决这个问题</span><br>            <span class="hljs-keyword">if</span> (arr[i] == arr[i<span class="hljs-number">-1</span>]) &#123;<br>                up = <span class="hljs-number">1</span>;<br>                down = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i<span class="hljs-number">-1</span>]) &#123;<br>                up = down + <span class="hljs-number">1</span>;<br>                down = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                down = up + <span class="hljs-number">1</span>;<br>                up = <span class="hljs-number">1</span>;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">max</span>(up, down));<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-11｜703-数据流中的第K大元素-「不断的添加数据到一个数组中，我们每次都要第k大的元素」"><a href="#2-11｜703-数据流中的第K大元素-「不断的添加数据到一个数组中，我们每次都要第k大的元素」" class="headerlink" title="2.11｜703 数据流中的第K大元素  「不断的添加数据到一个数组中，我们每次都要第k大的元素」"></a>2.11｜<a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/">703 数据流中的第K大元素  「不断的添加数据到一个数组中，我们每次都要第k大的元素」</a></h3><blockquote><h3 id="只关注前K大，我们用数组中-x3D-x3D-前k大的元素组成一个最小堆，并且维持堆的大小为K-x3D-x3D-堆顶的就是目前第k大的元素-。"><a href="#只关注前K大，我们用数组中-x3D-x3D-前k大的元素组成一个最小堆，并且维持堆的大小为K-x3D-x3D-堆顶的就是目前第k大的元素-。" class="headerlink" title="只关注前K大，我们用数组中&#x3D;&#x3D;前k大的元素组成一个最小堆，并且维持堆的大小为K&#x3D;&#x3D;(堆顶的就是目前第k大的元素)。"></a>只关注前K大，我们用数组中&#x3D;&#x3D;前k大的元素组成一个最小堆，并且维持堆的大小为K&#x3D;&#x3D;(堆顶的就是目前第k大的元素)。</h3><h3 id="之后每次添加元素val，如果val比目前的堆顶小，那么它将被pop掉，如果它比堆顶要大，那么堆顶将被pop掉，第K大元素将会发生变更。"><a href="#之后每次添加元素val，如果val比目前的堆顶小，那么它将被pop掉，如果它比堆顶要大，那么堆顶将被pop掉，第K大元素将会发生变更。" class="headerlink" title="之后每次添加元素val，如果val比目前的堆顶小，那么它将被pop掉，如果它比堆顶要大，那么堆顶将被pop掉，第K大元素将会发生变更。"></a>之后每次添加元素val，如果val比目前的堆顶小，那么它将被pop掉，如果它比堆顶要大，那么堆顶将被pop掉，第K大元素将会发生变更。</h3><h5 id="初始数据-4-5-8-2-｜-第3大"><a href="#初始数据-4-5-8-2-｜-第3大" class="headerlink" title="初始数据 4 5 8 2  ｜ 第3大"></a>初始数据 4 5 8 2  ｜ 第3大</h5><h4 id="我们的堆中存有-4-5-8-，add-3的时候，3比4还小，所以它不会影响到第K大元素，-它会被放在堆顶，直接被pop掉"><a href="#我们的堆中存有-4-5-8-，add-3的时候，3比4还小，所以它不会影响到第K大元素，-它会被放在堆顶，直接被pop掉" class="headerlink" title="我们的堆中存有 4 5 8  ，add 3的时候，3比4还小，所以它不会影响到第K大元素， 它会被放在堆顶，直接被pop掉"></a>我们的堆中存有 4 5 8  ，add 3的时候，3比4还小，所以它不会影响到第K大元素， 它会被放在堆顶，直接被pop掉</h4><h4 id="如果add-的是5，-那么4会在堆顶，它现在已经不是第3大的元素了，4被pop掉。"><a href="#如果add-的是5，-那么4会在堆顶，它现在已经不是第3大的元素了，4被pop掉。" class="headerlink" title="如果add 的是5， 那么4会在堆顶，它现在已经不是第3大的元素了，4被pop掉。"></a>如果add 的是5， 那么4会在堆顶，它现在已经不是第3大的元素了，4被pop掉。</h4></blockquote><hr><h3 id="2-13｜448-找到1-n之中所有消失的数字"><a href="#2-13｜448-找到1-n之中所有消失的数字" class="headerlink" title="2.13｜448 找到1-n之中所有消失的数字"></a>2.13｜<a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">448 找到1-n之中所有消失的数字</a></h3><h4 id="题：数组大小为n，它理应包含从1-n的连续不同的数字。"><a href="#题：数组大小为n，它理应包含从1-n的连续不同的数字。" class="headerlink" title="题：数组大小为n，它理应包含从1-n的连续不同的数字。"></a>题：数组大小为n，它理应包含从1-n的连续不同的数字。</h4><h4 id="但是有一些数字出现了多次，我们现在需要用一个数组返回数组中缺失的-范围在1-n之间的数字"><a href="#但是有一些数字出现了多次，我们现在需要用一个数组返回数组中缺失的-范围在1-n之间的数字" class="headerlink" title="但是有一些数字出现了多次，我们现在需要用一个数组返回数组中缺失的 范围在1-n之间的数字"></a>但是有一些数字出现了多次，我们现在需要用一个数组返回数组中缺失的 范围在1-n之间的数字</h4><blockquote><h3 id="关键在于-x3D-x3D-数的范围和下标的范围差不多-构建的直接就是下标对应的联系-x3D-x3D"><a href="#关键在于-x3D-x3D-数的范围和下标的范围差不多-构建的直接就是下标对应的联系-x3D-x3D" class="headerlink" title="关键在于 &#x3D;&#x3D;数的范围和下标的范围差不多 构建的直接就是下标对应的联系&#x3D;&#x3D;"></a>关键在于 &#x3D;&#x3D;数的范围和下标的范围差不多 构建的直接就是下标对应的联系&#x3D;&#x3D;</h3><h4 id="nums-i-的出现-直接将-nums-nums-i-1-n-n-可以把-n去掉，可能本来就已经加上了"><a href="#nums-i-的出现-直接将-nums-nums-i-1-n-n-可以把-n去掉，可能本来就已经加上了" class="headerlink" title="nums[i] 的出现 直接将 nums[nums[i]-1] + n (%n 可以把+n去掉，可能本来就已经加上了)"></a>nums[i] 的出现 直接将 nums[nums[i]-1] + n (%n 可以把+n去掉，可能本来就已经加上了)</h4></blockquote><hr><h3 id="3-2-304-二维区域和检索-矩阵不可变"><a href="#3-2-304-二维区域和检索-矩阵不可变" class="headerlink" title="3.2 | 304. 二维区域和检索 - 矩阵不可变"></a>3.2 | <a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></h3><blockquote><p>多次调用了矩阵的前缀和,我们可以一开始就全给他算出来,改成前缀模式 这样比较省时间.</p></blockquote><h2 id="3-4-1438-绝对差不超过限制的最长连续子数组"><a href="#3-4-1438-绝对差不超过限制的最长连续子数组" class="headerlink" title="3.4 | 1438. 绝对差不超过限制的最长连续子数组"></a>3.4 | <a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a></h2><h3 id="「想要每次都拿出最大值和最小值-可以使用multiset」"><a href="#「想要每次都拿出最大值和最小值-可以使用multiset」" class="headerlink" title="「想要每次都拿出最大值和最小值 可以使用multiset」"></a>「想要每次都拿出最大值和最小值 可以使用multiset」</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ⚠️ 要求的子数组里 任意两个元素 的差 不能超过limit!! 不是相邻元素</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> limit)</span> </span>&#123;<br>        multiset&lt;<span class="hljs-type">int</span>&gt; count;   <span class="hljs-comment">// 为什么使用 multiset ? 因为我们需要保证有序 而且同时需要最大和最小元素 「这意味着堆(priority_queue 是基于队列实现的 所以不支持拿最后尾元素)的不可使用」</span><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(), left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            count.<span class="hljs-built_in">insert</span>(nums[right]); <span class="hljs-comment">//默认是从小到大排序</span><br>            <span class="hljs-keyword">while</span> (*count.<span class="hljs-built_in">rbegin</span>() - *count.<span class="hljs-built_in">begin</span>() &gt; limit) &#123;<br>                count.<span class="hljs-built_in">erase</span>(count.<span class="hljs-built_in">find</span>(nums[left++]));    <span class="hljs-comment">// multiset -&gt; erase </span><br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(right-left+<span class="hljs-number">1</span>, res);<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="3-6-503-下一个更大元素-II"><a href="#3-6-503-下一个更大元素-II" class="headerlink" title="3.6 | 503. 下一个更大元素 II"></a>3.6 | <a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h3><h3 id="1-单调栈"><a href="#1-单调栈" class="headerlink" title="1. 单调栈"></a>1. 单调栈</h3><h4 id="对于每个数都需要找到下一个比它大的元素-栈中存储的相当于一个降序的序列-只要出现一个更大的-栈中所有元素对应的下一个更大-都是它"><a href="#对于每个数都需要找到下一个比它大的元素-栈中存储的相当于一个降序的序列-只要出现一个更大的-栈中所有元素对应的下一个更大-都是它" class="headerlink" title="对于每个数都需要找到下一个比它大的元素, 栈中存储的相当于一个降序的序列 只要出现一个更大的 栈中所有元素对应的下一个更大 都是它"></a>对于每个数都需要找到下一个比它大的元素, 栈中存储的相当于一个降序的序列 只要出现一个更大的 栈中所有元素对应的下一个更大 都是它</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        stack&lt;<span class="hljs-type">int</span>&gt; tedious;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!tedious.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i % n] &gt; nums[tedious.<span class="hljs-built_in">top</span>()]) &#123;<br>                res[tedious.<span class="hljs-built_in">top</span>()] = nums[i % n];<br>                tedious.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            tedious.<span class="hljs-built_in">push</span>(i % n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="x3D-x3D-⚠️-可以通过「-capacity」-来实现对于数组的逻辑拉长-「⚠️-i-lt-2-n-1-是省了一次-不是越界」-x3D-x3D"><a href="#x3D-x3D-⚠️-可以通过「-capacity」-来实现对于数组的逻辑拉长-「⚠️-i-lt-2-n-1-是省了一次-不是越界」-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;⚠️ 可以通过「 % capacity」 来实现对于数组的逻辑拉长 「⚠️ i  &lt; 2*n-1  是省了一次 不是越界」&#x3D;&#x3D;"></a>&#x3D;&#x3D;⚠️ 可以通过「 % capacity」 来实现对于数组的逻辑拉长 「⚠️ i  &lt; 2*n-1  是省了一次 不是越界」&#x3D;&#x3D;</h3><h3 id="3-6-快速幂-本质上讲-是利用了递归的-栈逻辑-x-n-x3D-x-n-x2F-2-x-n-x2F-2-…"><a href="#3-6-快速幂-本质上讲-是利用了递归的-栈逻辑-x-n-x3D-x-n-x2F-2-x-n-x2F-2-…" class="headerlink" title="3.6 | 快速幂   本质上讲 是利用了递归的 栈逻辑  x^n &#x3D; x ^ n&#x2F;2 * x ^ n&#x2F;2 …"></a>3.6 | 快速幂   本质上讲 是利用了递归的 栈逻辑  x^n &#x3D; x ^ n&#x2F;2 * x ^ n&#x2F;2 …</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> N = n;<br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">quickMulit</span>(x, N) : <span class="hljs-number">1.0</span>/<span class="hljs-built_in">quickMulit</span>(x, -N);<br>    &#125;  <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">quickMulit</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">long</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-type">double</span> y = <span class="hljs-built_in">quickMulit</span>(x, n / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//为奇数</span><br>            <span class="hljs-keyword">return</span> x * y * y;<br>        &#125;<br>        <span class="hljs-keyword">return</span> y * y;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-9-1047-删除字符串中的所有相邻重复项"><a href="#3-9-1047-删除字符串中的所有相邻重复项" class="headerlink" title="3.9 | 1047. 删除字符串中的所有相邻重复项"></a>3.9 | <a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h3><blockquote><h3 id="利用栈的性质解题-但注意的是-string-支持-pop-back-和-back-操作-我们可以直接将其理解为一个栈来做-「同样的道理-在a-b-hard中-我们也可以这样来用string-替代掉stack」"><a href="#利用栈的性质解题-但注意的是-string-支持-pop-back-和-back-操作-我们可以直接将其理解为一个栈来做-「同样的道理-在a-b-hard中-我们也可以这样来用string-替代掉stack」" class="headerlink" title="利用栈的性质解题 但注意的是 string 支持 pop_back() 和 back()操作  我们可以直接将其理解为一个栈来做 「同样的道理, 在a+b hard中, 我们也可以这样来用string 替代掉stack」"></a>利用栈的性质解题 但注意的是 string 支持 pop_back() 和 back()操作  我们可以直接将其理解为一个栈来做 「同样的道理, 在a+b hard中, 我们也可以这样来用string 替代掉stack」</h3></blockquote><h3 id="3-9-283-移动零-「把数组中某一特定值-此处是0-的元素-全部拿到队伍的末尾去」"><a href="#3-9-283-移动零-「把数组中某一特定值-此处是0-的元素-全部拿到队伍的末尾去」" class="headerlink" title="3.9 | 283 移动零 「把数组中某一特定值(此处是0)的元素 全部拿到队伍的末尾去」"></a>3.9 | 283 移动零 「把数组中某一特定值(此处是0)的元素 全部拿到队伍的末尾去」</h3><h2 id="「快慢指针」right指针一直前进-而left指针则停留在最后一个一定需要交换来解决问题的元素上-⚠️-在left-和right-都满足的时候-两者就都自加"><a href="#「快慢指针」right指针一直前进-而left指针则停留在最后一个一定需要交换来解决问题的元素上-⚠️-在left-和right-都满足的时候-两者就都自加" class="headerlink" title="「快慢指针」right指针一直前进,而left指针则停留在最后一个一定需要交换来解决问题的元素上 (⚠️ 在left 和right 都满足的时候, 两者就都自加)"></a>「快慢指针」right指针一直前进,而left指针则停留在最后一个一定需要交换来解决问题的元素上 (⚠️ 在left 和right 都满足的时候, 两者就都自加)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZero</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums )</span> </span>&#123;<br>  <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> (right &lt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>      <span class="hljs-keyword">if</span> (nums[right]) <span class="hljs-built_in">swap</span>(nums[right], nums[left ++]);<br>      ++ right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-15-54-螺旋矩阵-螺旋输出一个矩阵"><a href="#3-15-54-螺旋矩阵-螺旋输出一个矩阵" class="headerlink" title="3.15 54. 螺旋矩阵 螺旋输出一个矩阵"></a>3.15 <a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a> 螺旋输出一个矩阵</h3><h3 id="考虑矩阵的四个角-「top-right-left-bottom-」-用这四个变量标记它们"><a href="#考虑矩阵的四个角-「top-right-left-bottom-」-用这四个变量标记它们" class="headerlink" title="考虑矩阵的四个角 「top right left bottom 」 用这四个变量标记它们"></a>考虑矩阵的四个角 「top right left bottom 」 用这四个变量标记它们</h3><ul><li><h3 id="此题由于输出的总数已经知道-我们应该设置一个恒定的标记-让它减少到0来判断是否应该结束循环-而不是加入超多的判断语句"><a href="#此题由于输出的总数已经知道-我们应该设置一个恒定的标记-让它减少到0来判断是否应该结束循环-而不是加入超多的判断语句" class="headerlink" title="此题由于输出的总数已经知道,我们应该设置一个恒定的标记 让它减少到0来判断是否应该结束循环,而不是加入超多的判断语句."></a>此题由于输出的总数已经知道,我们应该设置一个恒定的标记 让它减少到0来判断是否应该结束循环,而不是加入超多的判断语句.</h3></li></ul><hr><h3 id="3-14-检查5张牌是否为顺子-「排序后-看最大和最小-差距大于等于5-就不行啦」"><a href="#3-14-检查5张牌是否为顺子-「排序后-看最大和最小-差距大于等于5-就不行啦」" class="headerlink" title="3.14  检查5张牌是否为顺子 「排序后,看最大和最小 差距大于等于5 就不行啦」"></a>3.14  检查5张牌是否为顺子 「排序后,看最大和最小 差距大于等于5 就不行啦」</h3><h4 id="3-17-层序遍历-分层输出"><a href="#3-17-层序遍历-分层输出" class="headerlink" title="3.17  层序遍历,分层输出"></a>3.17  层序遍历,分层输出</h4><h4 id="分层的要点在于-我们在原有的while循环里加入一个for循环-对于原本就在队列中的n个结点-这个循环的目标就是把它们的孩子都加入队列-同时把它们都pop出去"><a href="#分层的要点在于-我们在原有的while循环里加入一个for循环-对于原本就在队列中的n个结点-这个循环的目标就是把它们的孩子都加入队列-同时把它们都pop出去" class="headerlink" title="分层的要点在于, 我们在原有的while循环里加入一个for循环, 对于原本就在队列中的n个结点,这个循环的目标就是把它们的孩子都加入队列, 同时把它们都pop出去."></a>分层的要点在于, 我们在原有的while循环里加入一个for循环, 对于原本就在队列中的n个结点,这个循环的目标就是把它们的孩子都加入队列, 同时把它们都pop出去.</h4><h4 id="3-17-股票的最大利润-「只可以买卖一次」「实际上就是求数组最大的元素差-其中大的元素一定要在小的后面」"><a href="#3-17-股票的最大利润-「只可以买卖一次」「实际上就是求数组最大的元素差-其中大的元素一定要在小的后面」" class="headerlink" title="3.17 股票的最大利润 「只可以买卖一次」「实际上就是求数组最大的元素差,其中大的元素一定要在小的后面」"></a>3.17 股票的最大利润 「只可以买卖一次」「实际上就是求数组最大的元素差,其中大的元素一定要在小的后面」</h4><p><code>minprice 保证了在位于 price处 时候, minprice一定是当前最小的那个值了.  而maxprice 则利用了这一点</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> price: nums) &#123;<br>      maxprofit = <span class="hljs-built_in">max</span>(maxprofit, price - minprice);<br>      minprice = <span class="hljs-built_in">min</span>(price, minprice);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-20-150-逆波兰表达式求值"><a href="#3-20-150-逆波兰表达式求值" class="headerlink" title="3.20 | 150. 逆波兰表达式求值"></a>3.20 | <a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h3><h4 id="逆波兰表达式的解法很简单-数字直接入栈-见运算符就把两个拿出来计算之后push回去-⚠️-isdigit-是对字符生效的函数-以及-stoi-字符串转int-函数-值的注意的是-没有itos-哦"><a href="#逆波兰表达式的解法很简单-数字直接入栈-见运算符就把两个拿出来计算之后push回去-⚠️-isdigit-是对字符生效的函数-以及-stoi-字符串转int-函数-值的注意的是-没有itos-哦" class="headerlink" title="逆波兰表达式的解法很简单, 数字直接入栈, 见运算符就把两个拿出来计算之后push回去.  ⚠️ isdigit 是对字符生效的函数, 以及 stoi  字符串转int 函数.  值的注意的是 没有itos 哦!"></a>逆波兰表达式的解法很简单, 数字直接入栈, 见运算符就把两个拿出来计算之后push回去.  ⚠️ isdigit 是对字符生效的函数, 以及 stoi  字符串转int 函数.  值的注意的是 没有itos 哦!</h4><hr><h4 id="3-22-爬楼梯"><a href="#3-22-爬楼梯" class="headerlink" title="3.22 | 爬楼梯"></a>3.22 | 爬楼梯</h4><h4 id="456-132-模式-「看数组里-是否有这样的三个元素-i-j-k-它们满足-i-lt-j-lt-k-同时-nums-i-lt-nums-k-lt-nums-j-」"><a href="#456-132-模式-「看数组里-是否有这样的三个元素-i-j-k-它们满足-i-lt-j-lt-k-同时-nums-i-lt-nums-k-lt-nums-j-」" class="headerlink" title="456. 132 模式  「看数组里 是否有这样的三个元素 i j k 它们满足 i &lt; j &lt; k, 同时 nums[i] &lt; nums[k] &lt; nums[j]」"></a><a href="https://leetcode-cn.com/problems/132-pattern/">456. 132 模式</a>  「看数组里 是否有这样的三个元素 i j k 它们满足 i &lt; j &lt; k, 同时 nums[i] &lt; nums[k] &lt; nums[j]」</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// i &lt; j &lt; k || nums[i] &lt; nums[k] &lt; nums[j]</span><br>    <span class="hljs-comment">// 这个题的问题在于 我们只需要知道有没有即可, 我们是不需要提供下标的!</span><br>    <span class="hljs-comment">// 不可以使用priorityqueue来存储k的所有可能性 想想为什么</span><br>   <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find132pattern</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left_min = nums[<span class="hljs-number">0</span>], j = <span class="hljs-number">1</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        multiset&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) s.<span class="hljs-built_in">insert</span>(nums[i]);<br>        <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (left_min &lt; nums[j]) &#123;<br>                <span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">begin</span>();<br>                <span class="hljs-keyword">while</span> (it != s.<span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">if</span> (*it &lt; nums[j] &amp;&amp; *it &gt; left_min) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                    ++it;<br>                &#125;<br>            &#125;<br>            s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">find</span>(nums[j+<span class="hljs-number">1</span>])); <span class="hljs-comment">//这里使用erase 会一次删除掉所有值为val的元素,</span><br>            <span class="hljs-comment">// for (auto it = s.begin(); it != s.end(); ++it) &#123;</span><br>            <span class="hljs-comment">//     if (*it == nums[j+1]) &#123;</span><br>            <span class="hljs-comment">//         *it = 1e9+1;    </span><br>            <span class="hljs-comment">//     &#125;</span><br>            <span class="hljs-comment">// &#125;</span><br>            left_min = <span class="hljs-built_in">min</span>(left_min, nums[j++]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="x3D-x3D-⚠️-1-erase-如果里面直接给出元素-会直接删除所有的该元素-也可以使用find-这样只会删除第一个遇见的-2-迭代器只是遍历工具-我们是不能通过迭代器来修改容器内的值的-x3D-x3D"><a href="#x3D-x3D-⚠️-1-erase-如果里面直接给出元素-会直接删除所有的该元素-也可以使用find-这样只会删除第一个遇见的-2-迭代器只是遍历工具-我们是不能通过迭代器来修改容器内的值的-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;⚠️ 1. erase 如果里面直接给出元素, 会直接删除所有的该元素,  也可以使用find 这样只会删除第一个遇见的. 2.迭代器只是遍历工具, 我们是不能通过迭代器来修改容器内的值的!&#x3D;&#x3D;"></a>&#x3D;&#x3D;⚠️ 1. erase 如果里面直接给出元素, 会直接删除所有的该元素,  也可以使用find 这样只会删除第一个遇见的. 2.迭代器只是遍历工具, 我们是不能通过迭代器来修改容器内的值的!&#x3D;&#x3D;</h4><h3 id="4-12-179-最大数-「一个数组-把里面的数字拼成一个-字典序最大的字符串」"><a href="#4-12-179-最大数-「一个数组-把里面的数字拼成一个-字典序最大的字符串」" class="headerlink" title="4.12 179. 最大数 「一个数组 把里面的数字拼成一个 字典序最大的字符串」"></a>4.12 <a href="https://leetcode-cn.com/problems/largest-number/">179. 最大数</a> 「一个数组 把里面的数字拼成一个 字典序最大的字符串」</h3><blockquote><p>很容易想到在匿名函数里转字符串比较字典序. </p><h4 id="但我们可以直接利用整数来尝试拼接"><a href="#但我们可以直接利用整数来尝试拼接" class="headerlink" title="但我们可以直接利用整数来尝试拼接."></a>但我们可以直接利用整数来尝试拼接.</h4></blockquote><hr><h3 id="1738-找出第K大的异或坐标值「要注意前缀和从0开始」-https-leetcode-cn-com-x2F-problems-x2F-find-kth-largest-xor-coordinate-value-x2F"><a href="#1738-找出第K大的异或坐标值「要注意前缀和从0开始」-https-leetcode-cn-com-x2F-problems-x2F-find-kth-largest-xor-coordinate-value-x2F" class="headerlink" title="[1738. 找出第K大的异或坐标值「要注意前缀和从0开始」][https://leetcode- cn.com&#x2F;problems&#x2F;find-kth-largest-xor-coordinate-value&#x2F;]"></a>[1738. 找出第K大的异或坐标值「要注意前缀和从0开始」][<a href="https://leetcode-/">https://leetcode-</a> cn.com&#x2F;problems&#x2F;find-kth-largest-xor-coordinate-value&#x2F;]</h3><p>关于二维前缀和的解释如下: </p><p>所以 <code>prefix[i][j] = prefix[i][j-1]^prefix[i-1][j]^prefix[i-1][j-1]^matrix[i-1][j-1]</code></p><hr><h3 id="在342-4的幂"><a href="#在342-4的幂" class="headerlink" title="在342. 4的幂"></a>在<a href="https://leetcode-cn.com/problems/power-of-four/">342. 4的幂</a></h3><h5 id="1-偶数位上是1的32位整形-0xaaaaaaaa"><a href="#1-偶数位上是1的32位整形-0xaaaaaaaa" class="headerlink" title="1. 偶数位上是1的32位整形, 0xaaaaaaaa"></a>1. 偶数位上是1的32位整形, 0xaaaaaaaa</h5><h5 id="2-4-n-amp-3-x3D-x3D-1-利用的是数学法"><a href="#2-4-n-amp-3-x3D-x3D-1-利用的是数学法" class="headerlink" title="2. 4^n &amp; 3 &#x3D;&#x3D; 1 利用的是数学法"></a>2. 4^n &amp; 3 &#x3D;&#x3D; 1 利用的是数学法</h5><hr><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><ul><li><h4 id="accumulate-函数，到nums-begin-k，是不包括下标k的！并且-accmulate-所需要的时间是很短的-使用accumulate来检测数组中是否只有0是一个可行的选择。"><a href="#accumulate-函数，到nums-begin-k，是不包括下标k的！并且-accmulate-所需要的时间是很短的-使用accumulate来检测数组中是否只有0是一个可行的选择。" class="headerlink" title="accumulate 函数，到nums.begin()+k，是不包括下标k的！并且 accmulate 所需要的时间是很短的  使用accumulate来检测数组中是否只有0是一个可行的选择。"></a>accumulate 函数，到nums.begin()+k，是不包括下标k的！并且 accmulate 所需要的时间是很短的  使用accumulate来检测数组中是否只有0是一个可行的选择。</h4></li><li><p>index 从后往前遍历的时候 千万要注意 删除操作 对于index的位移</p></li><li><h3 id="如何用队列实现栈-「一个队列-每次push-都把队列转个圈」-如何用栈实现队列-「两个栈-in-x2F-out-push全部进入输入栈-每次执行pop或者top操作时如果输出栈为空就把输入栈的元素全部push进输出栈」"><a href="#如何用队列实现栈-「一个队列-每次push-都把队列转个圈」-如何用栈实现队列-「两个栈-in-x2F-out-push全部进入输入栈-每次执行pop或者top操作时如果输出栈为空就把输入栈的元素全部push进输出栈」" class="headerlink" title="如何用队列实现栈?  「一个队列 每次push 都把队列转个圈」 如何用栈实现队列? 「两个栈(in &#x2F; out) push全部进入输入栈, 每次执行pop或者top操作时如果输出栈为空就把输入栈的元素全部push进输出栈」"></a>如何用队列实现栈?  「一个队列 每次push 都把队列转个圈」 如何用栈实现队列? 「两个栈(in &#x2F; out) push全部进入输入栈, 每次执行pop或者top操作时如果输出栈为空就把输入栈的元素全部push进输出栈」</h3></li><li><h3 id="c-17-添加了新的特性-对于一个hashtable-dist-「for-auto-amp-y-x-dist」-x2F-x2F-顺序和原来相同"><a href="#c-17-添加了新的特性-对于一个hashtable-dist-「for-auto-amp-y-x-dist」-x2F-x2F-顺序和原来相同" class="headerlink" title="c++ 17 添加了新的特性 对于一个hashtable dist  「for (auto &amp;[y, x] : dist」&#x2F;&#x2F; 顺序和原来相同"></a>c++ 17 添加了新的特性 对于一个hashtable dist  「for (auto &amp;[y, x] : dist」&#x2F;&#x2F; 顺序和原来相同</h3></li><li><h2 id="两个变量交换"><a href="#两个变量交换" class="headerlink" title="两个变量交换"></a>两个变量交换</h2><blockquote><p>a &#x3D; a - b; b &#x3D; b - a; a &#x3D; a + b; &#x2F;&#x2F;法1</p><h3 id="a-x3D-a-b-b-x3D-a-b-a-x3D-a-b-x2F-x2F-法2"><a href="#a-x3D-a-b-b-x3D-a-b-a-x3D-a-b-x2F-x2F-法2" class="headerlink" title="a &#x3D; a ^ b ; b &#x3D; a ^ b; a &#x3D; a ^ b;  &#x2F;&#x2F; 法2"></a>a &#x3D; a ^ b ; b &#x3D; a ^ b; a &#x3D; a ^ b;  &#x2F;&#x2F; 法2</h3></blockquote></li></ul><h4 id="·想要返回正确的double值，把被除数转成double型，而不是把结果转为double"><a href="#·想要返回正确的double值，把被除数转成double型，而不是把结果转为double" class="headerlink" title="·想要返回正确的double值，把被除数转成double型，而不是把结果转为double"></a>·想要返回正确的double值，把被除数转成double型，而不是把结果转为double</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">return</span> <span class="hljs-built_in">double</span>(<span class="hljs-number">3</span>/<span class="hljs-number">2</span>) =&gt; <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">double</span>(<span class="hljs-number">3</span>)/<span class="hljs-number">2</span> =&gt; <span class="hljs-number">1.5</span><br></code></pre></td></tr></table></figure><ul><li><p>字符与int之间的转化是简单的,  只需要加减<code>&#39;0&#39; </code> 就可以了,   字符串则可以通过 stoi 和 to_string 函数来实现! </p></li><li><p>斐波那契数列 在n特别大时 采取矩阵快速幂的方法 能够求解 (滚动都太慢了)</p></li><li><h2 id="gt-操作符-和-操作符的区别-「-gt-左边是指针-左边是实体」-p-gt-a-p是指针-p-a-p是实体"><a href="#gt-操作符-和-操作符的区别-「-gt-左边是指针-左边是实体」-p-gt-a-p是指针-p-a-p是实体" class="headerlink" title="-&gt; 操作符 和 . 操作符的区别 「-&gt; 左边是指针  . 左边是实体」 (p -&gt; a()  p是指针,  p.a()  p是实体)"></a><code>-&gt;</code> 操作符 和 <code>.</code> 操作符的区别 「-&gt; 左边是指针  . 左边是实体」 <code>(p -&gt; a()  p是指针,  p.a()  p是实体)</code></h2></li><li></li><li><p><code>nth_element(res.begin(), res.begin() + k, res.end(), greater&lt;int&gt;()). </code> 寻找res中第k大的元素, 并将它放在第k个位置(默认是第k小)  「处理完之后,  K之前的全都比他大, K之后的全部比它小(比排序快上一点)」</p></li><li><p>STL copy </p><p>std::copy(start, end, container.begin());    &#x2F;&#x2F; container 是复制到的那个容器的第一个元素， 因为复制到这个已有元素后更加高效</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about string</title>
    <link href="/2021/04/20/about%20string%20/"/>
    <url>/2021/04/20/about%20string%20/</url>
    
    <content type="html"><![CDATA[<h1 id="about-string-字符串"><a href="#about-string-字符串" class="headerlink" title="about string 字符串"></a>about string 字符串</h1><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span> == #<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span> <span class="hljs-comment">//他们都是c语言的字符串库 ⚠️ 它们是不能定义string的 但可以使用字符串函数(如 strcpy)</span></span><br><br><span class="hljs-type">char</span>* <span class="hljs-type">char</span>[] <span class="hljs-comment">//都可以通过赋值 直接传给字符串对象 但字符串转到char[] 需要用data()或c_str()</span><br><br>string a, b<br><br>a.<span class="hljs-built_in">compare</span>(b); <span class="hljs-comment">//cmp函数 a和b相同返回0 a和b不同返回-1</span><br><br>a.<span class="hljs-built_in">find</span>(b); <span class="hljs-comment">// 寻找的是字符串</span><br><br>a.<span class="hljs-built_in">substr</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">// 从下标3开始 截取2个字符.</span><br>a.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 从下标2开始的所有字符 (包括2).</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Backtrack Leetcode</title>
    <link href="/2021/04/17/Chapter%207%20Backtrack/"/>
    <url>/2021/04/17/Chapter%207%20Backtrack/</url>
    
    <content type="html"><![CDATA[<h1 id="51-N-皇后「Hard」"><a href="#51-N-皇后「Hard」" class="headerlink" title="51. N 皇后「Hard」"></a><a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后「Hard」</a></h1><p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。皇后彼此不能相互攻击，也就是说：&#x3D;&#x3D;任何两个皇后都不能处于同一条横行、纵行或斜线上&#x3D;&#x3D;。</p><p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p><p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="picture"></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：n = 4<br>输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]<br>解释：如上图所示，4 皇后问题存在两个不同的解法。<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p><strong>方法一：基于集合的回溯</strong></p><p>为了判断一个位置所在的列和两条斜线上是否已经有皇后，使用三个集合 $columns,<del>diagonals1,</del>diagonals2$ 分别记录每一列以及两个方向的每条斜线上是否有皇后。</p><p>列的表示法很直观，一共有 $N$ 列，每一列的下标范围从 $0$ 到 $N-1$，使用列的下标即可明确表示每一列。</p><p>如何表示两个方向的斜线呢？对于每个方向的斜线，需要找到斜线上的每个位置的行下标与列下标之间的关系。</p><p>方向一的斜线为从左上到右下方向，同一条斜线上的每个位置满足<strong>行下标与列下标之差相等</strong>，例如 $(0,0)$ 和 $(3,3)$ 在同一条方向一的斜线上。因此使用行下标与列下标之差即可明确表示每一条方向一的斜线。</p><p><img src="https://assets.leetcode-cn.com/solution-static/51/1.png" alt="picture"></p><p>方向二的斜线为从右上到左下方向，同一条斜线上的每个位置满足<strong>行下标与列下标之和相等</strong>，例如 $(3,0)$ 和 $(1,2)$ 在同一条方向二的斜线上。因此使用行下标与列下标之和即可明确表示每一条方向二的斜线。</p><p><img src="https://assets.leetcode-cn.com/solution-static/51/2.png" alt="picture"></p><p>每次放置皇后时，对于每个位置判断其是否在三个集合中，如果三个集合都不包含当前位置，则当前位置是可以放置皇后的位置。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-keyword">auto</span> solutions = vector&lt;vector&lt;string&gt;&gt;();<br>        <span class="hljs-keyword">auto</span> queens = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">auto</span> columns = <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-keyword">auto</span> diagonals1 = <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-keyword">auto</span> diagonals2 = <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-built_in">backtrack</span>(solutions, queens, n, <span class="hljs-number">0</span>, columns, diagonals1, diagonals2);<br>        <span class="hljs-keyword">return</span> solutions;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt; &amp;solutions, vector&lt;<span class="hljs-type">int</span>&gt; &amp;queens, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, unordered_set&lt;<span class="hljs-type">int</span>&gt; &amp;columns, unordered_set&lt;<span class="hljs-type">int</span>&gt; &amp;diagonals1, unordered_set&lt;<span class="hljs-type">int</span>&gt; &amp;diagonals2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            vector&lt;string&gt; board = <span class="hljs-built_in">generateBoard</span>(queens, n);<br>            solutions.<span class="hljs-built_in">push_back</span>(board);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (columns.<span class="hljs-built_in">find</span>(i) != columns.<span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> diagonal1 = row - i;<br>                <span class="hljs-keyword">if</span> (diagonals1.<span class="hljs-built_in">find</span>(diagonal1) != diagonals1.<span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> diagonal2 = row + i;<br>                <span class="hljs-keyword">if</span> (diagonals2.<span class="hljs-built_in">find</span>(diagonal2) != diagonals2.<span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                queens[row] = i;<br>                columns.<span class="hljs-built_in">insert</span>(i);<br>                diagonals1.<span class="hljs-built_in">insert</span>(diagonal1);<br>                diagonals2.<span class="hljs-built_in">insert</span>(diagonal2);<br>                <span class="hljs-built_in">backtrack</span>(solutions, queens, n, row + <span class="hljs-number">1</span>, columns, diagonals1, diagonals2);<br>                queens[row] = <span class="hljs-number">-1</span>;<br>                columns.<span class="hljs-built_in">erase</span>(i);<br>                diagonals1.<span class="hljs-built_in">erase</span>(diagonal1);<br>                diagonals2.<span class="hljs-built_in">erase</span>(diagonal2);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateBoard</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;queens, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> board = <span class="hljs-built_in">vector</span>&lt;string&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            string row = <span class="hljs-built_in">string</span>(n, <span class="hljs-string">&#x27;.&#x27;</span>);<br>            row[queens[i]] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            board.<span class="hljs-built_in">push_back</span>(row);<br>        &#125;<br>        <span class="hljs-keyword">return</span> board;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="90-子集-II「Hard」"><a href="#90-子集-II「Hard」" class="headerlink" title="90. 子集 II「Hard」"></a><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II「Hard」</a></h1><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：nums = [1,2,2]<br>输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：nums = [0]<br>输出：[[],[0]]<br></code></pre></div></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; t;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">bool</span> choosePre, <span class="hljs-type">int</span> cur, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(t);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-literal">false</span>, cur + <span class="hljs-number">1</span>, nums);<br>        <span class="hljs-keyword">if</span> (!choosePre &amp;&amp; cur &gt; <span class="hljs-number">0</span> &amp;&amp; nums[cur - <span class="hljs-number">1</span>] == nums[cur]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        t.<span class="hljs-built_in">push_back</span>(nums[cur]);<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-literal">true</span>, cur + <span class="hljs-number">1</span>, nums);<br>        t.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about Dynamic Programming</title>
    <link href="/2021/04/15/about%20DP/"/>
    <url>/2021/04/15/about%20DP/</url>
    
    <content type="html"><![CDATA[<h1 id="about-Dynamic-Programming-「DP-x2F-动态规划」"><a href="#about-Dynamic-Programming-「DP-x2F-动态规划」" class="headerlink" title="about Dynamic Programming 「DP&#x2F;动态规划」"></a>about Dynamic Programming 「DP&#x2F;动态规划」</h1><p>子问题最优则原始问题最优——贪心算法或者动态规划算法。<br>子问题最优则原始问题最优，且子问题互相独立——分治算法。<br>子问题最优不能推导出原始问题最优——暴力搜索等。</p><p>如果子问题最优则原问题最优，贪心算法。<br>如果子问题需要全部求解才能求解原问题，子问题互相独立，分治算法。<br>如果子问题最优不能保证原问题最优，但是子问题之间不会循环（所谓循环，是指从问题 A 拆解出子问题 B，然后子问题 B 又能拆解出子问题 A），考虑动态规划算法。<br>更加复杂的情况，我们总是可以考虑暴力搜索解决。</p><p>分治「Divide and Conquer Algorithm 」</p><p>值的注意的是 : 贪心算法在解决01背包问题的时候错误很明显 所以你最好能够证明这个题可以使用贪心算法. </p><p>分治和动态规划的思想区别本质在于: 分治的子问题毫无关联, 而动态规划则是子问题的嵌套「所以需要状态转移方程」</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划:"></a>动态规划:</h3><h3 id="在不问最优解-只问最优值的时候-可以尝试动态规划"><a href="#在不问最优解-只问最优值的时候-可以尝试动态规划" class="headerlink" title="在不问最优解 只问最优值的时候 可以尝试动态规划"></a>在不问最优解 只问最优值的时候 可以尝试动态规划</h3><ol><li><p>递归 直接基于状态转移方程来实现 </p></li><li><p>自顶向下(记忆化) 相当于是查表 「重叠子结构」</p></li><li><p>自底向上(迭代)  </p><ol><li><p>有了状态转移方程，我们就知道如何从最小的问题规模入手，然后不断地增加问题规模，直到所要求的问题规模为止。在这个过程中，我们同样地可以记忆每个问题规模的解来避免重复的计算。这种方法就是自底向上的方法，由于避免了递归，这是一种更好的办法。</p><p>但是迭代法需要有一个明确的迭代方向，例如线性，区间，树形，状态压缩等比较主流的动态规划问题中，迭代方向都有相应的模式。参考后面的例题。但是有一些问题迭代法方向是不确定的，这时可以退而求其次用记忆化来做，参考后面的例题。</p></li></ol></li></ol><h3 id="动态规划存在无后效性的原则-「状态必须是确定的」"><a href="#动态规划存在无后效性的原则-「状态必须是确定的」" class="headerlink" title="动态规划存在无后效性的原则 「状态必须是确定的」"></a>动态规划存在无后效性的原则 「状态必须是确定的」</h3><h4 id="e-g-丢n枚硬币-我们求其中k个朝上的概率是多少"><a href="#e-g-丢n枚硬币-我们求其中k个朝上的概率是多少" class="headerlink" title="e.g. 丢n枚硬币, 我们求其中k个朝上的概率是多少"></a>e.g. 丢n枚硬币, 我们求其中k个朝上的概率是多少</h4><h4 id="设立矩阵-p-i-j-其中i代表丢下第i枚硬币-j代表-其中在这次丢硬币之前有-j-枚朝上"><a href="#设立矩阵-p-i-j-其中i代表丢下第i枚硬币-j代表-其中在这次丢硬币之前有-j-枚朝上" class="headerlink" title="设立矩阵 p[i] [j] 其中i代表丢下第i枚硬币, j代表 其中在这次丢硬币之前有 j 枚朝上"></a>设立矩阵 p[i] [j] 其中i代表丢下第i枚硬币, j代表 其中在这次丢硬币<em>之前</em>有 j 枚朝上</h4><h4 id="显然-我们有这样的状态转移方程-p-i-j-x3D-p-i-1-j-1-0-5-p-i-1-j-0-5"><a href="#显然-我们有这样的状态转移方程-p-i-j-x3D-p-i-1-j-1-0-5-p-i-1-j-0-5" class="headerlink" title="显然 我们有这样的状态转移方程:  p[i] [j] &#x3D; p[i-1] [j-1] * 0.5 + p[i-1] [j] * 0.5"></a>显然 我们有这样的状态转移方程:  p[i] [j] &#x3D; p[i-1] [j-1] * 0.5 + p[i-1] [j] * 0.5</h4><h4 id="现在我们改变问题-当连续两次丢下硬币都朝着一面的时候-下一次丢硬币一定会是另一面-因为我们的状态里没有包含前两次的结果-所以显然刚才的状态方程是错误的-如果想要使用动态规划-这里应该添加两个维度-来存储上一次-和上上次的结果"><a href="#现在我们改变问题-当连续两次丢下硬币都朝着一面的时候-下一次丢硬币一定会是另一面-因为我们的状态里没有包含前两次的结果-所以显然刚才的状态方程是错误的-如果想要使用动态规划-这里应该添加两个维度-来存储上一次-和上上次的结果" class="headerlink" title="现在我们改变问题  当连续两次丢下硬币都朝着一面的时候,  下一次丢硬币一定会是另一面.  因为我们的状态里没有包含前两次的结果, 所以显然刚才的状态方程是错误的,  如果想要使用动态规划, 这里应该添加两个维度, 来存储上一次 和上上次的结果."></a>现在我们改变问题  当连续两次丢下硬币都朝着一面的时候,  下一次丢硬币一定会是另一面.  因为我们的状态里没有包含前两次的结果, 所以显然刚才的状态方程是错误的,  如果想要使用动态规划, 这里应该添加两个维度, 来存储上一次 和上上次的结果.</h4><h3 id="动态规划的最优子结构-「在设计状态的时候-我们应当保证最优的状态只从之前的最优状态来-而不是从之前的非最优状态来」"><a href="#动态规划的最优子结构-「在设计状态的时候-我们应当保证最优的状态只从之前的最优状态来-而不是从之前的非最优状态来」" class="headerlink" title="动态规划的最优子结构 「在设计状态的时候, 我们应当保证最优的状态只从之前的最优状态来, 而不是从之前的非最优状态来」"></a>动态规划的最优子结构 「在设计状态的时候, 我们应当保证最优的状态只从之前的最优状态来, 而不是从之前的非最优状态来」</h3><h4 id="比如01背包问题-如果我们加入一个条件-某两件物品一起拿能够产生额外价值-那么就不适用动态规划了"><a href="#比如01背包问题-如果我们加入一个条件-某两件物品一起拿能够产生额外价值-那么就不适用动态规划了" class="headerlink" title="比如01背包问题, 如果我们加入一个条件, 某两件物品一起拿能够产生额外价值,  那么就不适用动态规划了."></a>比如01背包问题, 如果我们加入一个条件, 某两件物品一起拿能够产生额外价值,  那么就不适用动态规划了.</h4><h3 id="重叠子结构"><a href="#重叠子结构" class="headerlink" title="重叠子结构"></a>重叠子结构</h3><p>比如在解斐波那契的时候 , 我们加入一个dp[n], 存储每一次的答案, 不需要重复计算,</p><h3 id="动态规划例题"><a href="#动态规划例题" class="headerlink" title="动态规划例题:"></a>动态规划例题:</h3><h4 id="1-编辑距离-II-在编辑距离的基础上-不允许插入操作-这意味着在A删除和在B删除是有区别的"><a href="#1-编辑距离-II-在编辑距离的基础上-不允许插入操作-这意味着在A删除和在B删除是有区别的" class="headerlink" title="1. 编辑距离 II 在编辑距离的基础上, 不允许插入操作, 这意味着在A删除和在B删除是有区别的"></a>1. 编辑距离 II 在编辑距离的基础上, 不允许插入操作, 这意味着在A删除和在B删除是有区别的</h4><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 在A中删除一个字符 或者替换</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">edit_distance</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>(), m = t.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">if</span> (!(n * m)) <span class="hljs-keyword">return</span> m + n;<br>        <br>        <span class="hljs-comment">// 请务必注意dp边界的初始化 请一定要注意</span><br>        <span class="hljs-type">int</span> dp[n+<span class="hljs-number">1</span>][m+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) dp[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) dp[<span class="hljs-number">0</span>][i] = i;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (s[i<span class="hljs-number">-1</span>] == t[j<span class="hljs-number">-1</span>]) dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                <span class="hljs-comment">// 问题就在于 s的子串长度一定要超过 t 的子串长度. 否则不应删减掉</span><br>                <span class="hljs-keyword">else</span> dp[i][j] = i &gt; j ? <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j])+<span class="hljs-number">1</span> : dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];   <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-打家劫舍I-「给定一个序列-我们不能连着偷相邻的两家-求我们能获取的最大利润是多少」"><a href="#2-打家劫舍I-「给定一个序列-我们不能连着偷相邻的两家-求我们能获取的最大利润是多少」" class="headerlink" title="2. 打家劫舍I 「给定一个序列, 我们不能连着偷相邻的两家, 求我们能获取的最大利润是多少」"></a>2. 打家劫舍I 「给定一个序列, 我们不能连着偷相邻的两家, 求我们能获取的最大利润是多少」</h3><blockquote><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</p></blockquote><blockquote><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</p></blockquote><h4 id="思路-四种DP的方式-「无非就是从增加维度控制后效性-rightarrow-不增加维度的dp优化」"><a href="#思路-四种DP的方式-「无非就是从增加维度控制后效性-rightarrow-不增加维度的dp优化」" class="headerlink" title="思路: 四种DP的方式  「无非就是从增加维度控制后效性 $\rightarrow$ 不增加维度的dp优化」"></a>思路: 四种DP的方式  「无非就是从增加维度控制后效性 $\rightarrow$ 不增加维度的dp优化」</h4><ol><li><h5 id="2维DP-dp-i-0-代表不偷第-i-间-前i间房能获取的最大利润-dp-i-1-则是偷第i间-显然-dp-i-0-x3D-max-dp-i-1-1-dp-i-1-0-而dp-i-1-x3D-dp-i-1-0-nums-i-因为偷这一间意味着上一间肯定不能偷啦"><a href="#2维DP-dp-i-0-代表不偷第-i-间-前i间房能获取的最大利润-dp-i-1-则是偷第i间-显然-dp-i-0-x3D-max-dp-i-1-1-dp-i-1-0-而dp-i-1-x3D-dp-i-1-0-nums-i-因为偷这一间意味着上一间肯定不能偷啦" class="headerlink" title="2维DP dp[i] [0] 代表不偷第 i 间, 前i间房能获取的最大利润  dp[i] [1]则是偷第i间. 显然 dp[i] [0] &#x3D; max(dp[i-1] [1], dp[i-1] [0]), 而dp[i] [1] &#x3D; dp[i-1] [0] + nums[i] (因为偷这一间意味着上一间肯定不能偷啦 )"></a>2维DP dp[i] [0] 代表不偷第 i 间, 前i间房能获取的最大利润  dp[i] [1]则是偷第i间. 显然 dp[i] [0] &#x3D; max(dp[i-1] [1], dp[i-1] [0]), 而dp[i] [1] &#x3D; dp[i-1] [0] + nums[i] (因为偷这一间意味着上一间肯定不能偷啦 )</h5></li><li><h4 id="1维DP-法1"><a href="#1维DP-法1" class="headerlink" title="1维DP 法1"></a>1维DP 法1</h4><ul><li><em><strong>这种思路是错误的</strong></em> 「我们通过dp[i-1」和dp[i-2]是否相同来判断是否可以偷第[i]间, 但是问题就在于, 每两间房必会偷一间, 但显然, 这种方式无法每次都找到最优解.</li></ul></li><li><h4 id="1维DP-法2"><a href="#1维DP-法2" class="headerlink" title="1维DP 法2"></a>1维DP 法2</h4><ul><li><h5 id="dp-i-确实有两种情况-1-不偷-dp-i-x3D-dp-i-1-显然-上一个房间也不一定非要偷-2-偷-dp-i-x3D-dp-i-2-nums-i"><a href="#dp-i-确实有两种情况-1-不偷-dp-i-x3D-dp-i-1-显然-上一个房间也不一定非要偷-2-偷-dp-i-x3D-dp-i-2-nums-i" class="headerlink" title="dp[i] 确实有两种情况  1. 不偷 dp[i] &#x3D; dp[i-1] (显然, 上一个房间也不一定非要偷)  2. 偷 dp[i] &#x3D; dp[i-2] + nums[i];"></a>dp[i] 确实有两种情况  1. 不偷 dp[i] &#x3D; dp[i-1] (显然, 上一个房间也不一定非要偷)  2. 偷 dp[i] &#x3D; dp[i-2] + nums[i];</h5></li><li><h5 id="所以dp-i-x3D-max-dp-i-1-dp-i-2-nums-i"><a href="#所以dp-i-x3D-max-dp-i-1-dp-i-2-nums-i" class="headerlink" title="所以dp[i] &#x3D; max(dp[i-1], dp[i-2]+nums[i])"></a>所以dp[i] &#x3D; max(dp[i-1], dp[i-2]+nums[i])</h5></li></ul></li><li><h4 id="0维DP-直接上代码-两个变量相互继承-有点类似之前做过的最长湍流子数组-是吗"><a href="#0维DP-直接上代码-两个变量相互继承-有点类似之前做过的最长湍流子数组-是吗" class="headerlink" title="0维DP 直接上代码 两个变量相互继承, 有点类似之前做过的最长湍流子数组? 是吗"></a>0维DP 直接上代码 两个变量相互继承, 有点类似之前做过的最长湍流子数组? 是吗</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <br>        <span class="hljs-type">int</span> rob = nums[<span class="hljs-number">0</span>], nrob = nums[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> temp = rob;<br>            rob = <span class="hljs-built_in">max</span> (rob, nrob);<br>            nrob = temp + nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(rob, nrob);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="打家截舍II-现在第一间房屋和最后一间房屋连起来-偷第一间就不可以偷最后一间"><a href="#打家截舍II-现在第一间房屋和最后一间房屋连起来-偷第一间就不可以偷最后一间" class="headerlink" title="打家截舍II  现在第一间房屋和最后一间房屋连起来 偷第一间就不可以偷最后一间"></a>打家截舍II  现在第一间房屋和最后一间房屋连起来 偷第一间就不可以偷最后一间</h3><blockquote><p>改变区间就可以了. 如果偷第一家 就把最后一家从区间中去掉.  (根据一维dp法2来做)</p></blockquote></li></ol><h2 id="3-预测赢家-「给定一组牌-数组-我们只能从最后或者最前面拿牌-玩家1先手-我们-希望能在给定序列的情况下-提前知道玩家1是否可以赢-假设两名玩家都绝顶聪明-」"><a href="#3-预测赢家-「给定一组牌-数组-我们只能从最后或者最前面拿牌-玩家1先手-我们-希望能在给定序列的情况下-提前知道玩家1是否可以赢-假设两名玩家都绝顶聪明-」" class="headerlink" title="3. 预测赢家 「给定一组牌(数组), 我们只能从最后或者最前面拿牌, 玩家1先手, 我们 希望能在给定序列的情况下, 提前知道玩家1是否可以赢(假设两名玩家都绝顶聪明)」"></a>3. 预测赢家 「给定一组牌(数组), 我们只能从最后或者最前面拿牌, 玩家1先手, 我们 希望能在给定序列的情况下, 提前知道玩家1是否可以赢(假设两名玩家都绝顶聪明)」</h2><h3 id="此题出现了-dp-i-由-dp-i-1-和-dp-i-2-推导而来的情况-我们需要通过一个矩阵来解决这个问题-麻烦画一下-现在我懒得画了-其实比较容易"><a href="#此题出现了-dp-i-由-dp-i-1-和-dp-i-2-推导而来的情况-我们需要通过一个矩阵来解决这个问题-麻烦画一下-现在我懒得画了-其实比较容易" class="headerlink" title="此题出现了 dp[i]由 dp[i+1] 和 dp[i+2] 推导而来的情况, 我们需要通过一个矩阵来解决这个问题. 麻烦画一下 现在我懒得画了 其实比较容易."></a>此题出现了 dp[i]由 dp[i+1] 和 dp[i+2] 推导而来的情况, 我们需要通过一个矩阵来解决这个问题. 麻烦画一下 现在我懒得画了 其实比较容易.</h3><blockquote><h4 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1"></a>示例1</h4><p>输入：[1, 5, 2]<br>输出：False<br>解释：一开始，玩家1可以从1和2中进行选择。<br>如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。<br>所以，玩家 1 的最终分数为 1 + 2 &#x3D; 3，而玩家 2 为 5 。<br>因此，玩家 1 永远不会成为赢家，返回 False 。</p><h4 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2"></a>示例2</h4><p>输入：[1, 5, 233, 7]<br>输出：True<br>解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。<br>     最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// dp[i][j] 表示玩家1 在牌i到牌j可以拿到的最大分数; 最终的结果是 dp[i][nums.size()-1]</span><br>    <span class="hljs-comment">// dp[i][j] = max (left, right);  left -&gt; 拿左边的, right -&gt; 拿右边的</span><br>    <span class="hljs-comment">// left = min(dp[i+1][j-1], dp[i+2][j]) + nums[i] 站在玩家2的角度上思考,他必然选择最优解, 这意味着玩家1之后将拿到的只能是最小值. </span><br>    <span class="hljs-comment">// right = min(dp[i+1][j-1], dp[i][j-2]) + nums[j];</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PredictTheWinner</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(), sum = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) dp[i][i] = nums[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) dp[i][i+<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[i], nums[i+<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">3</span>; l &lt;= n; ++l) &#123;<br>            <span class="hljs-comment">//l作为长度, 最开始至少有3三张, 我们从前3张卡开始,不断的向外扩散</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + l - <span class="hljs-number">1</span> &lt; n; ++i) &#123;<br>                <span class="hljs-type">int</span> j = i + l - <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> left = <span class="hljs-built_in">min</span>(dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>], dp[i+<span class="hljs-number">2</span>][j]) + nums[i];<br>                <span class="hljs-type">int</span> right = <span class="hljs-built_in">min</span>(dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>], dp[i][j<span class="hljs-number">-2</span>]) + nums[j];<br>                dp[i][j] = <span class="hljs-built_in">max</span>(left, right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>] &gt;= sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>备注：当手牌为奇数的时候，先手必胜。</p><hr><h2 id="4-礼物的最大价值-「有的时候-我们可以直接在原数组上dp-不需要空间」"><a href="#4-礼物的最大价值-「有的时候-我们可以直接在原数组上dp-不需要空间」" class="headerlink" title="4. 礼物的最大价值 「有的时候 我们可以直接在原数组上dp, 不需要空间」"></a>4. 礼物的最大价值 「有的时候 我们可以直接在原数组上dp, 不需要空间」</h2><h4 id="剑指offer-47-在一个-m-n-的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于-0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？"><a href="#剑指offer-47-在一个-m-n-的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于-0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？" class="headerlink" title="剑指offer 47 :在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？"></a>剑指offer 47 :在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>(), n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j];</span><br>        <span class="hljs-comment">// vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n));</span><br>        <span class="hljs-comment">// // 我从左上角拿 那也意味着想要顺着边拿只能一直往下或一直往右.</span><br>        <span class="hljs-comment">// dp[0][0] = grid[0][0];</span><br>        <span class="hljs-comment">// for (int i = 1; i &lt; m; ++i) dp[i][0] = dp[i-1][0] + grid[i][0];</span><br>        <span class="hljs-comment">// for (int i = 1; i &lt; n; ++i) dp[0][i] = dp[0][i-1] + grid[0][i];</span><br>        <span class="hljs-comment">// for (int i = 1; i &lt; m; ++i) &#123;</span><br>        <span class="hljs-comment">//     for (int j = 1; j &lt; n; ++j) &#123;</span><br>        <span class="hljs-comment">//         dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j];</span><br>        <span class="hljs-comment">//     &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// return dp[m-1][n-1];</span><br>        <br>        <span class="hljs-comment">// 我们可以直接用grid数组本身代替dp数组 以下为优化方案. </span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i) grid[i][<span class="hljs-number">0</span>] += grid[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) grid[<span class="hljs-number">0</span>][i] += grid[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; ++j) grid[i][j] += <span class="hljs-built_in">max</span>(grid[i<span class="hljs-number">-1</span>][j], grid[i][j<span class="hljs-number">-1</span>]);<br>        <span class="hljs-keyword">return</span> grid[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Binary Search Leetcode</title>
    <link href="/2021/04/08/Chapter%208%20Binary%20Search/"/>
    <url>/2021/04/08/Chapter%208%20Binary%20Search/</url>
    
    <content type="html"><![CDATA[<h1 id="33-搜索旋转排序数组「Medium」"><a href="#33-搜索旋转排序数组「Medium」" class="headerlink" title="33. 搜索旋转排序数组「Medium」"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组「Medium」</a></h1><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，</p><p>使数组变为 <code>[nums[k], nums[k + 1], ..., nums[n - 1], nums[0], nums[1], ...,nums[k - 1]]</code>（下标 <strong>从 0 开始</strong> 计数）</p><p>例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：nums = [4,5,6,7,0,1,2], target = 0<br>输出：4<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：nums = [4,5,6,7,0,1,2], target = 3<br>输出：-1<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p>对于有序数组，可以使用二分查找的方法查找元素。</p><p>但是这道题中，数组本身不是有序的，进行旋转后只保证了数组的局部是有序的，这还能进行二分查找吗？答案是可以的。</p><p>可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从 <code>6</code> 这个位置分开以后数组变成了 <code>[4, 5, 6]</code> 和 <code>[7, 0, 1, 2]</code> 两个部分，其中左边 <code>[4, 5, 6]</code> 这个部分的数组是有序的，其他也是如此。</p><p>这启示我们可以在常规二分查找的时候查看当前 <code>mid</code> 为分割位置分割出来的两个部分 <code>[l, mid]</code> 和 <code>[mid + 1, r]</code> 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 <code>target</code> 在不在这个部分：</p><ul><li>如果 <code>[l, mid - 1]</code> 是有序数组，且 <code>target</code> 的大小满足 <code>[nums[l], nums[mid])</code> 则我们应该将搜索范围缩小至 <code>[l, mid - 1]</code>，否则在 <code>[mid + 1, r]</code> 中寻找。</li><li>如果 <code>[mid, r]</code> 是有序数组，且 <code>target</code> 的大小满足 <code>(nums[mid], nums[r]]</code> 则我们应该将搜索范围缩小至 <code>[mid + 1, r]</code>，否则在 <code>[l, mid - 1]</code> 中寻找。</li></ul><p><img src="https://assets.leetcode-cn.com/solution-static/33/33_fig1.png" alt="picture"></p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-keyword">if</span> (!numsSize) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (numsSize == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target ? <span class="hljs-number">0</span> : <span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = numsSize - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 本题的二分是只在有序数组那一边的范围里找 target</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (nums[mid] == target) <span class="hljs-keyword">return</span> mid;<br>        <br>        <span class="hljs-keyword">if</span> (nums[left] &lt;= nums[mid]) &#123; <span class="hljs-comment">// 左边为升序排序数组</span><br>            <span class="hljs-keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 右边为升序数组</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>变式：</strong> 数组中的值可以重复</p><blockquote><p>算法分析：</p><p>对于数组中有重复元素的情况，二分查找时可能会有 <code>nums[l] = nums[mid] = nums[right] </code> 此时无法判断区间 <code>[left, mid]</code> 和区间 <code>[mid + 1, right]</code> 哪个是有序的。</p><p>对于这种情况，我们只能将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-keyword">if</span> (!numsSize) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (numsSize == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = numsSize - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (nums[mid] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (nums[left] == nums[mid] &amp;&amp; nums[mid] == nums[right]) &#123;<br>            ++left;<br>            --right;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[left] &lt;= nums[mid]) &#123; <br>            <span class="hljs-keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="153-寻找旋转排序数组中的最小值「Medium」"><a href="#153-寻找旋转排序数组中的最小值「Medium」" class="headerlink" title="153. 寻找旋转排序数组中的最小值「Medium」"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值「Medium」</a></h1><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> </p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：nums = [3,4,5,1,2]<br>输出：1<br>解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p>一个不包含重复元素的升序数组在经过旋转之后，可以得到下面可视化的折线图：</p><p><img src="https://assets.leetcode-cn.com/solution-static/153/1.png" alt="picture"></p><p>其中横轴表示数组元素的下标，纵轴表示数组元素的值。图中标出了最小值的位置，是我们需要查找的目标.</p><p>​    我们考虑<strong>数组中的最后一个元素</strong> $x$：在最小值右侧的元素 ( 不包括最后一个元素本身 )，它们的值一定都严格小于 $x$ 而在最小值左侧的元素，它们的值一定都严格大于 $x$. 因此，我们可以根据这一条性质，通过二分查找的方法找出最小值.</p><p>​    在二分查找的每一步中，左边界为 $low$，右边界为 $high$，区间的中点为 $pivot$，最小值就在该区间内. 我们将中轴元素 $nums[pivot]$ 与右边界元素 $nums[high]$ 进行比较，可能会有以下的三种情况：</p><p>​    第一种情况是 $nums[pivot]&lt;nums[high]$. 如下图所示，这说明 $nums[pivot]$ 是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分.</p><p><img src="https://assets.leetcode-cn.com/solution-static/153/2.png" alt="picture"></p><p>​    第二种情况是 $nums[pivot]&gt;nums[high]$. 如下图所示，这说明 $nums[pivot]$ 是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分.</p><p><img src="https://assets.leetcode-cn.com/solution-static/153/3.png" alt="picture"></p><p>由于数组不包含重复元素，并且只要当前的区间长度不为 $1$，$pivot$ 就不会与 $high$ 重合；而如果当前的区间长度为 $1$ ，这说明我们已经可以结束二分查找了。因此不会存在 $nums[pivot]&#x3D;nums[high]$ 的情况.</p><p>当二分查找结束时，我们就得到了最小值所在的位置.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">findMin</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span> &#123;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = numsSize - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> pivot = low + (high - low) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[pivot] &lt; nums[high]) &#123;<br>            high = pivot;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            low = pivot + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[low];<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about Binary Search</title>
    <link href="/2021/04/07/about%20Binary%20Search%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2021/04/07/about%20Binary%20Search%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="about-Binary-Search-二分查找"><a href="#about-Binary-Search-二分查找" class="headerlink" title="about Binary Search 二分查找"></a>about Binary Search 二分查找</h1><h3 id="普通的二分查找"><a href="#普通的二分查找" class="headerlink" title="普通的二分查找"></a>普通的二分查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinarySearch_nonrecursive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;  <span class="hljs-comment">//不加 = 如果数组长度为1 会错</span><br>        <span class="hljs-type">int</span> mid = (left + right)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//递归 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinarySearch_recursive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (nums[mid] &gt; target) <span class="hljs-keyword">return</span> <span class="hljs-built_in">BinarySearch_recursive</span>(nums, target, left, mid - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target) <span class="hljs-keyword">return</span> <span class="hljs-built_in">BinarySearch_recursive</span>(nums, target, mid + <span class="hljs-number">1</span>, right);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="如果你只想要二分查找找到的第一个："><a href="#如果你只想要二分查找找到的第一个：" class="headerlink" title="如果你只想要二分查找找到的第一个："></a>如果你只想要二分查找找到的第一个：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BinarySearch_First_nonrecursive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123; <span class="hljs-comment">//查找第一个</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = (left + right)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[left] == target ? left : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>(l + r + 1) &gt;&gt; 1; 进阶的 (r - l)&#x2F;2 + l;</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about vector</title>
    <link href="/2021/04/05/about%20vector/"/>
    <url>/2021/04/05/about%20vector/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; a,b; <span class="hljs-comment">//缺省所有参数时 size直接为0的</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">a</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span> <span class="hljs-comment">//注意不使用[] 使用()来选定大小 值默认为0</span><br><br><span class="hljs-built_in">vector</span>&lt;&gt;::reverse_iterator i;<span class="hljs-comment">//在STL库中定义反向迭代器 </span><br><span class="hljs-comment">//迭代器可以用来遍历，反向迭代器++之后往前移动 通过加*号的迭代器 也可以直接访问数组元素的值(作为在STL中封装好的指针来使用)</span><br>begin(),end(),rbegin(),rend(); <span class="hljs-comment">//后两个的意思</span><br><br>a.assign(b.begin(),b.begin()+<span class="hljs-number">3</span>); <span class="hljs-comment">//b数组的前3个元素分给a</span><br>a.assign(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//4个2</span><br><br>a.back(); a.front(); a[i]; a.clear(); a.empty(); a.pop_back();<br><br><span class="hljs-comment">//删除a中第一个（从第0个算起）到第二个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+3（不包括它）结束</span><br>a.erase(a.begin()+<span class="hljs-number">1</span>,a.begin()+<span class="hljs-number">3</span>);<br>a.push_back(); a.emplace_back(); <span class="hljs-comment">//两者一样功能 建议使用emplace 优化内存 c++11可以使用</span><br><br>a.insert(a.begin()+<span class="hljs-number">1</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">//第一个参数就是插入值之后这个值在数组里的下标！注意使用迭代器(前插)</span><br>a.insert(a.begin()+<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">//可以连续插入多个一样的 插入个数是第二个参数</span><br>a.inse3rt(a.begin()+<span class="hljs-number">1</span>,b+<span class="hljs-number">3</span>,b+<span class="hljs-number">6</span>); <span class="hljs-comment">//b是数组，在1号下标插入 b的[3,6)下标元素(不包括最后一个)</span><br><br>a.size();a.capacity(); <span class="hljs-comment">//返回数组大小 由于在空间不够时vector每次都直接扩大一倍，size返回的是元素的个数 而capacity返回的是现在vector能容纳多少个元素</span><br><br>a.resize(<span class="hljs-number">10</span>); <span class="hljs-comment">//把长度变成10 多删 少补(值随机)</span><br>a.resize(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//与上面的区别在于补的数值默认为2</span><br>a.reserve(<span class="hljs-number">100</span>); <span class="hljs-comment">//注意和reverse区分 注意：reserve是保留空间，但不创建对象(resize的可以直接调用)</span><br><br><br>a.swap(b); <span class="hljs-comment">//交换向量a和b</span><br><span class="hljs-comment">//b为向量，向量的比较操作还有 != &gt;= &gt; &lt;= &lt;</span><br>a==b;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(a.begin(), a.begin()+k) ; 我们可以通过这个语句 来返回数组的 前k项<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><ol><li><p><strong>vector 没有length() 函数</strong></p></li><li><p>&#x3D;&#x3D;<strong>vector 只能push_back 和 pop_back 从头插入 使用insert(a.begin(), value)</strong>&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;<strong>所有的STL返回整型 全部都是 unsigned long 我们需要在前面加括号 用int型接收它们</strong>&#x3D;&#x3D;</p></li><li><p><strong>size 和 capicity 大部分时候不需要关注</strong></p></li><li><p>&#x3D;&#x3D;在你直接初始化一个二维数组时 你可以使用memset 也可以这样&#x3D;&#x3D;</p><p>&#x3D;&#x3D;<code>vector&lt;vector&lt;int&gt;&gt; (5, vector&lt;int&gt;(6,1))</code> 显然 这里用了套娃的属性&#x3D;&#x3D;</p></li><li><p><strong>少使用push_back() 要使用emplace_back();</strong></p></li><li><p>**vector&lt;pair &lt;int, int&gt; &gt; 或者 vector&lt;vector&lt;int,int&gt; &gt;(在用sort比较时 会先比较first 如果first相同，再比较second **</p></li></ol></blockquote><ul><li>关于<code>pair</code> <ul><li>Pair 定义有序对 是结构体 调用使用 <code>.first</code> 和 <code>.second</code> 比较时也是先比较first 再比较second</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stack Leetcode</title>
    <link href="/2021/03/24/Chapter%203%20Stack/"/>
    <url>/2021/03/24/Chapter%203%20Stack/</url>
    
    <content type="html"><![CDATA[<h1 id="84-柱状图中最大的矩形「Hard」"><a href="#84-柱状图中最大的矩形「Hard」" class="headerlink" title="84. 柱状图中最大的矩形「Hard」"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形「Hard」</a></h1><p>给定 <code>n</code> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 <code>1</code> 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png" alt="picture"></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" alt="pictture"></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</p><p><strong>示例:</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入: [2,1,5,6,2,3]<br>输出: 10<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p>枚举「宽」的暴力法这里就不再过多赘述了。</p><p>&#x3D;&#x3D;算法引入&#x3D;&#x3D;：</p><p>我们对枚举「高」来做一些分析以及优化。</p><p>对枚举「高」的暴力法就是对每一条「高」进行中心扩展：</p><ul><li>首先我们枚举某一根柱子 $i$ 作为高 $h&#x3D;height[i]$.</li><li>随后我们需要进行向左右两边扩展，使得扩展到的柱子的高度均不小于 $h$，也就是说，我们需要找到<strong>左右两侧最近的高度小于 $h$ 的柱子</strong>，这两根柱子之间的所有柱子的高度均不小于 $h$，这就是 $i$ 能扩展的最远范围.</li></ul><p>对于上述分析我们可知，我们可以使用<strong>单调栈</strong>来维护左边和右边的高度依赖关系。由分析可知，我们需要查找的是距离 $i$ 最近比 $h$ 低的柱子，所以我们可以维护一个单调递增的栈，每次只需要查找对比栈顶元素与当前的柱子高度，进行 $pop$ 操作和 $push$ 操作即可。</p><p>&#x3D;&#x3D;单调栈的算法如下&#x3D;&#x3D;：</p><ul><li>当我们枚举到第 $i$ 根柱子时，我们从栈顶不断移除 $height[j]&gt;height[i]$ 的 $j$ 值。在移除完毕后，栈顶元素的 $j$ 值就一定满足 $height[j]&lt;height[i]$，此时 $j$ 就是 $i$ 左侧且最近的小于其高度的柱子。</li><li>这里会有一种特殊情况。如果我们移除了栈中所有的 $j$ 值，说明 $i$ 左侧所有柱子的高度都大于 $height[i]$，那么我们可以认为 $i$ 左侧且最近的小于其高度的柱子在位置 $j&#x3D;-1$，它是一根「虚拟」的、高度无限低的柱子。这样的定义不会对我们的答案产生任何的影响，我们也称这根「虚拟」的柱子为「哨兵」。</li><li>最后我们将 $i$ 这根柱子入栈。</li></ul><p>Details：</p><p>我们在栈中存放的是柱子的下标而非柱子高度。</p><p>最后求面积为 <code>maxArea = max(maxArea, (right[i] - left[i] - 1) * heights[i])</code>，具体下标的长度需要注意。</p><p>本题还能进行常数优化 $\Rightarrow$ 一次遍历，这里就不提了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxArea = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>)heights.<span class="hljs-built_in">size</span>();<br>        stack&lt;<span class="hljs-type">int</span>&gt; min_stack;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(n)</span>, <span class="hljs-title">right</span><span class="hljs-params">(n)</span></span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!min_stack.<span class="hljs-built_in">empty</span>() <span class="hljs-keyword">and</span> heights[i] &lt;= heights[min_stack.<span class="hljs-built_in">top</span>()]) &#123;<br>                min_stack.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            left[i] = min_stack.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : min_stack.<span class="hljs-built_in">top</span>();<br>            min_stack.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <br>        min_stack = <span class="hljs-built_in">stack</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">while</span> (!min_stack.<span class="hljs-built_in">empty</span>() <span class="hljs-keyword">and</span> heights[i] &lt;= heights[min_stack.<span class="hljs-built_in">top</span>()]) &#123;<br>                min_stack.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            right[i] = min_stack.<span class="hljs-built_in">empty</span>() ? n : min_stack.<span class="hljs-built_in">top</span>();<br>            min_stack.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            maxArea = <span class="hljs-built_in">max</span>(maxArea, (right[i] - left[i] - <span class="hljs-number">1</span>) * heights[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="503-下一个更大元素-II「Medium」"><a href="#503-下一个更大元素-II「Medium」" class="headerlink" title="503. 下一个更大元素 II「Medium」"></a><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II「Medium」</a></h1><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 $x$ 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 $-1$.</p><p><strong>示例 1:</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入: [1,2,1]<br>输出: [2,-1,2]<br>解释: 第一个 1 的下一个更大的数是 2；<br>数字 2 找不到下一个更大的数； <br>第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p>我们可以使用单调栈解决本题。单调栈中保存的是下标，从栈底到栈顶的下标在数组 $nums$ 中对应的值是单调不升的。</p><p>每次我们移动到数组中的一个新的位置 $i$，我们就将当前单调栈中所有对应值小于 $nums[i]$ 的下标弹出单调栈，这些值的下一个更大元素即为 $nums[i]$，随后我们将位置 $i$ 入栈.</p><p>但是注意到只遍历一次序列是不够的，例如序列 $[2,3,1]$，最后单调栈中将剩余 $[3,1]$，其中元素 $[1]$ 的下一个更大元素还是不知道的</p><p>一个朴素的思想是，我们可以把这个循环数组「拉直」，即复制该序列的前 $n-1$ 个元素拼接在原序列的后面。这样我们就可以将这个新序列当作普通序列，用上文的方法来处理。</p><p>而在本题中，我们不需要显性地将该循环数组「拉直」，而只需要在处理时对下标取模即可。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[stk.<span class="hljs-built_in">top</span>()] &lt; nums[i % n]) &#123;<br>                ret[stk.<span class="hljs-built_in">top</span>()] = nums[i % n];<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            stk.<span class="hljs-built_in">push</span>(i % n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224. 基本计算器"></a><a href="https://leetcode-cn.com/problems/basic-calculator/%E3%80%8CHard%E3%80%8D">224. 基本计算器</a></h1><p>实现一个基本的计算器来计算一个简单的字符串表达式 <code>s</code> 的值。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot;<br>输出：23<br></code></pre></div></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> 由数字、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;(&#39;</code>、<code>&#39;)&#39;</code>、和 <code>&#39; &#39;</code> 组成</li><li><code>s</code> 表示一个有效的表达式</li></ul><blockquote><p>算法分析：</p><p>方法：括号展开 + 栈</p><p>由于字符串除了数字与括号外，只有加号和减号两种运算符。因此，如果展开表达式中所有的括号，则得到的新表达式中，数字本身不会发生变化，只是每个数字前面的符号会发生变化。</p><p>因此，我们考虑使用一个取值为 {-1, 1} 的整数 $sign$ 代表「当前」的符号。根据括号表达式的性质，它的取值：</p><ul><li>与字符串中当前位置的运算符有关；</li><li>如果当前位置处于一系列括号之内，则也与这些括号前面的运算符有关：每当遇到一个以 -− 号开头的括号，则意味着此后的符号都要被「翻转」。</li></ul><p>考虑到第二点，我们需要维护一个栈 $ops$，其中栈顶元素记录了当前位置所处的每个括号所「共同形成」的符号。例如，对于字符串 $1+2+(3-(4+5))$：</p><ul><li>扫描到 $1+2$ 时，由于当前位置没有被任何括号所包含，则栈顶元素为初始值 $+1$.</li><li>扫描到 $1+2+(3$ 时，当前位置被一个括号所包含，该括号前面的符号为 $+$ 号，因此栈顶元素依然 $+1$.</li><li>扫描到 $1+2+(3-(4$ 时，当前位置被两个括号所包含，分别对应着 $+$ 号和 $-$ 号，由于 $+$ 号和 $-$ 号合并的结果为 $-$ 号，因此栈顶元素变为 $-1$.</li></ul><p>​    在得到栈 $ops$ 之后，$sign$ 的取值就能够确定了：&#x3D;&#x3D;如果当前遇到了 $+$ 号，则更新 $sign\leftarrow ops.top()$ ；如果遇到了遇到了 $-$ 号，则更新 $sign\leftarrow -ops.top()$&#x3D;&#x3D;.</p><p>然后，每当遇到 $($ 时，都要将当前的 $sign$ 取值压入栈中；每当遇到 $)$ 时，都从栈中弹出一个元素。这样，我们能够在扫描字符串的时候，即时地更新 $ops$ 中的元素.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>n := <span class="hljs-built_in">len</span>(s)<br>ans := <span class="hljs-number">0</span><br>ops := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>&#125;<br>sign := <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; &#123;<br><span class="hljs-keyword">switch</span> s[i] &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27; &#x27;</span>:<br>i++<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>sign = -ops[<span class="hljs-built_in">len</span>(ops)<span class="hljs-number">-1</span>]<br>i++<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>sign = ops[<span class="hljs-built_in">len</span>(ops)<span class="hljs-number">-1</span>]<br>i++<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>ops = <span class="hljs-built_in">append</span>(ops, sign)<br>i++<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<br>ops = ops[:<span class="hljs-built_in">len</span>(ops)<span class="hljs-number">-1</span>]<br>i++<br><span class="hljs-keyword">default</span>:<br>num := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> ; i &lt; n &amp;&amp; <span class="hljs-string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; i++ &#123;<br>num = num*<span class="hljs-number">10</span> + (<span class="hljs-type">int</span>)(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>)<br>&#125;<br>ans += sign * num<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="331-验证二叉树的前序序列化「Medium」"><a href="#331-验证二叉树的前序序列化「Medium」" class="headerlink" title="331. 验证二叉树的前序序列化「Medium」"></a><a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/">331. 验证二叉树的前序序列化「Medium」</a></h1><p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">     <span class="hljs-built_in">_</span>9<span class="hljs-built_in">_</span><br>    /   <span class="hljs-keyword">\</span><br><span class="hljs-keyword"></span>   3     2<br>  / <span class="hljs-keyword">\ </span>  / <span class="hljs-keyword">\</span><br><span class="hljs-keyword"></span> 4   1  <span class="hljs-params">#</span>  6<br>/ <span class="hljs-keyword">\ </span>/ <span class="hljs-keyword">\ </span>  / <span class="hljs-keyword">\</span><br><span class="hljs-keyword"></span><span class="hljs-params">#</span> <span class="hljs-params">#</span> <span class="hljs-params">#</span> <span class="hljs-params">#</span>   <span class="hljs-params">#</span> <span class="hljs-params">#</span><br></code></pre></div></td></tr></table></figure><p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 <code>#</code> 代表一个空节点。</p><p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p>每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>&#39;#&#39;</code> 。</p><p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入: &quot;9,3,4,<span class="hljs-params">#</span>,<span class="hljs-params">#</span>,1,<span class="hljs-params">#</span>,<span class="hljs-params">#</span>,2,<span class="hljs-params">#</span>,6,<span class="hljs-params">#</span>,<span class="hljs-params">#</span>&quot;<br>输出: true<br></code></pre></div></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入: &quot;1,<span class="hljs-params">#</span>&quot;<br>输出: false<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p>&#x3D;&#x3D;方法一：栈&#x3D;&#x3D;<br>我们可以定义一个概念，叫做槽位。一个槽位可以被看作「当前二叉树中正在等待被节点填充」的那些位置。</p><p>二叉树的建立也伴随着槽位数量的变化。每当遇到一个节点时：</p><p>如果遇到了空节点，则要消耗一个槽位；</p><p>如果遇到了非空节点，则除了消耗一个槽位外，还要再补充两个槽位。</p><p>此外，还需要将根节点作为特殊情况处理。</p><p><img src="https://assets.leetcode-cn.com/solution-static/331/1.png" alt="p"></p><p>我们使用栈来维护槽位的变化。栈中的每个元素，代表了对应节点处<strong>剩余槽位的数量</strong>，而栈顶元素就对应着下一步可用的槽位数量。当遇到空节点时，仅将栈顶元素减 $1$；当遇到非空节点时，将栈顶元素减 $1$ 后，再向栈中压入一个 $2$。无论何时，如果栈顶元素变为 $0$，就立刻将栈顶弹出。 </p><p>历结束后，若栈为空，说明没有待填充的槽位，因此是一个合法序列；否则若栈不为空，则序列不合法。此外，在遍历的过程中，若槽位数量不足，则序列不合法。</p><ul><li>时间复杂度：$O(n)$.</li><li>空间复杂度：$O(n)$.</li></ul><p>&#x3D;&#x3D;方法二：计数&#x3D;&#x3D;</p><p>回顾方法一的逻辑，如果把栈中元素看成一个整体，即所有剩余槽位的数量，也能维护槽位的变化。</p><p>因此，我们可以只维护一个计数器，代表栈中所有元素之和，其余的操作逻辑均可以保持不变</p><ul><li>时间复杂度：$O(n)$.</li><li>空间复杂度：$O(1)$.</li></ul></blockquote><p>方法一：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidSerialization</span><span class="hljs-params">(preorder <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(preorder)<br>    stk := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stk) == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> preorder[i] == <span class="hljs-string">&#x27;,&#x27;</span> &#123;<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> preorder[i] == <span class="hljs-string">&#x27;#&#x27;</span> &#123;<br>            stk[<span class="hljs-built_in">len</span>(stk)<span class="hljs-number">-1</span>]--<br>            <span class="hljs-keyword">if</span> stk[<span class="hljs-built_in">len</span>(stk)<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span> &#123;<br>                stk = stk[:<span class="hljs-built_in">len</span>(stk)<span class="hljs-number">-1</span>]<br>            &#125;<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 读一个数字</span><br>            <span class="hljs-keyword">for</span> i &lt; n &amp;&amp; preorder[i] != <span class="hljs-string">&#x27;,&#x27;</span> &#123;<br>                i++<br>            &#125;<br>            stk[<span class="hljs-built_in">len</span>(stk)<span class="hljs-number">-1</span>]--<br>            <span class="hljs-keyword">if</span> stk[<span class="hljs-built_in">len</span>(stk)<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span> &#123;<br>                stk = stk[:<span class="hljs-built_in">len</span>(stk)<span class="hljs-number">-1</span>]<br>            &#125;<br>            stk = <span class="hljs-built_in">append</span>(stk, <span class="hljs-number">2</span>)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stk) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>方法二：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidSerialization</span><span class="hljs-params">(preorder <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(preorder)<br>    slots := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; &#123;<br>        <span class="hljs-keyword">if</span> slots == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> preorder[i] == <span class="hljs-string">&#x27;,&#x27;</span> &#123;<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> preorder[i] == <span class="hljs-string">&#x27;#&#x27;</span> &#123;<br>            slots--<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 读一个数字</span><br>            <span class="hljs-keyword">for</span> i &lt; n &amp;&amp; preorder[i] != <span class="hljs-string">&#x27;,&#x27;</span> &#123;<br>                i++<br>            &#125;<br>            slots++ <span class="hljs-comment">// slots = slots - 1 + 2</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slots == <span class="hljs-number">0</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="456-132-模式「Medium」"><a href="#456-132-模式「Medium」" class="headerlink" title="456. 132 模式「Medium」"></a><a href="https://leetcode-cn.com/problems/132-pattern/">456. 132 模式「Medium」</a></h1><p>给你一个整数数组 <code>nums</code> ，数组中共有 <code>n</code> 个整数。</p><p><strong>132 模式的子序列</strong> 由三个整数 <code>nums[i], nums[j]</code> 和 <code>nums[k]</code> 组成</p><p>并同时满足：<code>i &lt; j &lt; k</code> 和 <code>nums[i] &lt; nums[k] &lt; nums[j]</code></p><p>如果 <code>nums</code> 中存在 <strong>132 模式的子序列</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> </p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：nums = [1,2,3,4]<br>输出：false<br>解释：序列中不存在 132 模式的子序列。<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：nums = [3,1,4,2]<br>输出：true<br>解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p>我们首先可以考虑枚举 <code>132</code> 模式中的 <code>3</code></p><ul><li><p>由于 <code>1</code> 是模式中的最小值，因此我们在枚举 <code>j</code> 的同时，维护数组 <code>num[0, j - 1]</code> 中的最小值，因为只有 <code>a[i] &lt; a[j]</code> 时，我们才可以选择 <code>a[i]</code> 作为 <code>1</code>.</p></li><li><p>由于 <code>2</code> 是模式中的次小值，因此我们可以使用一个有序集合（例如平衡树）维护数组中右侧元素</p><p> <code>nums[j + 1, n - 1]</code> 中的所有值。当我们确定了 <code>a[i]</code> 和 <code>a[j]</code> 时，我们就可以在有序集合中查询严格比 <code>a[i]</code> 大的那个最小元素，即为 <code>a[k]</code>.</p></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find132pattern</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 左侧最小值</span><br>        <span class="hljs-type">int</span> left_min = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 右侧所有元素</span><br>        multiset&lt;<span class="hljs-type">int</span>&gt; right_all;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">2</span>; k &lt; n; ++k) &#123;<br>            right_all.<span class="hljs-built_in">insert</span>(nums[k]);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">1</span>; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (left_min &lt; nums[j]) &#123;<br>                <span class="hljs-keyword">auto</span> it = right_all.<span class="hljs-built_in">upper_bound</span>(left_min);<br>                <span class="hljs-keyword">if</span> (it != right_all.<span class="hljs-built_in">end</span>() &amp;&amp; *it &lt; nums[j]) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            left_min = <span class="hljs-built_in">min</span>(left_min, nums[j]);<br>            right_all.<span class="hljs-built_in">erase</span>(right_all.<span class="hljs-built_in">find</span>(nums[j + <span class="hljs-number">1</span>]));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about Search</title>
    <link href="/2021/03/18/about%20Search/"/>
    <url>/2021/03/18/about%20Search/</url>
    
    <content type="html"><![CDATA[<h1 id="about-Search"><a href="#about-Search" class="headerlink" title="about Search"></a>about Search</h1><h2 id="深度优先搜索「一条路走到底，不撞南墙不回头」"><a href="#深度优先搜索「一条路走到底，不撞南墙不回头」" class="headerlink" title="深度优先搜索「一条路走到底，不撞南墙不回头」"></a>深度优先搜索「一条路走到底，不撞南墙不回头」</h2><ul><li><h5 id="深度优先遍历-只要前面有可以走的路，就会一直向前走，直到无路可走才会回头；"><a href="#深度优先遍历-只要前面有可以走的路，就会一直向前走，直到无路可走才会回头；" class="headerlink" title="深度优先遍历 只要前面有可以走的路，就会一直向前走，直到无路可走才会回头；"></a>深度优先遍历 只要前面有可以走的路，就会一直向前走，直到无路可走才会回头；</h5></li><li><h4 id="「无路可走」有两种情况：①-遇到了墙；②-遇到了已经走过的路；"><a href="#「无路可走」有两种情况：①-遇到了墙；②-遇到了已经走过的路；" class="headerlink" title="「无路可走」有两种情况：① 遇到了墙；② 遇到了已经走过的路；"></a>「无路可走」有两种情况：① 遇到了墙；② 遇到了已经走过的路；</h4></li><li><p>在「无路可走」的时候，沿着原路返回，直到回到了还有未走过的路的路口，尝试继续走没有走过的路径；有一些路径没有走到，这是因为找到了出口，程序就停止了；</p></li><li><p>「深度优先遍历」也叫「深度优先搜索」，遍历是行为的描述，搜索是目的（用途）；</p></li><li><p>遍历不是很深奥的事情，把 所有 可能的情况都看一遍，才能说「找到了目标元素」或者「没找到目标元素」。遍历也称为 穷举，穷举的思想在人类看来虽然很不起眼，但借助 计算机强大的计算能力，穷举可以帮助我们解决很多专业领域知识不能解决的问题。</p></li><li><h3 id="n皇后问题「n个皇后位于nxn的棋盘-她们不可互相攻击-横-竖-斜-都不可以在一列上-」"><a href="#n皇后问题「n个皇后位于nxn的棋盘-她们不可互相攻击-横-竖-斜-都不可以在一列上-」" class="headerlink" title="n皇后问题「n个皇后位于nxn的棋盘, 她们不可互相攻击(横 竖 斜 都不可以在一列上)」"></a>n皇后问题「n个皇后位于nxn的棋盘, 她们不可互相攻击(横 竖 斜 都不可以在一列上)」</h3></li><li><h4 id="解决这个问题的思路是尝试每一种可能，然后逐个判断。只不过回溯算法按照一定的顺序进行尝试，在一定不可能得到解的时候进行剪枝，进而减少了尝试的可能。"><a href="#解决这个问题的思路是尝试每一种可能，然后逐个判断。只不过回溯算法按照一定的顺序进行尝试，在一定不可能得到解的时候进行剪枝，进而减少了尝试的可能。" class="headerlink" title="解决这个问题的思路是尝试每一种可能，然后逐个判断。只不过回溯算法按照一定的顺序进行尝试，在一定不可能得到解的时候进行剪枝，进而减少了尝试的可能。"></a>解决这个问题的思路是尝试每一种可能，然后逐个判断。只不过回溯算法按照一定的顺序进行尝试，<strong>在一定不可能得到解的时候进行剪枝</strong>，进而减少了尝试的可能。</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayDeque;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 记录某一列是否放置了皇后</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] col;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 记录主对角线上的单元格是否放置了皇后</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] main;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 记录了副对角线上的单元格是否放置了皇后</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span>[] sub;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;List&lt;String&gt;&gt; res;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">solveNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-comment">// 设置成员变量，减少参数传递，具体作为方法参数还是作为成员变量，请参考团队开发规范</span><br>        <span class="hljs-built_in">this</span>.n = n;<br>        <span class="hljs-built_in">this</span>.col = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-built_in">this</span>.main = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">this</span>.sub = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>];<br>        Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>        dfs(<span class="hljs-number">0</span>, path);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> row, Deque&lt;Integer&gt; path)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            <span class="hljs-comment">// 深度优先遍历到下标为 n，表示 [0.. n - 1] 已经填完，得到了一个结果</span><br>            List&lt;String&gt; board = convert2board(path);<br>            res.add(board);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 针对下标为 row 的每一列，尝试是否可以放置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (!col[j] &amp;&amp; !main[row - j + n - <span class="hljs-number">1</span>] &amp;&amp; !sub[row + j]) &#123;<br>                path.addLast(j);<br>                col[j] = <span class="hljs-literal">true</span>;<br>                main[row - j + n - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                sub[row + j] = <span class="hljs-literal">true</span>;<br>                dfs(row + <span class="hljs-number">1</span>, path);<br>                sub[row + j] = <span class="hljs-literal">false</span>;<br>                main[row - j + n - <span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>                col[j] = <span class="hljs-literal">false</span>;<br>                path.removeLast();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">convert2board</span><span class="hljs-params">(Deque&lt;Integer&gt; path)</span> &#123;<br>        List&lt;String&gt; board = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Integer num : path) &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            row.append(<span class="hljs-string">&quot;.&quot;</span>.repeat(Math.max(<span class="hljs-number">0</span>, n)));<br>            row.replace(num, num + <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Q&quot;</span>);<br>            board.add(row.toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> board;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        vis = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>);<br>        tmp = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n);<br>        <span class="hljs-comment">//从0层递归到n层 ，这里我们无需判断某一层是否有多个皇后，因为我们</span><br>        <span class="hljs-comment">//是按照层来递归，一层只有一个皇后</span><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">const</span> <span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-comment">//到达n层，存储一个可行解</span><br>        <span class="hljs-keyword">if</span>(k == n)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;string&gt;(n, <span class="hljs-built_in">string</span>(n, <span class="hljs-string">&#x27;.&#x27;</span>)));<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>                ans.<span class="hljs-built_in">back</span>()[i][tmp[i]] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>            <span class="hljs-comment">//该列已经有皇后了，不能放置</span><br>            <span class="hljs-keyword">if</span>(vis[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//第k行第i个位置放皇后</span><br>            tmp[k] = i;<br>            vis[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(k))<br>                <span class="hljs-built_in">dfs</span>(k + <span class="hljs-number">1</span>, n);<br>            vis[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//和之前已经放置过的皇后判断是否在对角线、斜对角线上</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i ++)&#123;<br>            <span class="hljs-keyword">if</span>(tmp[i] - i == tmp[k] - k || tmp[i] + i == tmp[k] + k)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//判断某一列上是否有皇后</span><br>    vector&lt;<span class="hljs-type">bool</span>&gt; vis;<br>    <span class="hljs-comment">//保存答案</span><br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    <span class="hljs-comment">//存储每一层皇后的位置</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="DFS的方向模版"><a href="#DFS的方向模版" class="headerlink" title="DFS的方向模版"></a>DFS的方向模版</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> row, column;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; vis, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span>&amp; maxn)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= row || y &lt; <span class="hljs-number">0</span> || y &gt;= column || vis[x][y] || grid[x][y] == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ++maxn;<br>        vis[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> dx = x + dir[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> dy = y + dir[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">dfs</span>(grid, vis, dx, dy, maxn);<br>        &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about Sort</title>
    <link href="/2021/03/14/about%20Sort/"/>
    <url>/2021/03/14/about%20Sort/</url>
    
    <content type="html"><![CDATA[<h1 id="about-Sort"><a href="#about-Sort" class="headerlink" title="about Sort"></a>about Sort</h1><h2 id="稳定排序-x2F-不稳定排序-「相同的元素-在排序前后-仍然处于相同顺序-rightarrow-稳定排序」"><a href="#稳定排序-x2F-不稳定排序-「相同的元素-在排序前后-仍然处于相同顺序-rightarrow-稳定排序」" class="headerlink" title="稳定排序&#x2F;不稳定排序 「相同的元素 在排序前后 仍然处于相同顺序 $\rightarrow$ 稳定排序」"></a>稳定排序&#x2F;不稳定排序 「相同的元素 在排序前后 仍然处于相同顺序 $\rightarrow$ 稳定排序」</h2><hr><ul><li><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2></li></ul><h5 id="Pivot-算法-「每次选择一个参考数-小于这个参考数的放在左边-大于它的放在右边-x2F-x2F-这个参考数当然也在合适的位置」"><a href="#Pivot-算法-「每次选择一个参考数-小于这个参考数的放在左边-大于它的放在右边-x2F-x2F-这个参考数当然也在合适的位置」" class="headerlink" title="Pivot 算法 「每次选择一个参考数 小于这个参考数的放在左边 大于它的放在右边 &#x2F;&#x2F; 这个参考数当然也在合适的位置」"></a>Pivot 算法 「每次选择一个参考数 小于这个参考数的放在左边 大于它的放在右边 &#x2F;&#x2F; 这个参考数当然也在合适的位置」</h5><h4 id="找出参考数之后-向左右部分递归调用Pivot算法-每次调用算法-会产生一个参考数-它一定会在最后正确的位置-如果参考数每次都处在中间位置-那么为O-nlogn-级别-但在最差情况下会退化到n-2"><a href="#找出参考数之后-向左右部分递归调用Pivot算法-每次调用算法-会产生一个参考数-它一定会在最后正确的位置-如果参考数每次都处在中间位置-那么为O-nlogn-级别-但在最差情况下会退化到n-2" class="headerlink" title="找出参考数之后 向左右部分递归调用Pivot算法 每次调用算法 会产生一个参考数 它一定会在最后正确的位置      如果参考数每次都处在中间位置 那么为O((nlogn))级别 但在最差情况下会退化到n^2"></a>找出参考数之后 向左右部分递归调用Pivot算法 每次调用算法 会产生一个参考数 它一定会在<em><strong>最后正确</strong></em>的位置      如果参考数每次都处在中间位置 那么为O((nlogn))级别 但在最差情况下会退化到n^2</h4><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义 pivot 函数，他会以数组第一个数作为参考数，并会按上述规则调整数组，并返回参考数的下标</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pivot</span>(<span class="hljs-params">a</span>):<br>    <span class="hljs-comment"># 首先我们分析一下边界情况，首先如果只有一个数，这种情况下数组已经是有序的了，我们返回 -1 代表不需要再继续后面的过程。那如果是两个数的话，我们可以直接比较大小然后给出正确排序，也不需要 pivot 过程了。我们仍然返回 -1。</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a) == <span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a) == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">if</span> a[<span class="hljs-number">0</span>] &gt; a[<span class="hljs-number">1</span>]:<br>            a[<span class="hljs-number">0</span>],a[<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>],a[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-comment"># 那么接下来我们就得进行我们的算法了，首先按我们刚才说的，我们假设参考数是第一个值。同时我们定义两个指针，i 指向 1，j 指向末尾。</span><br>    pivot = a[<span class="hljs-number">0</span>]<br>    i = <span class="hljs-number">1</span>; j = <span class="hljs-built_in">len</span>(a)-<span class="hljs-number">1</span><br>    <span class="hljs-comment"># 如果 i 和 j 还没重叠的话</span><br>    <span class="hljs-keyword">while</span> i &lt; j:<br>        <span class="hljs-comment"># 我们比较 a[i] 和 pivot 的大小关系，直到碰到第一个 a[i] 大于 pivot，或者 i 等于 j 就退出</span><br>        <span class="hljs-keyword">while</span> a[i] &lt; pivot <span class="hljs-keyword">and</span> i &lt; j:<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 对 a[j] 进行类似操作</span><br>        <span class="hljs-keyword">while</span> a[j] &gt; pivot <span class="hljs-keyword">and</span> i &lt; j:<br>            j -= <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 如果 i, j 重合，就可以退出了</span><br>        <span class="hljs-keyword">if</span> i == j:<span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># 交换 a[i], a[j] 继续算法</span><br>        a[i],a[j] = a[j],a[i]<br>    <span class="hljs-comment"># 最后交换 pivot</span><br>    <span class="hljs-keyword">if</span> a[i] &gt; a[<span class="hljs-number">0</span>]:<br>        a[<span class="hljs-number">0</span>],a[i-<span class="hljs-number">1</span>] = a[i-<span class="hljs-number">1</span>],a[<span class="hljs-number">0</span>]; i -=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        a[<span class="hljs-number">0</span>],a[i] = a[i],a[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> i<br><br>// 完整的快排算法 就是对其进行左右递归.  下面的是严蔚敏的快速排序算法<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-type">int</span> pivot = nums[low];<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        <span class="hljs-keyword">while</span> (low &lt; high <span class="hljs-keyword">and</span> nums[high] &gt;= pivot) --high;<br>        nums[low] = nums[high];<br>        <span class="hljs-keyword">while</span> (low &lt; high <span class="hljs-keyword">and</span> nums[low] &lt;= pivot) ++low;<br>        nums[high] = nums[low];<br>    &#125;<br>    nums[low] = pivot;<br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">Partition</span>(nums, low, high);<br>        <span class="hljs-built_in">QuickSort</span>(nums, low, pivot - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">QuickSort</span>(nums, pivot + <span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><ul><li><h2 id="基数排序-桶排序-桶排序是基数排序的特例"><a href="#基数排序-桶排序-桶排序是基数排序的特例" class="headerlink" title="基数排序(桶排序) 桶排序是基数排序的特例"></a>基数排序(桶排序) 桶排序是基数排序的特例</h2></li></ul><h3 id="桶排序-在序列里值的范围-且这个范围不算太大时使用"><a href="#桶排序-在序列里值的范围-且这个范围不算太大时使用" class="headerlink" title="桶排序  在序列里值的范围 且这个范围不算太大时使用"></a>桶排序  在序列里值的范围 且这个范围不算太大时使用</h3><p>是一种非常特殊的排序算法。在前面的课程中，我们有一道题目是要找数据流的中位数，限制是所有的数都在 1 到 100 以内。我们当时提到在这种限制下，可以将数字放到 1-100 的桶里，每个桶只记录当前数字的数量，从而将插入的复杂度从 O(n) 降低为<br>O(1)，这就是一个桶排序的思想。同样的，如果我们碰到这样的题目：</p><blockquote><h4 id="例题：有-10-万个整数，每个数范围在-0-99-之间。有若干查询，每个查询给定一个数-x，问比-x-小的数有多少。"><a href="#例题：有-10-万个整数，每个数范围在-0-99-之间。有若干查询，每个查询给定一个数-x，问比-x-小的数有多少。" class="headerlink" title="例题：有 10 万个整数，每个数范围在 [0,99] 之间。有若干查询，每个查询给定一个数 x，问比 x 小的数有多少。"></a>例题：有 10 万个整数，每个数范围在 [0,99] 之间。有若干查询，每个查询给定一个数 x，问比 x 小的数有多少。</h4><p>对于这道题目，我们可以直接把数都拿过来排序，然后对每个 x 做一个二分查找，可以解决问题。但是通过桶排序我们可以有更优的解。</p><p>我们开一个数组，大小为 100，分别代表 0 到 99 每个数有多少个。然后我们遍历所有数据，记录每个数字的数量。最后统计的时候，我们只需要计算数组中下标小于 x 的数的总和就可以了。</p><p>后面统计的部分只有 0 到 100 的循环，所以查询的时间非常短。整体复杂度的瓶颈就在于开始时预处理数据，也就是 O(n) </p></blockquote><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h4 id="我们开一个长度为10的桶-把数据按照-x3D-x3D-最后一位-x3D-x3D-放到对应的桶里-形成一个序列"><a href="#我们开一个长度为10的桶-把数据按照-x3D-x3D-最后一位-x3D-x3D-放到对应的桶里-形成一个序列" class="headerlink" title="我们开一个长度为10的桶  把数据按照&#x3D;&#x3D;最后一位&#x3D;&#x3D;放到对应的桶里 形成一个序列"></a>我们开一个长度为10的桶  把数据按照&#x3D;&#x3D;最后一位&#x3D;&#x3D;放到对应的桶里 形成一个序列</h4><h4 id="我们开一个长度为10的桶-把数据按照-x3D-x3D-倒数第二位-x3D-x3D-放到对应的桶里-⚠️-同一个桶里的元素要按照上个序列的顺序放"><a href="#我们开一个长度为10的桶-把数据按照-x3D-x3D-倒数第二位-x3D-x3D-放到对应的桶里-⚠️-同一个桶里的元素要按照上个序列的顺序放" class="headerlink" title="我们开一个长度为10的桶  把数据按照 &#x3D;&#x3D;倒数第二位&#x3D;&#x3D; 放到对应的桶里 ⚠️ 同一个桶里的元素要按照上个序列的顺序放"></a>我们开一个长度为10的桶  把数据按照 &#x3D;&#x3D;倒数第二位&#x3D;&#x3D; 放到对应的桶里 ⚠️ 同一个桶里的元素要按照上个序列的顺序放</h4><h4 id="我们开始一个长度为10的桶-把数据按照-x3D-x3D-倒数第三位-x3D-x3D-放到对应的桶里-同理"><a href="#我们开始一个长度为10的桶-把数据按照-x3D-x3D-倒数第三位-x3D-x3D-放到对应的桶里-同理" class="headerlink" title="我们开始一个长度为10的桶 把数据按照 &#x3D;&#x3D;倒数第三位&#x3D;&#x3D; 放到对应的桶里 同理"></a>我们开始一个长度为10的桶 把数据按照 &#x3D;&#x3D;倒数第三位&#x3D;&#x3D; 放到对应的桶里 同理</h4><img src="/Users/edelweiss/Library/Application Support/typora-user-images/image-20210308201415058.png" alt="image-20210308201415058" style="zoom:50%;" /><hr><ul><li><h2 id="冒泡排序-「优化-如果一轮里没有元素被交换-说明排序结束」"><a href="#冒泡排序-「优化-如果一轮里没有元素被交换-说明排序结束」" class="headerlink" title="冒泡排序 「优化 : 如果一轮里没有元素被交换 说明排序结束」"></a>冒泡排序 「优化 : 如果一轮里没有元素被交换 说明排序结束」</h2></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-comment">// 如果左边的数大于右边的数，则交换，保证右边的数字最大</span><br>            arr[j + <span class="hljs-number">1</span>] = arr[j + <span class="hljs-number">1</span>] + arr[j];<br>            arr[j] = arr[j + <span class="hljs-number">1</span>] - arr[j];<br>            arr[j + <span class="hljs-number">1</span>] = arr[j + <span class="hljs-number">1</span>] - arr[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><ul><li><h2 id="选择排序-「不受输入状态影响-amp-交换次数少-最多n次交换-」「选择排序的优化版本就是堆排序」"><a href="#选择排序-「不受输入状态影响-amp-交换次数少-最多n次交换-」「选择排序的优化版本就是堆排序」" class="headerlink" title="选择排序 「不受输入状态影响 &amp; 交换次数少(最多n次交换)」「选择排序的优化版本就是堆排序」"></a>选择排序 「不受输入状态影响 &amp; 交换次数少(最多n次交换)」「选择排序的优化版本就是堆排序」</h2></li></ul><p>维护一个长度逐渐变长的窗口 这个窗口中的元素是已经排好序的了 每一次都把序列搜索一遍.  搜索n-1遍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> index = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                index = nums[j] &lt; nums[index] ? j : index;<br>            &#125;<br>            <span class="hljs-built_in">swap</span> (nums[i], nums[index]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><ul><li><h3 id="插入排序-「分为-向后腾挪和交换-两种方式」"><a href="#插入排序-「分为-向后腾挪和交换-两种方式」" class="headerlink" title="插入排序 「分为 向后腾挪和交换 两种方式」"></a>插入排序 「分为 向后腾挪和交换 两种方式」</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 从第二个数开始，往前插入数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentNumber</span> <span class="hljs-operator">=</span> arr[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 寻找插入位置的过程中，不断地将比 currentNumber 大的数字向后挪</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; currentNumber &lt; arr[j]) &#123;<br>            arr[j + <span class="hljs-number">1</span>] = arr[j];<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">// 两种情况会跳出循环：1. 遇到一个小于或等于 currentNumber 的数字，跳出循环，currentNumber 就坐到它后面。</span><br>        <span class="hljs-comment">// 2. 已经走到数列头部，仍然没有遇到小于或等于 currentNumber 的数字，也会跳出循环，此时 j 等于 -1，currentNumber 就坐到数列头部。</span><br>        arr[j + <span class="hljs-number">1</span>] = currentNumber;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 这种采取了交换的方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-comment">// 从第二个数开始，往前插入数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-comment">// j 记录当前数字下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-comment">// 当前数字比前一个数字小，则将当前数字与前一个数字交换</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">1</span> &amp;&amp; arr[j] &lt; arr[j - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j];<br>            arr[j] = arr[j - <span class="hljs-number">1</span>];<br>            arr[j - <span class="hljs-number">1</span>] = temp;<br>            <span class="hljs-comment">// 更新当前数字下标</span><br>            j--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tree Leetcode</title>
    <link href="/2021/03/13/Chapter%205%20Tree/"/>
    <url>/2021/03/13/Chapter%205%20Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote><p>树的解决我们一般使用递归方法，递归概述如下：</p><ul><li>将问题转化为规模更小的子问题，直至边界情况</li><li>递归方程 + 边界条件</li><li>借助于计算机的程序栈，利用函数自身调用来实现</li></ul></blockquote><h1 id="124-二叉树中的最大路径和「Hard」"><a href="#124-二叉树中的最大路径和「Hard」" class="headerlink" title="124. 二叉树中的最大路径和「Hard」"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和「Hard」</a></h1><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 最大路径和 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="picture"></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：root = [1,2,3]<br>输出：6<br>解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="picture"></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：root = [-10,9,20,null,null,15,7]<br>输出：42<br>解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p>首先，考虑实现一个简化的函数 <code>maxGain(node)</code>，该函数计算二叉树中的一个节点的最大贡献值，具体而言，就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。</p><p>具体而言，该函数的计算如下：</p><ul><li>空节点的最大贡献值等于 $0$.</li><li>非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和 ( 对于叶节点而言，最大贡献值等于节点值 )</li></ul><p>例如，考虑如下二叉树。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"> <span class="hljs-number">-10</span><br> / \<br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  \<br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></div></td></tr></table></figure><p>叶节点 <code>9、15、7</code> 的最大贡献值分别为 <code>9、15、7</code>。</p><p>得到叶节点的最大贡献值之后，再计算非叶节点的最大贡献值。</p><p>节点 20 的最大贡献值等于 <code>20 + max(15, 7) =  35</code>.</p><p>节点 -10 的最大贡献值等于 <code>-10 + max(35, 9) = 25</code>.</p><p>上述计算过程是递归的过程，因此，对根节点调用函数 <code>maxGain</code>，即可得到每个节点的最大贡献值。</p><p>根据函数 <code>maxGain</code> 得到每个节点的最大贡献值之后，如何得到二叉树的最大路径和？对于二叉树中的一个节点，该节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值，如果子节点的最大贡献值为正，则计入该节点的最大路径和，否则不计入该节点的最大路径和。维护一个全局变量 <code>maxSum</code> 存储最大路径和，在递归过程中更新 <code>maxSum</code> 的值，最后得到的 <code>maxSum</code> 的值即为二叉树中的最大路径和。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> maxSum = INT_MIN;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxGain</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 递归计算左右子节点的最大贡献值</span><br>        <span class="hljs-comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span><br>        <span class="hljs-type">int</span> leftGain = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxGain</span>(root-&gt;left), <span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> rightGain = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxGain</span>(root-&gt;right), <span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-comment">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span><br>        <span class="hljs-type">int</span> priceNewpath = root-&gt;val + leftGain + rightGain;<br>        <br>        <span class="hljs-comment">// 更新答案</span><br>        maxSum = <span class="hljs-built_in">max</span>(maxSum, priceNewpath);<br>        <br>        <span class="hljs-comment">// 返回节点的最大贡献值</span><br>        <span class="hljs-keyword">return</span> root-&gt;val + <span class="hljs-built_in">max</span>(leftGain, rightGain);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">maxGain</span>(root);<br>        <span class="hljs-keyword">return</span> maxSum;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="剑指-Offer-26-树的子结构「Medium」"><a href="#剑指-Offer-26-树的子结构「Medium」" class="headerlink" title="剑指 Offer 26. 树的子结构「Medium」"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构「Medium」</a></h1><p>输入两棵二叉树<code>A</code>和<code>B</code>，判断<code>B</code>是不是<code>A</code>的子结构。(约定空树不是任意一个树的子结构)</p><p><code>B</code>是<code>A</code>的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:<br>给定的树 <code>A</code>:</p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">    3<br>   / <span class="hljs-keyword">\</span><br><span class="hljs-keyword"></span>  4   5<br> / <span class="hljs-keyword">\</span><br><span class="hljs-keyword"></span>1   2<br></code></pre></div></td></tr></table></figure><p>给定的树 <code>B</code>：</p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">  4 <br> /<br>1<br></code></pre></div></td></tr></table></figure><p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：A = [1,2,3], B = [3,1]<br>输出：false<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><ol><li>双重递归第一重，<code>isSubStructure</code><ul><li>判断 <code>pRoot2</code> 是否为 <code>pRoot1</code> 的子结构 (约定空树,不为任何一棵树的子结构)</li><li>约定空树不是任意一个树的子结构. 所以 A 不可为空树,且 B 不可为空树。</li><li>B 是以 “<strong>A 为根节点</strong>“ 的子结构,或者 B 是 “<strong>A 的左子树</strong>“ 的子结构,或者B是 “<strong>A 的右子树</strong>“ 的子结构。注意三者为 <strong>或</strong> 的关系</li><li>相当于对 A 进行了前序遍历: 根-&gt;左-&gt;右</li></ul></li><li>双重递归第二重，<code>isInclude</code><ul><li>判断 <code>pRoot1</code> 是否包含 <code>pRoot2</code> (从集合关系分析,空集属于任何集合的子集)</li><li><code>pRoot2</code> 为空,则 <code>pRoot1</code> 包含 <code>pRoot2</code></li><li><code>pRoot1</code> 为空,则 <code>pRoot1</code> 不包含 <code>pRoot2</code></li><li><code>pRoot1</code>，<code>pRoot2</code> 都不为空, 但节点值不同，则 <code>pRoot1</code> 不包含 <code>pRoot2</code>，即不具备包含关系</li><li>如果值相同，则判断他们的左右节点是否也是包含关系（必须都是包含关系才行）</li><li>递归判断 A 的左节点和 B 的左节点是否相等, 递归判断 A 的右节点和 B 的右节点是否相等</li></ul></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubStructure</span><span class="hljs-params">(TreeNode* A, TreeNode* B)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (B == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isInclude</span>(A, B) <span class="hljs-keyword">or</span> <span class="hljs-built_in">isSubStructure</span>(A-&gt;left, B) <span class="hljs-keyword">or</span> <span class="hljs-built_in">isSubStructure</span>(A-&gt;right, B);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isInclude</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pRoot2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (pRoot1 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (pRoot1-&gt;val != pRoot2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isInclude</span>(pRoot1-&gt;left, pRoot2-&gt;left) <span class="hljs-keyword">and</span> <br>           <span class="hljs-built_in">isInclude</span>(pRoot1-&gt;right, pRoot2-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bit Leetcode</title>
    <link href="/2021/03/13/Chapter%206%20Bit/"/>
    <url>/2021/03/13/Chapter%206%20Bit/</url>
    
    <content type="html"><![CDATA[<h1 id="1680-连接连续二进制数字「Medium」"><a href="#1680-连接连续二进制数字「Medium」" class="headerlink" title="1680. 连接连续二进制数字「Medium」"></a><a href="https://leetcode-cn.com/problems/concatenation-of-consecutive-binary-numbers/">1680. 连接连续二进制数字「Medium」</a></h1><p>给你一个整数 <code>n</code> ，请你将 <code>1</code> 到 <code>n</code> 的二进制表示连接起来，并返回连接结果对应的 <strong>十进制</strong> 数字对 <code>10^9 + 7</code> 取余的结果。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：n = 1<br>输出：1<br>解释：二进制的 &quot;1&quot; 对应着十进制的 1 。<br></code></pre></div></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：n = 3<br>输出：27<br>解释：二进制下，1，2 和 3 分别对应 &quot;1&quot; ，&quot;10&quot; 和 &quot;11&quot; 。<br>将它们依次连接，我们得到 &quot;11011&quot; ，对应着十进制的 27 。<br></code></pre></div></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：n = 12<br>输出：505379714<br>解释：连接结果为 &quot;1101110010111011110001001101010111100&quot; 。<br>对应的十进制数字为 118505380540 。<br>对 109 + 7 取余后，结果为 505379714 。<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p>由于我们需要将「十进制转换成二进制」「进行运算」「将结果转换回十进制」这三个步骤，因此我们不妨直接将整个问题在十进制的角度下进行考虑。</p><p>假设我们当前处理到了数字 $i$，并且前面 $[1,i-1]$ 的二进制连接起来对应的<strong>十进制数</strong>为 $x$，那么我们如何将数字 $i$ 进行连接呢？</p><p>观察二进制连接的过程，我们可以将这一步运算抽象为两个步骤：</p><ol><li>将之前 $[1,i-1]$ 的二进制数<strong>左移</strong>若干位，这个位数就是 $i$ 的二进制表示的位数；</li><li>将 $i$ 通过<strong>加法运算</strong>与左移的结果进行相加。</li></ol><p>这样，我们可以得到 $x$ 的递推式：$x&#x3D;x\times2^{len(i)}+i$.</p><p>我们可以知道 $len(i)$ 和 $len(i-1)$ 要么相等，要么相差 $1$.</p><p>$x$ 是 $(100\cdots)_2$ 的形式存储，而 $x-1$ 是以 $(111\cdots)_2$ 的形式存在，所以当一个数 $x$ 为 $2$ 的倍数次的时候，那么它比 $x-1$ 多一位，因此&#x3D;&#x3D;当 <code>x &amp; (x - 1) == 0</code> 的时候，移位的位数就需要加 $1$&#x3D;&#x3D;，答案就显而易见了。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">concatenatedBinary</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> times = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((i &amp; (i - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>) ++times;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; times; ++j) &#123;<br>                ans &lt;&lt;= <span class="hljs-number">1</span>;<br>                ans %= mod;<br>            &#125;<br>            ans += i;<br>            ans %= mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="剑指-Offer-56-I-数组中数字出现的次数「Medium」"><a href="#剑指-Offer-56-I-数组中数字出现的次数「Medium」" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数「Medium」"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指 Offer 56 - I. 数组中数字出现的次数「Medium」</a></h1><p>一个整型数组 <code>nums</code> 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是 $O(n)$，空间复杂度是 $O(1)$.</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：nums = [4,1,4,6]<br>输出：[1,6] 或 [6,1]<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p>设两个只出现一次的数字为 $x,y$，由于 $x≠y$，则 $x$ 和 $y$ 二进制至少有一位不同（即分别为 $0$ 和 $1$ ），根据此位可以将 $nums$ 拆分为分别包含 $x$ 和 $y$ 的两个子数组。</p><p>易知两子数组都满足 「除一个数字之外，其他数字都出现了两次」。因此，仿照以上简化问题的思路，分别对两子数组遍历执行异或操作，即可得到两个只出现一次的数字 $x,y$.</p><p>算法流程：</p><ol><li><p>遍历 $nums$ 执行异或：</p><ul><li>设整型数组 $nums&#x3D;[a,a,b,b\cdots,x,y]$，对 $nums$ 中所有数字进行异或，得到的结果为 $x\bigoplus y$.</li></ul></li><li><p>循环左移计算 m:</p><ul><li><p>根据异或运算定义，若整数 $x\bigoplus y$ 某二进制位为 $1$，则 $x$ 和 $y$ 的此二进制位一定不同。换言之，找到  $x\bigoplus y$ 某位为 $1$ 的二进制位，即可将数组 $nums$ 拆分为上述的两个子数组。根据与运算特点，可知对于任意整数 $a$ 有：</p><ul><li>若 $a$ &amp; $0001&#x3D;1$，则 $a$ 的第一位为 $1$ ；</li><li>若 $a$ &amp; $0010&#x3D;1$，则 $a$ 的第二位为 $1$ ；</li><li>以此类推…</li></ul></li><li><p>因此，初始化一个辅助变量 $m&#x3D;1$，通过与运算从右向左循环判断，可 <strong>获取整数</strong> $x\bigoplus y$ <strong>首位</strong> $1$，记录于 $m$ 中，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(z &amp; m == <span class="hljs-number">0</span>) <span class="hljs-comment">// m 循环左移一位，直到 z &amp; m ！= 0</span><br>    m &lt;&lt;= <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure></li></ul></li><li><p><strong>拆分</strong> $nums$ <strong>为两个子数组</strong>；</p></li><li><p><strong>分别遍历两个子数组执行异或</strong>；</p><ul><li>通过遍历判断 $nums$ 中各数字和 $m$ 做与运算的结果，可将数组拆分为两个子数组，并分别对两个子数组遍历求异或，则可得到两个只出现一次的数字</li></ul></li></ol><p><img src="https://pic.leetcode-cn.com/1611415418-aCzGJI-Picture2.png" alt="picture"></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">singleNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>, m = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)         <span class="hljs-comment">// 1. 遍历异或</span><br>            n ^= num;<br>        <span class="hljs-keyword">while</span>((n &amp; m) == <span class="hljs-number">0</span>)         <span class="hljs-comment">// 2. 循环左移，计算 m</span><br>            m &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums) &#123;       <span class="hljs-comment">// 3. 遍历 nums 分组</span><br>            <span class="hljs-keyword">if</span>(num &amp; m) x ^= num;   <span class="hljs-comment">// 4. 当 num &amp; m != 0</span><br>            <span class="hljs-keyword">else</span> y ^= num;          <span class="hljs-comment">// 4. 当 num &amp; m == 0</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123;x, y&#125;;  <span class="hljs-comment">// 5. 返回出现一次的数字</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="剑指-Offer-56-II-数组中数字出现的次数-II「Medium」"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II「Medium」" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II「Medium」"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指 Offer 56 - II. 数组中数字出现的次数 II「Medium」</a></h1><p>在一个数组 <code>nums</code> 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入：nums = [3,4,3,3]<br>输出：4<br></code></pre></div></td></tr></table></figure><blockquote><p>算法分析：</p><p>方法一：有限状态自动机</p><p>各二进制位的 位运算规则相同 ，因此只需考虑一位即可。如下图所示，对于所有数字中的某二进制位 $1$ 的个数，存在 $3$ 种状态，即对 $3$ 余数为 $0, 1, 2$.</p><ul><li>若输入二进制位 $1$，则状态按照 $0\rightarrow1\rightarrow2\rightarrow0\rightarrow\cdots$ 顺序转换；</li><li>若输入二进制位 $0$，则状态不变.</li></ul><p><img src="https://pic.leetcode-cn.com/1603022900-GNKGMP-Picture2.png" alt="picture"></p><p>如下图所示，由于二进制只能表示 $0,1$，因此需要使用两个二进制位来表示 $3$ 个状态。设此两位分别为 $two,one$，则状态转换变为：$00\rightarrow01\rightarrow10\rightarrow00\rightarrow\cdots$ </p><p>![image-20210304232713519](&#x2F;Users&#x2F;wanglei&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210304232713519.png)</p><p>接下来，需要通过<strong>状态转换表</strong>导出<strong>状态转换的计算公式</strong>。首先回忆一下位运算特点，对于任意二进制位 $x$，有：</p><ul><li>异或运算：<code>x ^ 0 = x</code> ， <code>x ^ 1 = ~x</code> </li><li>与运算：<code>x &amp; 0 = 0</code> ， <code>x &amp; 1 = x</code></li></ul><p>&#x3D;&#x3D;计算 $one$ 方法&#x3D;&#x3D;：</p><p>设当前状态为 $two,one$，此时输入二进制位 $n$。如下图所示，通过对状态表的情况拆分，可推出 $one$ 的计算方法为：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> two == <span class="hljs-number">0</span>:<br>  <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>    one = one<br>  <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>    one = ~one<br><span class="hljs-keyword">if</span> two == <span class="hljs-number">1</span>:<br>    one = <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>引入 <strong>异或运算</strong> ，可将以上拆分简化为：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> two == <span class="hljs-number">0</span>:<br>    one = one ^ n<br><span class="hljs-keyword">if</span> two == <span class="hljs-number">1</span>:<br>    one = <span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>引入 <strong>与运算</strong> ，可继续简化为：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">one = one ^ n &amp; ~two<br></code></pre></div></td></tr></table></figure><p><img src="https://pic.leetcode-cn.com/1603022900-qIFpAR-Picture4.png" alt="p"></p><p>&#x3D;&#x3D;计算 $two$ 方法&#x3D;&#x3D;：</p><p>由于是先计算 $one$ ，因此应在新 $one$ 的基础上计算 $two$.</p><p>如下图所示，修改为新 $one$ 后，得到了新的状态图。观察发现，可以使用同样的方法计算 $two$，即：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">two = two ^ n &amp; ~one<br></code></pre></div></td></tr></table></figure><p><img src="https://pic.leetcode-cn.com/1603022900-hnUxBz-Picture5.png" alt="picture"></p><p>**&#x3D;&#x3D;返回值&#x3D;&#x3D;**：</p><p>以上是对数字的二进制中 “一位” 的分析，而 <code>int</code> 类型的其他 $31$ 位具有相同的运算规则，因此可将以上公式直接套用在 $32$ 位数上。</p><p>遍历完所有数字后，各二进制位都处于状态 $00$ 和状态 $01$ ( 取决于 “只出现一次的数字” 的各二进制位是 $0$ 还是 $1$ )，而此两状态是由 $one$ 来记录的 ( 此两状态下 $twos$ 恒为 $0$ )，因此返回 $ones$ 即可.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ones = <span class="hljs-number">0</span>, twos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;num : nums)&#123;<br>            ones = ones ^ num &amp; ~twos;<br>            twos = twos ^ num &amp; ~ones;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ones;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="剑指-Offer-65-不用加减乘除做加法「Easy」"><a href="#剑指-Offer-65-不用加减乘除做加法「Easy」" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法「Easy」"></a><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">剑指 Offer 65. 不用加减乘除做加法「Easy」</a></h1><p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“&#x2F;” 四则运算符号。</p><p><strong>示例:</strong></p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">输入: a = 1, b = 1<br>输出: 2<br></code></pre></div></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>a</code>, <code>b</code> 均可能是负数或 $0$</li><li>结果不会溢出 $32$ 位整数</li></ul><blockquote><p>算法分析：</p><p>设两数字的二进制形式 $a,b$，求其和 $s&#x3D;a+b$，每一位的计算分为以下四种情况：</p><p>![image-20210305222249494](&#x2F;Users&#x2F;wanglei&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210305222249494.png)</p><p>观察发现，<strong>无进位和</strong> 与 <strong>异或运算</strong> 规律相同，<strong>进位</strong> 和 <strong>与运算</strong> 规律相同 ( 并需左移一位 ) 。因此，无进位和 $n$ 与进位 $c$ 的计算公式如下：<br>$$<br>\left{<br>\begin{aligned}<br>&amp;n&#x3D;a\bigoplus b &amp; 非进位和：异或运算\<br>&amp;c&#x3D;a<del>&amp;</del>b~&lt;&lt;1 &amp; 进位：与运算+左移一位\<br>\end{aligned}<br>\right.<br>$$<br>和 ( $s$ ）&#x3D;（非进位和 $n$ ）+（进位 $c$ ）。即可将 $s&#x3D;a+b$ 转化为：$s&#x3D;a+b\Rightarrow s&#x3D;n+c$.</p><p>循环求 $n$ 和 $c$，直至进位 $c&#x3D;0$；此时 $s&#x3D;n$，返回 $n$ 即可.</p><p><img src="https://pic.leetcode-cn.com/9716b1a1ead21824b8216c7d54910bee4d838c011581f4e3d82a14f71cb392a1-Picture1.png" alt="picture"></p></blockquote><blockquote><p>Q ： 若数字 $a$ 和 $b$ 中有负数，则变成了减法，如何处理？<br>A ： 在计算机系统中，数值一律用 补码 来表示和存储。补码的优势： 加法、减法可以统一处理（CPU只有加法器）。因此，以上方法 同时适用于正数和负数的加法 。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 当进位为 0 时跳出</span><br>            <span class="hljs-type">int</span> c = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// c = 进位</span><br>            a ^= b; <span class="hljs-comment">// a = 非进位和</span><br>            b = c; <span class="hljs-comment">// b = 进位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about priority_queue &amp; heap</title>
    <link href="/2021/01/18/about%20priority_queue%20&amp;%20heap/"/>
    <url>/2021/01/18/about%20priority_queue%20&amp;%20heap/</url>
    
    <content type="html"><![CDATA[<h1 id="about-priority-queue-amp-heap"><a href="#about-priority-queue-amp-heap" class="headerlink" title="about priority_queue &amp; heap"></a>about priority_queue &amp; heap</h1><h2 id="自实现的堆"><a href="#自实现的堆" class="headerlink" title="自实现的堆"></a>自实现的堆</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">min_heap</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">min_heap</span>() &#123; <span class="hljs-comment">//下标从1开始</span><br>        nums.<span class="hljs-built_in">emplace_back</span>(nullhead);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        nums.<span class="hljs-built_in">emplace_back</span>(val);<br>        <span class="hljs-built_in">Shift_up</span>((<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Shift_up</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (index / <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (nums[index/<span class="hljs-number">2</span>] &gt; nums[index]) <span class="hljs-built_in">swap</span>(nums[index], nums[index/<span class="hljs-number">2</span>]); <span class="hljs-comment">//由于向下取整 2i 和 2i+1 对应的双亲只要除2就能到</span><br>            index /= <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">heap_top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;nums[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_delete</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;ERROR&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        nums.<span class="hljs-built_in">erase</span>(nums.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span> + index);<br>        <span class="hljs-built_in">heap_sort</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> index = (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">Shift_up</span>(index);<br>            index --;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_print</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">//用来测试</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            cout &lt;&lt; nums[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><ol><li>上浮「shift_up」操作的关键在于 我们取1开始 两个孩子分别是 2i 和 2i+1 它们俩除2 可以同时到达双亲节点</li><li>我们把上浮定义成 可以指定任何一个下标 上浮。 这样的好处是 之后的 heap_sort 以及 Insert 函数 都很方便写了 「heapsort就是把每个元素都上浮，insert就是加到末尾然后上浮」</li><li>要注意的是 下标从1 开始 返回top的时候不要用front！</li></ol></blockquote><p>⚠️ 优先队列是一种数据结构 但堆不是 堆是优先队列的内部实现方式</p><h2 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h2><blockquote><ul><li><code>priority_queue&lt;int&gt; q;//等价于默认，从大到小排</code></li><li><code>priority_queue&lt;int, vector&lt;int&gt;,  less&lt;int&gt;&gt; q;//等价于默认，从大到小排</code></li><li><code>priority_queue&lt;int, vector&lt;int&gt;,  greater&lt;int&gt;&gt; q; 　　//通过操作，按照元素从小到大的顺序出队</code></li><li>priority_queue&lt;TreeNode*, vector&lt;TreeNode*&gt;,  decltype(cmp)&gt; q{cmp};</li></ul></blockquote><h2 id="自定义优先级"><a href="#自定义优先级" class="headerlink" title="自定义优先级"></a>自定义优先级</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;    <span class="hljs-comment">//通过传入不同类型来定义不同类型优先级</span><br>        <span class="hljs-keyword">return</span> a &gt; b;    <span class="hljs-comment">//最小值优先</span><br>      <span class="hljs-comment">//return a &lt; b; // 最大值优先</span><br>    &#125;<br>&#125;;<br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, cmp &gt; q;<br><br><span class="hljs-comment">//或者可以使用这种方式定义</span><br><span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">const</span> TreeNode* a, <span class="hljs-type">const</span> TreeNode* b) &#123;<br>    <span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val;<br>&#125;;<br>priority_queue&lt;TreeNode*, vector&lt;TreeNode*&gt;,  <span class="hljs-keyword">decltype</span>(cmp)&gt; q&#123;cmp&#125;;<br></code></pre></td></tr></table></figure><h2 id="自定义结构体、优先级"><a href="#自定义结构体、优先级" class="headerlink" title="自定义结构体、优先级"></a>自定义结构体、优先级</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> priority;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node &amp;a, <span class="hljs-type">const</span> node &amp;b) &#123;<br>        <span class="hljs-keyword">return</span> a.priority &lt; b.priority;<br>    &#125;<br>    <span class="hljs-comment">/* 这样写也可以</span><br><span class="hljs-comment">    bool operator &lt; (const node &amp;a) const &#123;</span><br><span class="hljs-comment">        return priority &lt; a.priority;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>&#125;;<br><br>priority_queue&lt;node&gt; q;<br></code></pre></td></tr></table></figure><blockquote><p>因为标准库默认使用元素类型的 <code>&lt;</code> 操作符来确定它们之间的优先级关系。而且自定义类型的 <code>&lt;</code> 操作符与 <code>&gt;</code> 操作符并无直接联系，故会编译不过。</p><p>错误示范：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> priority;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &gt; (<span class="hljs-type">const</span> node &amp;a, <span class="hljs-type">const</span> node &amp;b) &#123;   <span class="hljs-comment">//错误示范</span><br>        <span class="hljs-keyword">return</span> a.priority &gt; b.priority;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote><h2 id="decltype关键字-C-11"><a href="#decltype关键字-C-11" class="headerlink" title="decltype关键字 ( C++11 )"></a>decltype关键字 ( C++11 )</h2><blockquote><p><a href="https://baike.baidu.com/item/decltype">decltype</a>，在C++中，作为操作符，用于查询表达式的数据类型.</p><p>​    有时我们希望从表达式的<strong>类型推断</strong>出要定义的<strong>变量类型</strong>，但是不想用该表达式的值初始化变量 ( 如果要初始化就用auto了 )。为了满足这一需求，C++11新标准引入了decltype类型说明符，它的作用是<strong>选择并返回操作数的数据类型</strong>，在此过程中，编译器<strong>分析</strong>表达式并得到它的类型，却<strong>不实际计算</strong>表达式的值。</p></blockquote><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> tempA = <span class="hljs-number">2</span>;<br>    <br>    <span class="hljs-comment">/*1.dclTempA为int*/</span><br>    <span class="hljs-keyword">decltype</span>(tempA) dclTempA;<br>    <span class="hljs-comment">/*2.dclTempB为int，对于getSize根本没有定义，但是程序依旧正常，因为decltype只做分析，并不调用getSize，*/</span><br>    <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">getSize</span>()) dclTempB;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="与-const-结合"><a href="#与-const-结合" class="headerlink" title="与 const 结合"></a>与 const 结合</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> tempA = <span class="hljs-number">3.0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> ctempA = <span class="hljs-number">5.0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> ctempB = <span class="hljs-number">6.0</span>；<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> *<span class="hljs-type">const</span> cptrTempA = &amp;ctempA;<br><span class="hljs-comment">/*1.dclTempA推断为const double（保留顶层const，此处与auto不同）*/</span><br><span class="hljs-keyword">decltype</span>(ctempA) dclTempA = <span class="hljs-number">4.1</span>;<br><span class="hljs-comment">/*2.dclTempA为const double，不能对其赋值，编译不过*/</span><br>dclTempA = <span class="hljs-number">5</span>;<br><span class="hljs-comment">/*3.dclTempB推断为const double * const*/</span><br><span class="hljs-keyword">decltype</span>(cptrTempA) dclTempB = &amp;ctempA;<br><span class="hljs-comment">/*4.输出为4（32位计算机）和5*/</span><br>cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(dclTempB)&lt;&lt;<span class="hljs-string">&quot;    &quot;</span>&lt;&lt;*dclTempB&lt;&lt;endl;<br><span class="hljs-comment">/*5.保留顶层const，不能修改指针指向的对象，编译不过*/</span><br>dclTempB = &amp;ctempB;<br><span class="hljs-comment">/*6.保留底层const，不能修改指针指向的对象的值，编译不过*/</span><br>*dclTempB = <span class="hljs-number">7.0</span>;<br></code></pre></td></tr></table></figure><h3 id="与引用结合"><a href="#与引用结合" class="headerlink" title="与引用结合"></a>与引用结合</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> tempA = <span class="hljs-number">0</span>, &amp;refTempA = tempA;<br><br><span class="hljs-comment">/*1.dclTempA为引用，绑定到tempA*/</span><br><span class="hljs-keyword">decltype</span>(refTempA) dclTempA = tempA;<br><span class="hljs-comment">/*2.dclTempB为引用，必须绑定到变量，编译不过*/</span><br><span class="hljs-keyword">decltype</span>(refTempA) dclTempB = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/*3.dclTempC为引用，必须初始化，编译不过*/</span><br><span class="hljs-keyword">decltype</span>(refTempA) dclTempC;<br><span class="hljs-comment">/*4.双层括号表示引用，dclTempD为引用，绑定到tempA*/</span><br><span class="hljs-keyword">decltype</span>((tempA)) dclTempD = tempA;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ctempA = <span class="hljs-number">1</span>, &amp;crefTempA = ctempA;<br><br><span class="hljs-comment">/*5.dclTempE为常量引用，可以绑定到普通变量tempA*/</span><br><span class="hljs-keyword">decltype</span>(crefTempA) dclTempE = tempA;<br><span class="hljs-comment">/*6.dclTempF为常量引用，可以绑定到常量ctempA*/</span><br><span class="hljs-keyword">decltype</span>(crefTempA) dclTempF = ctempA;<br><span class="hljs-comment">/*7.dclTempG为常量引用，绑定到一个临时变量*/</span><br><span class="hljs-keyword">decltype</span>(crefTempA) dclTempG = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/*8.dclTempH为常量引用，必须初始化，编译不过*/</span><br><span class="hljs-keyword">decltype</span>(crefTempA) dclTempH;<br><span class="hljs-comment">/*9.双层括号表示引用,dclTempI为常量引用，可以绑定到普通变量tempA*/</span><br><span class="hljs-keyword">decltype</span>((ctempA))  dclTempI = ctempA;<br></code></pre></td></tr></table></figure><h3 id="与指针结合"><a href="#与指针结合" class="headerlink" title="与指针结合"></a>与指针结合</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> tempA = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> *ptrTempA = &amp;tempA;<br><span class="hljs-comment">/*1.常规使用dclTempA为一个int *的指针*/</span><br><span class="hljs-keyword">decltype</span>(ptrTempA) dclTempA;<br><span class="hljs-comment">/*2.需要特别注意，表达式内容为解引用操作，dclTempB为一个引用，引用必须初始化，故编译不过*/</span><br><span class="hljs-keyword">decltype</span>(*ptrTempA) dclTempB;<br></code></pre></td></tr></table></figure><h3 id="decltype-总结"><a href="#decltype-总结" class="headerlink" title="decltype 总结"></a>decltype 总结</h3><blockquote><p>decltype和auto都可以用来推断类型，但是二者有几处明显的差异：</p><p>1.<code>auto</code><strong>忽略</strong>顶层<code>const</code>，<code>decltype</code> <strong>保留</strong>顶层 <code>const</code>；</p><p>2.对<strong>引用操作</strong>，<code>auto</code>推断出<strong>原有类型</strong>，<code>decltype</code>推断出<strong>引用</strong>；</p><p>3.对<strong>解引用操作</strong>，<code>auto</code>推断出<strong>原有类型</strong>，<code>decltype</code>推断出<strong>引用</strong>；</p><p>4.<code>auto</code>推断时会<strong>实际执行</strong>，<code>decltype</code><strong>不会执行</strong>，<strong>只做分析</strong>。</p><p>总之在使用中过程中和<code>const</code>、引用和指针结合时需要特别小心。</p></blockquote><h2 id="Lambda-与-decltype-结合"><a href="#Lambda-与-decltype-结合" class="headerlink" title="Lambda 与 decltype 结合"></a>Lambda 与 decltype 结合</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">counts</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">auto</span> cmp = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; letter1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; letter2) &#123;<br><span class="hljs-keyword">return</span> counts[letter1 - <span class="hljs-string">&#x27;a&#x27;</span>]  &lt; counts[letter2 - <span class="hljs-string">&#x27;a&#x27;</span>];<br>&#125;;<br>priority_queue&lt;<span class="hljs-type">char</span>, vector&lt;<span class="hljs-type">char</span>&gt;,  <span class="hljs-keyword">decltype</span>(cmp)&gt; qu&#123;cmp&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web 开发技术</title>
    <link href="/2021/01/04/Web%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"/>
    <url>/2021/01/04/Web%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Web开发技术"><a href="#Web开发技术" class="headerlink" title="Web开发技术"></a>Web开发技术</h1><h3 id="远程过程调用-RPC-「Remote-Procedure-Call」"><a href="#远程过程调用-RPC-「Remote-Procedure-Call」" class="headerlink" title="远程过程调用 RPC 「Remote Procedure Call」"></a>远程过程调用 RPC 「Remote Procedure Call」</h3><p><strong>&#x3D;&#x3D;RPC模式 以及利用此模式制作的RPC中间件(通信插件) 旨在简化Web开发，使得程序员可以使用高级语言来建构程序(特别是网络分布式程序 如C&#x2F;S架构) 而不是利用API来调用&#x3D;&#x3D;</strong></p><ul><li><code>套接字API</code> 是底层通信过程最直接的抽象 直接面向TCP&#x2F;IP通信过程 所以即使是使用API来调用底层硬件<strong>仍然比较麻烦</strong> 并且会出现异常 好在<em><strong>API不是网络应用程序间通信实现的唯一方法</strong></em></li><li><code>procedure 过程</code> 指能解决一系列相关人物的可调用程序，(传统面向过程编程里的子程序)</li><li><code>procedure call 过程调用</code> 是面向过程编程机制 每个过程利用一组形式化参数定义，当过程被调用时 调用者要提供与形参匹配的实参(直接可以理解成 函数 和函数的调用)</li><li><code>RPC</code> <ul><li>是最早被提出和开发的C&#x2F;S通信工具的机制 </li><li>使用<strong>传统编程语言结构</strong>向开发者提供接口，而不像API那样需要利用显式通信原语</li><li>RPC允许程序员将过程适配到多个主机上，通过不同计算机间进行的远程过程调用自动生产代码并完成通信</li></ul></li></ul><h4 id="RPC模式规范"><a href="#RPC模式规范" class="headerlink" title="RPC模式规范"></a>RPC模式规范</h4><ul><li>我们需要的 RPC模式在现有的编程语言中扩展，设计了一种符合<strong>高级语言编写规范(考虑到不同计算机的适配问题 需要用高级语言 汇编不行)</strong> 并能自动处理网络通信细节</li><li>RPC允许客户端 <strong>跨过网络调用服务器过程 在这种情况下就可以使用<code>RPC工具</code>，它将生成处理所需的通信过程插件<code>communication stub/proxy</code> 真正的通信任务交给插件来完成 如下图</strong><ul><li>在使用通信插件后 程序员被允许在忽略底层通信拓扑的基础上使用高级语言和成熟的编程方法来进行架构 提高软件的可靠性<ul><li>客户端 $\Rightarrow$ 客户插件 + 客户端主程序</li><li>服务器 $\Rightarrow$ 服务器插件 + 远程过程</li></ul></li></ul></li><li><code>中间件 middleware</code> 是介于传统应用程序和系统平台(os和hardware system) 之间的通用服务工具 主要的作用是以下三点 我认为这和API有很多相似之处<ul><li>提供标准接口 ｜ 支持分布式计算(负载均衡) ｜ 支持跨平台</li></ul></li></ul><hr>]]></content>
    
    
    
    <tags>
      
      <tag>互联网原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Email &amp;&amp; WWW</title>
    <link href="/2021/01/04/Email-&amp;&amp;-WWW/"/>
    <url>/2021/01/04/Email-&amp;&amp;-WWW/</url>
    
    <content type="html"><![CDATA[<h1 id="E-mail-amp-amp-WWW"><a href="#E-mail-amp-amp-WWW" class="headerlink" title="E-mail &amp;&amp; WWW"></a>E-mail &amp;&amp; WWW</h1><h1 id="E-MAIL-系统概述"><a href="#E-MAIL-系统概述" class="headerlink" title="E-MAIL 系统概述"></a>E-MAIL 系统概述</h1><h3 id="⚠️-邮件系统-在大型机上不同邮箱移动报文时-就已经出现了-它的出现至少不晚于Internet"><a href="#⚠️-邮件系统-在大型机上不同邮箱移动报文时-就已经出现了-它的出现至少不晚于Internet" class="headerlink" title="⚠️ 邮件系统 在大型机上不同邮箱移动报文时 就已经出现了 (它的出现至少不晚于Internet)"></a>⚠️ 邮件系统 在大型机上不同邮箱移动报文时 就已经出现了 (它的出现至少不晚于Internet)</h3><h3 id="而我们使用的-所谓-x3D-x3D-E-Mail-则是-x3D-x3D-x3D-x3D-特指-x3D-x3D-x3D-x3D-通过计算机网络进行通信-x3D-x3D-的-电子化信息传递系统"><a href="#而我们使用的-所谓-x3D-x3D-E-Mail-则是-x3D-x3D-x3D-x3D-特指-x3D-x3D-x3D-x3D-通过计算机网络进行通信-x3D-x3D-的-电子化信息传递系统" class="headerlink" title="而我们使用的 所谓 &#x3D;&#x3D;E-Mail 则是&#x3D;&#x3D; &#x3D;&#x3D;特指&#x3D;&#x3D;&#x3D;&#x3D;通过计算机网络进行通信&#x3D;&#x3D;的 电子化信息传递系统"></a>而我们使用的 所谓 &#x3D;&#x3D;E-Mail 则是&#x3D;&#x3D; &#x3D;&#x3D;特指&#x3D;&#x3D;&#x3D;&#x3D;通过计算机网络进行通信&#x3D;&#x3D;的 电子化信息传递系统</h3><h3 id="E-Mail-是-Internet上-使用最广泛的应用"><a href="#E-Mail-是-Internet上-使用最广泛的应用" class="headerlink" title="E-Mail 是 Internet上 使用最广泛的应用"></a>E-Mail 是 Internet上 使用最广泛的应用</h3><p>E-Mail定义了SMTP 和 MIME </p><h5 id="电子邮件需要实现以下的几个功能"><a href="#电子邮件需要实现以下的几个功能" class="headerlink" title="电子邮件需要实现以下的几个功能"></a>电子邮件需要实现以下的几个功能</h5><ol><li>创建电子邮件</li><li>发送和接收邮件</li><li>管理邮件 「管理：包括回复 转发 删除 存储 等等」</li><li>保证邮箱的私有性质 「虽然任何人都可以在邮箱里放入邮件 但只有邮箱的拥有者可以查看」</li></ol><h3 id="E-Mail的地址结构"><a href="#E-Mail的地址结构" class="headerlink" title="E-Mail的地址结构"></a>E-Mail的地址结构</h3><p>一般认为 邮箱地址要保证唯一  需要 <strong>邮箱名+存放邮箱的主机域名</strong></p><p><a href="mailto:&#49;&#51;&#53;&#x37;&#48;&#48;&#48;&#x32;&#x37;&#x34;&#x40;&#113;&#113;&#46;&#99;&#x6f;&#x6d;">&#49;&#51;&#53;&#x37;&#48;&#48;&#48;&#x32;&#x37;&#x34;&#x40;&#113;&#113;&#46;&#99;&#x6f;&#x6d;</a> $\Rightarrow$ 1357000274 为邮箱名 ｜  qq.com 存放邮箱的主机域名</p><h2 id="SMTP-Simple-Mail-Transfer-Protocol"><a href="#SMTP-Simple-Mail-Transfer-Protocol" class="headerlink" title="SMTP Simple Mail Transfer Protocol"></a>SMTP Simple Mail Transfer Protocol</h2><ul><li>1981年出现 **它只能传输字符 信息主体被限制为 ASCII码 **</li><li>SMTP 规定相互通信的 C&#x2F;S端两个 SMTP进程间如何进行信息交互</li><li>⚠️ SMTP没有定义 邮件采用何种格式 以及 如何存储邮件 发送和递交邮件</li></ul><h3 id="SMTP传送的过程"><a href="#SMTP传送的过程" class="headerlink" title="SMTP传送的过程"></a>SMTP传送的过程</h3><ul><li>类似上图 用户按照格式填装邮件 输入发送命令后 电子邮件接口软件 首先将这个邮件放在 邮件暂存队列里</li><li>对邮件的控制权此时来到了 <strong>邮件传输程序</strong>这里。 它将判断这封邮件发往哪里。「可以发送给 本地的计算机」</li><li>如果要向互联网远程用户发送邮件 在确认连接互联网后 <strong>邮件传输软件作为客户 和 邮件服务器进行通信(它在远程计算机上)， 传输软件会将 邮件的 一个&#x3D;&#x3D;<em>副本</em>&#x3D;&#x3D;发送到邮件服务器上</strong></li><li>邮件现在来到了邮件缓存区 发送方SMTP软件会定时(几分钟或几时分钟)扫描缓冲区队列</li><li>如果SMTP软件检测到了待发邮件 它就会 <strong>作为客户和目的计算机SMTP服务器端口(25)建立TCP连接</strong><ul><li>服务器发出 220 Service ready  客户端发送 helo + 邮箱+主机名；</li><li>服务器如果可以接收 会应答 250 OK 否则返回代码 421 Service not available | 451 &#x2F; 452 等异常命令<ul><li>SMTP定义了 14条命令(由4个字母组成) 和 21种应答(由3个数字开始)</li></ul></li><li>开始传输邮件副本</li></ul></li><li><strong>由客户端在发送结束后 通过 QUIT 命令释放TCP连接</strong></li></ul><h3 id="SMTP-是复杂的协商交互协议-通常会在后台工作-因为邮件系统从来就不是一个实时传输新系统"><a href="#SMTP-是复杂的协商交互协议-通常会在后台工作-因为邮件系统从来就不是一个实时传输新系统" class="headerlink" title="SMTP 是复杂的协商交互协议 通常会在后台工作(因为邮件系统从来就不是一个实时传输新系统)"></a>SMTP 是复杂的协商交互协议 通常会在后台工作(因为邮件系统从来就不是一个实时传输新系统)</h3><h3 id="SMTP可以用在两个用户之间-但主流情况下-使用-邮局和中转的概念「分发-转发-列表-按照列表分发-多重接收-同一个计算机上的多个邮箱-只建立一个TCP连接-」"><a href="#SMTP可以用在两个用户之间-但主流情况下-使用-邮局和中转的概念「分发-转发-列表-按照列表分发-多重接收-同一个计算机上的多个邮箱-只建立一个TCP连接-」" class="headerlink" title="SMTP可以用在两个用户之间 但主流情况下 使用 邮局和中转的概念「分发 转发 列表(按照列表分发) 多重接收(同一个计算机上的多个邮箱 只建立一个TCP连接)」"></a>SMTP可以用在两个用户之间 但主流情况下 使用 邮局和中转的概念「分发 转发 列表(按照列表分发) 多重接收(同一个计算机上的多个邮箱 只建立一个TCP连接)」</h3><p><strong>邮件中继：</strong> 当需要进行 <strong>大量的</strong>的邮件转发&#x2F;分发时 一个独立且能力更强的计算机<strong>E-Mail Gateway &#x2F; E-Mail Relay</strong> 出现了</p><p>组织地址：它帮助每个自己管理下的计算机完成邮件的收发「这个组织通常会运行一个组织网关来管理」</p><p><strong>邮件网关实际隔离外部邮件地址与内部邮件地址(计算机与用户)</strong></p><h2 id="MIME-Multipurpose-Internet-Mail-Extension"><a href="#MIME-Multipurpose-Internet-Mail-Extension" class="headerlink" title="MIME Multipurpose Internet Mail Extension"></a>MIME Multipurpose Internet Mail Extension</h2><h3 id="邮件在这个协议里-被允许-分成几个部分-每个部分可以通过不同的格式来传送"><a href="#邮件在这个协议里-被允许-分成几个部分-每个部分可以通过不同的格式来传送" class="headerlink" title="邮件在这个协议里 被允许 分成几个部分 每个部分可以通过不同的格式来传送"></a>邮件在这个协议里 被允许 分成几个部分 每个部分可以通过不同的格式来传送</h3><ul><li>头部 「发、收地址 日期 主题等条目  每个头部行开始是 行关键字和冒号 + 信息」</li><li>空行 用来分割 头部和信息文本</li><li>信息文本   包含了 多媒体二进制信息 可以实现任意编辑</li></ul><h2 id="存储传送方式-非端到端直接传送-｜-POP-amp-IMAP"><a href="#存储传送方式-非端到端直接传送-｜-POP-amp-IMAP" class="headerlink" title="存储传送方式(非端到端直接传送) ｜ POP &amp; IMAP"></a>存储传送方式(非端到端直接传送) ｜ POP &amp; IMAP</h2><p>在目前邮箱通常被放在电子邮件系统服务器计算机上 接受者要自己去邮件服务器 读自己的邮件 而不是它主动发给你</p><h3 id="常用的-远程读取的邮局协议POP-Post-Office-Protocol-1996-POP3-IMAP-Internet-Mail-Access-Protocol"><a href="#常用的-远程读取的邮局协议POP-Post-Office-Protocol-1996-POP3-IMAP-Internet-Mail-Access-Protocol" class="headerlink" title="常用的 远程读取的邮局协议POP(Post Office Protocol)(1996 POP3) | IMAP(Internet Mail Access Protocol)"></a>常用的 远程读取的邮局协议POP(Post Office Protocol)(1996 POP3) | IMAP(Internet Mail Access Protocol)</h3><p>用户计算机的电子邮件软件作为POP服务器的客户 来存取</p><h3 id="POP相比SMTP的优越性-rightarrow-POP不进行传输交互"><a href="#POP相比SMTP的优越性-rightarrow-POP不进行传输交互" class="headerlink" title="POP相比SMTP的优越性 $\rightarrow$ POP不进行传输交互"></a>POP相比SMTP的优越性 $\rightarrow$ POP不进行传输交互</h3><p>pop主要完成 创建连接 用户认证 事务操作(列出 取回并删除等等) ｜ 邮件将在被读取后的不久被POP删除</p><h3 id="IMAP-2003-IMAP4-和POP3一样采用C-x2F-S方式来工作-但比POP3复杂-用户能进行更多的操作-比如只看首部-并且在不下令删除的情况下保留用户的邮件"><a href="#IMAP-2003-IMAP4-和POP3一样采用C-x2F-S方式来工作-但比POP3复杂-用户能进行更多的操作-比如只看首部-并且在不下令删除的情况下保留用户的邮件" class="headerlink" title="IMAP (2003 IMAP4) 和POP3一样采用C&#x2F;S方式来工作 但比POP3复杂(用户能进行更多的操作 比如只看首部) 并且在不下令删除的情况下保留用户的邮件"></a>IMAP (2003 IMAP4) 和POP3一样采用C&#x2F;S方式来工作 但比POP3复杂(用户能进行更多的操作 比如只看首部) 并且在不下令删除的情况下保留用户的邮件</h3><h3 id="目前-具有大邮箱数据库和SMTP-x2F-POP服务器-中继功能的计算机-相当于电子邮局"><a href="#目前-具有大邮箱数据库和SMTP-x2F-POP服务器-中继功能的计算机-相当于电子邮局" class="headerlink" title="目前 具有大邮箱数据库和SMTP&#x2F;POP服务器+中继功能的计算机 相当于电子邮局"></a>目前 具有大邮箱数据库和SMTP&#x2F;POP服务器+中继功能的计算机 相当于电子邮局</h3><h2 id="E-Mail传递的发展"><a href="#E-Mail传递的发展" class="headerlink" title="E-Mail传递的发展"></a>E-Mail传递的发展</h2><ol><li>两个主机间点对点的 SMTP邮件直接收发</li><li>邮件网关(中继) 和组织邮件地址 出现中间管理服务</li><li>电子邮局出现 形成现今的电子邮件系统框架</li><li>SMTP完成发送 POP&#x2F;IMAP完成电子邮局登陆 读取和管理邮件</li></ol><h2 id="MIME协议和实现"><a href="#MIME协议和实现" class="headerlink" title="MIME协议和实现"></a>MIME协议和实现</h2><p>现在使用的 是多用途Internet邮件扩充MIME协议</p><h3 id="MIME完成的是传输-ASCII码之外的-二进制信息-声音-图像-影视信号也可以发送了"><a href="#MIME完成的是传输-ASCII码之外的-二进制信息-声音-图像-影视信号也可以发送了" class="headerlink" title="MIME完成的是传输 ASCII码之外的 二进制信息(声音 图像 影视信号也可以发送了)"></a>MIME完成的是传输 ASCII码之外的 二进制信息(声音 图像 影视信号也可以发送了)</h3><p>MIME的设计思路是不推翻SMTP架构而对其微调</p><p>做法是：</p><blockquote><p>将所有不同类型的二进制数据<strong>分段编码</strong>为7位ASCII码 然后用SMTP作为一般的文本来发送 然后在接收端转换回去</p></blockquote><p>在使用MIME时发送方会在邮件头部增加附加行 这一行将会指明这个报文遵循的MIME格式 数据类型和编码算法</p><p>比如 MIME-Version:1.0 </p><p>MIME还允许发送方将报文分成多个部分(它们可以使用不一样的编码方法) 实际上就是 粘贴多个附件</p><h3 id="MIME具有-兼容性「SMTP不需要解析MIME的编码-所以和早期的SMTP兼容」-和-灵活性「不规定编码方法和名称-」"><a href="#MIME具有-兼容性「SMTP不需要解析MIME的编码-所以和早期的SMTP兼容」-和-灵活性「不规定编码方法和名称-」" class="headerlink" title="MIME具有 兼容性「SMTP不需要解析MIME的编码 所以和早期的SMTP兼容」 和 灵活性「不规定编码方法和名称 」"></a>MIME具有 兼容性「SMTP不需要解析MIME的编码 所以和早期的SMTP兼容」 和 灵活性「不规定编码方法和名称 」</h3><hr><blockquote><p><strong>1、为什么说电子邮件的使用超过了因特网的范围</strong></p><p>电子邮件用户计算机完全可以不是Internet用户(没有因特网域名或IP地址) 而可以是在某个Internet计算机上注册了邮箱的普通计算机。 甚至还可以只和本地的传输邮件。</p></blockquote><blockquote><p><strong>2、当你发送电子邮件给不同电子邮局用户时，需要经过哪些必要的环节?请画图 示意。</strong></p></blockquote><blockquote><p><strong>3、早期电子邮件直接在收发计算机之间传输完成，试说明这种模式的优缺点。</strong></p><p>优点：效率高 是即时的传输 实现简单</p><p>缺点：</p><ol><li><p>接收的计算机需要开着(并且要么连接互联网，要么和发送计算机直接相连)， 这意味着接收方需要事先知道要接收邮件，也就丧失了邮件系统的非实时性。</p></li><li><p>常用的个人计算机无法配置邮件服务器，这使得利用邮件服务器完成的功能(如 分发 转发 列表) 收发计算机都无法完成，使得邮件系统可用性大幅下降</p></li></ol></blockquote><blockquote><p><strong>4、通过目前电子邮件系统发往某邮件，常常发现传输时间是不确定的，有时快而 有时慢，为什么?</strong></p><p>因为用户邮件在发端是定时扫描、建立连接和批处理传输的；且发送到目的邮局服务器的邮箱后，需要用户登陆后取回；即E-mail系统工作过程不是一个实际收发的端到端连接通信，而是中间邮局的非实时处理，所以邮件传递快慢取决于个环节等待时间。</p></blockquote><blockquote><p> <strong>5、一个组织的电子邮件系统网关，通常具有什么功能</strong></p><ol><li>分发和管理组织内的电子邮件地址和电子邮箱</li><li>实现组织内部和组织内外之间进行大批量邮件分发或转发功能</li><li>对邮件进行一定的过滤和筛选(去除垃圾和病毒邮件)</li></ol></blockquote><blockquote><p><strong>6、SMTP的主要作用</strong></p><p>电子邮件客户软件定时扫描邮件暂存队列，有待发邮件时，SMTP客户和目的地计算机SMTP服务器建立TCP连接。然后SMTP协议进行通过ASCII码命令和应答逐步协商，最后客户发出邮件副本，服务器接收副本。</p></blockquote><blockquote><p><strong>7、POP的主要作用</strong> 见POP介绍</p></blockquote><blockquote><p><strong>8、SMTP可以传递非ASCII码信息吗</strong> 当然可以了。。MIME</p></blockquote><hr><h1 id="WWW-概述"><a href="#WWW-概述" class="headerlink" title="WWW 概述"></a>WWW 概述</h1><h2 id="World-Wide-Web-是Internet上最受欢迎-应用-其思路来自CERN-欧洲粒子物理研究中心"><a href="#World-Wide-Web-是Internet上最受欢迎-应用-其思路来自CERN-欧洲粒子物理研究中心" class="headerlink" title="World Wide Web 是Internet上最受欢迎 应用  其思路来自CERN(欧洲粒子物理研究中心)"></a>World Wide Web 是Internet上最受欢迎 应用  其思路来自CERN(欧洲粒子物理研究中心)</h2><p>Tim Berners-Lee 在1990年开发了第一个基于超文本的分布式信息系统  1991年Gopher在Internet上运行</p><p>第一个图形界面的浏览器产生于1993年「Mosaic」</p><p><strong>www的设计基于超文本 HTML HTTP和浏览器</strong></p><h2 id="超文本-x3D-一般文本-到其他文档的链接-「其数据结构是指针链接的-网状结构-⚠️和树状区分-」"><a href="#超文本-x3D-一般文本-到其他文档的链接-「其数据结构是指针链接的-网状结构-⚠️和树状区分-」" class="headerlink" title="超文本 &#x3D;  一般文本 + 到其他文档的链接 「其数据结构是指针链接的 网状结构(⚠️和树状区分)」"></a>超文本 &#x3D;  一般文本 + 到其他文档的链接 「其数据结构是指针链接的 网状结构(⚠️和树状区分)」</h2><ul><li><p>超媒体 $\Rightarrow$ 超文本 + 图像、声音、视频的链接 (即把超文本扩展为更多的媒体) 「它们被总称为 Web文档」</p><ul><li><em>所谓的 Web文档IE(也被称为HTML文档) $\Rightarrow$ 网页</em></li></ul></li><li><p><em><strong>超文本和超媒体 决定了WWW是 非线性、联想式的文档集合 和一个布满链接的信息网</strong></em></p></li><li><h3 id="所谓的-Web-指的是由超文本-连接而成的信息集合-而WWW则是指-在世界范围内分布的Web服务器的集合"><a href="#所谓的-Web-指的是由超文本-连接而成的信息集合-而WWW则是指-在世界范围内分布的Web服务器的集合" class="headerlink" title="所谓的 Web 指的是由超文本 连接而成的信息集合  而WWW则是指 在世界范围内分布的Web服务器的集合"></a>所谓的 Web 指的是由超文本 连接而成的信息集合  而WWW则是指 在世界范围内分布的Web服务器的集合</h3><ul><li>WWW &#x3D;&gt; 建立在超文本和超媒体基础上的 全球分布的 <strong>在线式</strong>的信息网 (这一概念有时会和Web混用)</li><li>Web服务器同时也集成了E-Mail FTP TELNET等服务</li></ul></li></ul><h2 id="HTML-Hypertext-MakeUp-Language-超文本标记语言-用来创建和识别标准的-Web文档"><a href="#HTML-Hypertext-MakeUp-Language-超文本标记语言-用来创建和识别标准的-Web文档" class="headerlink" title="HTML Hypertext MakeUp Language 超文本标记语言      用来创建和识别标准的 Web文档"></a>HTML Hypertext MakeUp Language 超文本标记语言      用来创建和识别标准的 Web文档</h2><ul><li><h3 id="标记语言-Rightarrow-在文本中嵌入一系列-控制符号-使得文件按照作者的想法-显示或者打印"><a href="#标记语言-Rightarrow-在文本中嵌入一系列-控制符号-使得文件按照作者的想法-显示或者打印" class="headerlink" title="标记语言 $\Rightarrow$ 在文本中嵌入一系列 控制符号 使得文件按照作者的想法 显示或者打印"></a>标记语言 $\Rightarrow$ 在文本中嵌入一系列 控制符号 使得文件按照作者的想法 显示或者打印</h3></li><li><h3 id="HTML和普通的标记语言区别-Rightarrow-在它们的基础上-扩展了-x3D-x3D-超文本引用-x3D-x3D-通过点击实现自动跳转"><a href="#HTML和普通的标记语言区别-Rightarrow-在它们的基础上-扩展了-x3D-x3D-超文本引用-x3D-x3D-通过点击实现自动跳转" class="headerlink" title="HTML和普通的标记语言区别$\Rightarrow$在它们的基础上 扩展了 &#x3D;&#x3D;超文本引用&#x3D;&#x3D;(通过点击实现自动跳转)"></a>HTML和普通的标记语言区别$\Rightarrow$在它们的基础上 扩展了 &#x3D;&#x3D;超文本引用&#x3D;&#x3D;(通过点击实现自动跳转)</h3></li><li><p>「Web文档的格式 一般情况下 就是 HTML格式  当然也支持HTML以外的格式」</p><ul><li>超文本引用的原理：文本中被预先设置指向另一个文档的被动指针(被动是指 需要用户主动选择)</li><li><strong><em>任何内容</em>都可以作为超文本引用可选项</strong>(声音 图像也是可以的) 而这种机制 被称为 anchor <em><strong>锚</strong></em></li></ul></li><li><p>当然 除了利用<strong>超文本引用</strong>来实现定位之外  URL的应用也十分广泛</p></li></ul><h2 id="通过-URL-Uniform-精确-Resource-Locater-实现网页的定位-「见sp-edition-互联网传奇」"><a href="#通过-URL-Uniform-精确-Resource-Locater-实现网页的定位-「见sp-edition-互联网传奇」" class="headerlink" title="通过 URL Uniform(精确) Resource Locater 实现网页的定位 「见sp edition 互联网传奇」"></a>通过 URL Uniform(精确) Resource Locater 实现网页的定位 「见sp edition 互联网传奇」</h2><p>找到存放Web的计算机 $\Rightarrow$ 找到是这个计算机中存放的哪个网页 $\Rightarrow$ 确认访问此网页需要的协议 $\Rightarrow$ 对接网页显示的格式</p><p>URL的一般格式：</p><p>$$<br>协议:&#x2F;&#x2F;计算机域名:端口号(optional)&#x2F;路径&#x2F;Web文档名称<br>$$<br>「端口号 http&#x2F;Web &#x3D;&gt; 80 ； FTP &#x3D;&gt; 21 在采用默认端口号时 可以省略」</p><p><em><strong>值得注意的是 虽然URL输入时 可以大小写， 但实际上URL不区分大小写</strong></em></p><p><strong>使用URL定位时 因为必须指明特定的主机 如果访问量太大 会炸。 这时只能 就近访问和负载均衡。 而正在发展的URI(Universal Resource Indentifier) 尝试将资源名称和主机位置分离开</strong></p><h2 id="网页传输-和-HTTP-协议"><a href="#网页传输-和-HTTP-协议" class="headerlink" title="网页传输 和 HTTP 协议"></a>网页传输 和 HTTP 协议</h2><h3 id="我们先把浏览器和客户等同起来，-这时浏览器和Web服务器的交流就属于典型的C-x2F-S模式-但连接时间短-不记忆状态"><a href="#我们先把浏览器和客户等同起来，-这时浏览器和Web服务器的交流就属于典型的C-x2F-S模式-但连接时间短-不记忆状态" class="headerlink" title="我们先把浏览器和客户等同起来， 这时浏览器和Web服务器的交流就属于典型的C&#x2F;S模式(但连接时间短 不记忆状态)"></a>我们先把浏览器和客户等同起来， 这时浏览器和Web服务器的交流就属于典型的C&#x2F;S模式(但连接时间短 不记忆状态)</h3><blockquote><ul><li>浏览器作为客户 根据URL指定的域名 向DNS服务器请求解析 $\Rightarrow$ 得到目的IP地址</li><li>浏览器作为客户 和目的IP对应的计算机(和这个计算机上的 Web服务器) 建立TCP连接</li><li>浏览器作为客户 向Web服务器发送请求获取Web文档命令 (GET)</li><li>Web服务器响应请求 然后返回网页(Web文档)</li><li>浏览器接收完成并释放TCP连接， 在这之后显示网页</li></ul><p>我们也把HTTP的这种连接方式称为 「无状态连接」它可以实现快速的传输和调用 缺点在于如果访问同一个计算机上的多个网页，需要多次连接 产生额外的开销</p></blockquote><h3 id="HTTP的请求和响应格式"><a href="#HTTP的请求和响应格式" class="headerlink" title="HTTP的请求和响应格式"></a>HTTP的请求和响应格式</h3><p>这是一条HTTP请求命令</p><p>以下是HTTP的某些响应命令</p><h3 id="HTTP具有以下的特点"><a href="#HTTP具有以下的特点" class="headerlink" title="HTTP具有以下的特点"></a>HTTP具有以下的特点</h3><blockquote><ol><li><h4 id="可以-高速处理-大量请求。-「包含6种请求方式-URL格式化信息-服务器简单应答」-从开销上看HTTP优于FTP"><a href="#可以-高速处理-大量请求。-「包含6种请求方式-URL格式化信息-服务器简单应答」-从开销上看HTTP优于FTP" class="headerlink" title="可以 高速处理 大量请求。 「包含6种请求方式(URL格式化信息) 服务器简单应答」  (从开销上看HTTP优于FTP)"></a>可以 高速处理 大量请求。 「包含6种请求方式(URL格式化信息) 服务器简单应答」  (<strong>从开销上看HTTP优于FTP</strong>)</h4></li><li><h4 id="可以传输任意类型的数据-并且-采用-C-x2F-S模式-支持全球访问-支持所有的超文本和超媒体"><a href="#可以传输任意类型的数据-并且-采用-C-x2F-S模式-支持全球访问-支持所有的超文本和超媒体" class="headerlink" title="可以传输任意类型的数据 并且 采用 C&#x2F;S模式 支持全球访问    支持所有的超文本和超媒体"></a>可以传输任意类型的数据 并且 采用 C&#x2F;S模式 支持全球访问    支持所有的超文本和超媒体</h4></li><li><h4 id="短连接-无状态-「一次请求-一次应答-并不记忆任何状态」"><a href="#短连接-无状态-「一次请求-一次应答-并不记忆任何状态」" class="headerlink" title="短连接 + 无状态 「一次请求 一次应答 并不记忆任何状态」"></a>短连接 + 无状态 「一次请求 一次应答 并不记忆任何状态」</h4></li><li><h4 id="可协商。-客户请求可以指明可接受的响应类型。"><a href="#可协商。-客户请求可以指明可接受的响应类型。" class="headerlink" title="可协商。 客户请求可以指明可接受的响应类型。"></a>可协商。 客户请求可以指明可接受的响应类型。</h4></li></ol></blockquote><h2 id="分布式Web-普通-与非分布式Web-公司内-｜-Web代理服务"><a href="#分布式Web-普通-与非分布式Web-公司内-｜-Web代理服务" class="headerlink" title="分布式Web(普通)与非分布式Web(公司内) ｜  Web代理服务"></a>分布式Web(普通)与非分布式Web(公司内) ｜  Web代理服务</h2><p>普通的Web文档被存放在不同的计算机上 由不同人员独立管理 由于管理人员之间信息不一定互通 所以可能会出现无效网页 错误定位等意外情况。</p><p><strong>而非分布式的 Web系统会将每个Web文档集中存放在某个计算机上，其Web文档的超链接也是本地的 并且由专门的人员统一管理， 相比分布式Web 更能保证链接的有效性和一致性</strong></p><h3 id="Web代理服务-「大量的Web访问可能占满Internet的带宽-所以做一个cache」"><a href="#Web代理服务-「大量的Web访问可能占满Internet的带宽-所以做一个cache」" class="headerlink" title="Web代理服务 「大量的Web访问可能占满Internet的带宽 所以做一个cache」"></a>Web代理服务 「大量的Web访问可能占满Internet的带宽 所以做一个cache」</h3><p>Web Proxy&#x2F;Cache Server 会用一个高速缓存存储被大量访问的Web文档</p><p>如果你连接了校园网 一般在访问WWW时 先被校园网出口的路由器重定向到Web Cache 如果里面没有再进行访问(同时把结果存在Proxy中)</p><h2 id="浏览器-Browser-Web系统最重要部分-是用户进入Internet的主要入口「本质上是Web系统的客户端」"><a href="#浏览器-Browser-Web系统最重要部分-是用户进入Internet的主要入口「本质上是Web系统的客户端」" class="headerlink" title="浏览器 Browser  Web系统最重要部分 是用户进入Internet的主要入口「本质上是Web系统的客户端」"></a>浏览器 Browser  Web系统最重要部分 是用户进入Internet的主要入口「本质上是Web系统的客户端」</h2><h3 id="浏览器实现的功能-「为了满足多功能客户端桌面的需求-」"><a href="#浏览器实现的功能-「为了满足多功能客户端桌面的需求-」" class="headerlink" title="浏览器实现的功能 「为了满足多功能客户端桌面的需求 」"></a>浏览器实现的功能 「为了满足多功能客户端桌面的需求 」</h3><blockquote><ol><li>网页浏览</li><li>作为HTTP客户 通过TCP&#x2F;IP网络 完成用户对选择URL的请求和文档接受</li><li>解析Web文档(HTML文档)  这个功能也包括控制外设来显示这个Web文档</li><li>提供额外的服务 支持多格式文档(比如flash服务)  从实际设计角度上看 Browser甚至比Web服务器更加的复杂</li></ol><ul><li>这一项同时也意味着 浏览器可以包含支持其他服务的客户端软件(FTP&#x2F;E-Mail等)</li><li>所以 Browser&#x2F;Web Server 「B&#x2F;S」已经逐渐发展为互联网应用的统一形式</li></ul></blockquote><h2 id="Web体系结构-｜-Browser-x2F-Web-Server模式-B-x2F-S模式｜Web技术的发展"><a href="#Web体系结构-｜-Browser-x2F-Web-Server模式-B-x2F-S模式｜Web技术的发展" class="headerlink" title="Web体系结构 ｜ Browser&#x2F;Web Server模式 B&#x2F;S模式｜Web技术的发展"></a>Web体系结构 ｜ Browser&#x2F;Web Server模式 B&#x2F;S模式｜Web技术的发展</h2><p>浏览器通过URL 在TCP基础上 HTTP协议规定B&#x2F;S之间遵循的规则和需要进行的操作</p><p>&#x3D;&#x3D;这也体现出WWW的核心： 超文本｜HTML&#x2F;URL结构｜HTTP｜浏览器&#x3D;&#x3D;</p><h3 id="B-x2F-S体系结构-是作为C-x2F-S的后继发展类型"><a href="#B-x2F-S体系结构-是作为C-x2F-S的后继发展类型" class="headerlink" title="B&#x2F;S体系结构    是作为C&#x2F;S的后继发展类型"></a>B&#x2F;S体系结构    是作为C&#x2F;S的后继发展类型</h3><p>Browser在90年代中期开始逐渐成为主流 其客户端采用标准化浏览器(Java虚拟机 多媒体解析显示+简单逻辑操作)</p><p>Web服务器要做的事 解决应用开发 逻辑计算 网页封装和管理 使网络应用系统的升级 扩展和维护更加方便</p><p>在现在的B&#x2F;S服务器端 Web服务器演变为新的 <strong>MVC</strong>结构「WebSever+应用服务器+数据库服务器」</p><p>M $\Rightarrow$ 业务逻辑   V $\Rightarrow$ 展示    C $\Rightarrow$ 控制  这种结构是目前电子商务、政务广泛流行的架构</p><h3 id="Web技术的发展"><a href="#Web技术的发展" class="headerlink" title="Web技术的发展"></a>Web技术的发展</h3><h4 id="1-HTML-Rightarrow-XML-表示数据时-HTML的个性化不够-所以需要建立一种具有理解数据格式和结构的规则和方法"><a href="#1-HTML-Rightarrow-XML-表示数据时-HTML的个性化不够-所以需要建立一种具有理解数据格式和结构的规则和方法" class="headerlink" title="1. HTML $\Rightarrow$ XML  表示数据时 HTML的个性化不够 所以需要建立一种具有理解数据格式和结构的规则和方法"></a>1. HTML $\Rightarrow$ XML  表示数据时 HTML的个性化不够 所以需要建立一种具有理解数据格式和结构的规则和方法</h4><h4 id="2-Web2-0和语义Web"><a href="#2-Web2-0和语义Web" class="headerlink" title="2. Web2.0和语义Web"></a>2. Web2.0和语义Web</h4><hr><blockquote><p><strong>什么是超媒体、HTML 与Web？</strong></p><p>超媒体：在超文本中加入了图像、声音和视频的链接。可调出指针指向多媒体的信息</p><p>HTML：超文本标记语言，在普通标记语言的基础上扩展了超文本引用</p><p>Web：由超文本(超媒体)连接而成的信息集合</p></blockquote><blockquote><p><strong>为什么有时链接打开一个网页会发现无效？</strong></p><p>WWW是基于互联网的分布式的超媒体(超文本), 每个Web文档存放在不同的计算机上，并由不同的人员独立管理，其修改、删除、增加或者重命名等不会(实际上是无法) 通知相连的其他节点。因此会出现链接无效 或者链接不一致的情况。</p></blockquote><blockquote><p><strong>如何区分分布式Web和非分布式Web系统，试说明两者的可能的应用场合。</strong></p><p>相比分布式Web系统，非分布式Web系统将所有的Web文档集中存放在某一个计算机上，通常通常其Web文档的超链也是本地的，并由专门人员统一管理，能够很好的保持链接的一致性和有效性。</p><p>分布式的Web将Web服务器散布在Internet的各处，所有Internet上的Web服务器构成了万维网，是Internet上最受欢迎的应用，</p><p>非分布式的Web系统可以应用在公司或组织的内部资料库中，由专门的人员管理，也只有公司本地网段的计算机可以访问。</p></blockquote><blockquote><p><strong>试说明C&#x2F;S结构和B&#x2F;S结构的异同。</strong></p><p>B&#x2F;S结构是由C&#x2F;S结构演变而来的，采用了客户层｜中间层｜服务器 的三层结构，是基于WWW产生的。</p><p>不同之处：</p><p>B&#x2F;S的设计目的是为了满足接入Internet的普通用户需求，而C&#x2F;S则更多的由专业用户使用，同时有一定的门槛</p><p>B&#x2F;S建立在WWW(Internet)上，而C&#x2F;S则常常被部署在局域网上</p><p>B&#x2F;S的兼容性强 部署容易，而C&#x2F;S的部署比较复杂</p><p>B&#x2F;S系统的开发和维护开销都比较小，而C&#x2F;S相对来说更大一些</p><p>B&#x2F;S建立在广域网上，相比C&#x2F;S结构对于安全性的要求更低</p></blockquote><blockquote><p><strong>B&#x2F;S架构是互联网应用基本形式，什么类应用不适合B&#x2F;S架构？</strong></p><p>B&#x2F;S的架构开发和维护都相对简单 但由于是基于WWW而设计，只需要和本地服务器交互，不需要连接互联网的应用，不适合用B&#x2F;S架构。</p><p>另外，由于其无状态连接的特点，需要点对点高强度交互的应用，不适合使用B&#x2F;S架构。</p><p>虽然浏览器的功能非常强大，但如果用户需要某些特定的功能(比如游玩大型的网络游戏)，就需要专门的客户端软件，而不适合B&#x2F;S架构。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>互联网原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS</title>
    <link href="/2021/01/04/DNS-&amp;-FTP/"/>
    <url>/2021/01/04/DNS-&amp;-FTP/</url>
    
    <content type="html"><![CDATA[<h2 id="4-1-域名服务系统-DNS-Domain-Name-System"><a href="#4-1-域名服务系统-DNS-Domain-Name-System" class="headerlink" title="4.1 域名服务系统 DNS[Domain Name System]"></a>4.1 域名服务系统 DNS[Domain Name System]</h2><h3 id="DNS系统概述"><a href="#DNS系统概述" class="headerlink" title="DNS系统概述"></a>DNS系统概述</h3><p>我们显然可以通过输入 IP地址来访问网站。 使用DNS只是为了 让字符化的计算机域名 能够起到 特征标示的作用。</p><p><em><strong>DNS 的作用是 将 用户使用的域名 和 计算机使用的IP地址 互相转换(translation)</strong></em></p><p><strong>备注：</strong></p><p><strong>1. DNS 同时也表示 Domain Name Server</strong></p><p><strong>2. DNS所实现的转换是 双向的</strong></p><p><strong>3. 域名的翻译是自动完成的 依赖分布在全球的一系列服务器完成， DNS实现的翻译 属于C&#x2F;S交互</strong></p><h3 id="Internet-域名构造"><a href="#Internet-域名构造" class="headerlink" title="Internet 域名构造"></a>Internet 域名构造</h3><p><strong>因特网将这些域名划分成 树状体系 最高级的域名一般是通用域名&#x2F;国家&#x2F;基础结构域类。 在这些最高级域名下划分子类 逐渐延伸</strong></p><p>我们的高级域名<code>.cn</code> 之下 定义了7个2级域名 ac(研究机构)  com    edu    gov    mil    net    org    以及34个行政区域名</p><p><strong>如果你想要使用最高级域名， 必须向Internet管理机构ICANN(或其授权管理机构 比如中国的CCNIC)登记，层层递进</strong></p><h3 id="DNS层次结构和服务器分布模型"><a href="#DNS层次结构和服务器分布模型" class="headerlink" title="DNS层次结构和服务器分布模型"></a>DNS层次结构和服务器分布模型</h3><ul><li>每个DNS服务器 都是域名体系中部分域名的实际管理者，要负责具有某后缀的所有计算机权威管理</li><li>每个计算机域名也必须在对应的DNS组织(服务器)登记</li><li>DNS具有命名 和 服务器设置的 自治性</li><li>每个DNS服务器 只能完成部分计算机域名的处理，因此因特网所有的DNS服务器宏观上被连接成了一个系统。<ul><li>这意味着：<strong>每个DNS服务器都知道如何找到根DNS服务器，以及如何找到下级的DNS服务器</strong></li></ul></li><li>对大型组织集中单一DNS服务很困难。但由于DNS服务具有 <strong>局部访问性原理</strong> 我们可以按照层次制定分布DNS服务策略</li></ul><h3 id="DNS记录和协议报文格式"><a href="#DNS记录和协议报文格式" class="headerlink" title="DNS记录和协议报文格式"></a>DNS记录和协议报文格式</h3><h5 id="DNS的拓扑"><a href="#DNS的拓扑" class="headerlink" title="DNS的拓扑"></a>DNS的拓扑</h5><p>一般组织使用单一DNS服务器，小型公司作为用户，和提供DNS的ISP连接，DNS服务也由和其连接的ISP完成</p><hr><blockquote><p><strong>试解释中文域名可能的工作原理</strong></p><p>我认为现在的DNS系统已经比较成熟，所以中文域名的工作可以从从用户角度入手，即将用户输入的中文域名，翻译成英文域名，然后接入现有的DNS体系框架内。</p><p>在用户使用的浏览器中添加扩展，使得浏览器能够实现汉字输入转换，并考虑使用缺省和机器学习来优化</p><p>如输入 百度 则浏览器转化为 <a href="https://www.baidu.com/">https://www.baidu.com</a> 实际上仍然使用现有的DNS服务</p></blockquote><blockquote><p><strong>试说明DNS服务器怎样获取请求客户主机域名的？</strong></p><ol><li>客户机想要查询时首先在本地计算机缓存中查找，如果无法获得查询信息，则向本地DNS服务器发送查询请求</li><li>本地DNS服务器收到请求，首先在其管理区域记录里查询，如果找到了，则直接解析并返回，没找到则执行3</li><li>本地DNS服务器将客户的请求发送到根域名DNS服务器。根域名服务器解析请求的根域部分，并以此获知管理下一级域名的DNS服务器地址，并将这个地址返回给本地DNS服务器。</li><li>本地DNS服务器利用上一级域名服务器给出的地址访问下一级DNS服务器，得到更下一级的DNS服务器地址，同样，这个地址被返回给本地DNS服务器。</li><li>返回递归执行步骤4 直到本地DNS服务器获取到知道域名对应IP的DNS服务器传回的IP地址</li><li>本地DNS服务器将查询结果返回客户 完成解析过程</li></ol><p><strong>两个DNS服务器包含完全相同的域名有意义吗？为什么？</strong></p><p>是有意义的。因为DNS的解析是递归的过程，如果有两个不同的DNS服务器都包含这个域名，说不定可以减少递归的次数，提高DNS服务的效率。</p><p><strong>试分析DNS体系的层次数对域名解析速度是否有影响？</strong></p><p><strong>有影响</strong>。如果你要访问的域名离自己的本地DNS服务器太远，你的访问请求将被迫一级一级的不断上传，同时一级一级的向下返回，虽然传输的时延不长，但处理和排队的时延累加起来就很长了。比如我们访问国外的网站，即使没有被屏蔽也会很慢。</p><p><strong>DNS系统为什么要优化，优化措施主要有哪些？</strong></p><p><strong>无论是递归还是迭代</strong>的请求方式，本质上其实<strong>效率都很糟糕</strong>，特别是根服务器的负载非常大，并且根服务器作为枢纽一旦下线，非本地访问的DNS服务几乎就中断了。</p><h5 id="但由于一台计算机经常访问本地域名或重复访问同样的域名，所以可以进行以下的优化处理："><a href="#但由于一台计算机经常访问本地域名或重复访问同样的域名，所以可以进行以下的优化处理：" class="headerlink" title="但由于一台计算机经常访问本地域名或重复访问同样的域名，所以可以进行以下的优化处理："></a>但由于一台计算机经常访问本地域名或重复访问同样的域名，所以可以进行以下的优化处理：</h5><ol><li>复制。复制多个根服务器副本，按照地域分布，实现就地DNS域名服务</li><li>缓存。每次查找新域名 本地DNS服务器将地址联编副本进行缓存 实际上客户的浏览器也有类似的 域名缓存措施</li></ol></blockquote><hr><h2 id="4-2-FTP-File-Transfer-Protocol"><a href="#4-2-FTP-File-Transfer-Protocol" class="headerlink" title="4.2 FTP [File Transfer Protocol]"></a>4.2 FTP [File Transfer Protocol]</h2><h3 id="FTP-概述"><a href="#FTP-概述" class="headerlink" title="FTP 概述"></a>FTP 概述</h3><p>FTP的产生 $\rightarrow$ 早期Internet(ARPANET) 的工作主要是 信息交互 (特别是文件交互共享)</p><p><strong>从历史上讲 FTP的产生要早于TCP (现在则是使用新的FTP协议 ) 在95年之前 FTP占据因特网通信量的 1&#x2F;3</strong></p><h2 id="FTP需要解决-在异构计算机之间的-通用文件传递-这需要克服不同文件系统的差异："><a href="#FTP需要解决-在异构计算机之间的-通用文件传递-这需要克服不同文件系统的差异：" class="headerlink" title="FTP需要解决 在异构计算机之间的 通用文件传递 这需要克服不同文件系统的差异："></a>FTP需要解决 在<em><strong>异构计算机之间的 通用文件传递</strong></em> 这需要克服不同文件系统的差异：</h2><ol><li>通用性 </li><li>跨平台特性</li><li>传输和控制 $\rightarrow$ 控制 上传 下载</li><li><strong>FTP可以支持 任意类型的数据文件</strong></li><li>FTP可以加密 可以控制访问</li></ol><h5 id="FTP主要提供2种交互方式-即-实时交互-和-批处理"><a href="#FTP主要提供2种交互方式-即-实时交互-和-批处理" class="headerlink" title="FTP主要提供2种交互方式 即  实时交互 和 批处理"></a>FTP主要提供2种交互方式 即  实时交互 和 批处理</h5><p>值得注意的是 可以建立一种 同时实现两种方式的 服务</p><h2 id="FTP只有-文本-和-binary-两种格式「FTP传输的是-文件的副本-而不是文件本身」"><a href="#FTP只有-文本-和-binary-两种格式「FTP传输的是-文件的副本-而不是文件本身」" class="headerlink" title="FTP只有 文本 和 binary 两种格式「FTP传输的是 文件的副本 而不是文件本身」"></a>FTP只有 文本 和 binary 两种格式「<em><strong>FTP传输的是 文件的副本 而不是文件本身</strong></em>」</h2><p>视频 浮点数 图形… 只要不是文本 全部都使用binary 传输</p><p>当然 二进制会出现在FTP两边格式不一样的情况 这FTP不管</p><h3 id="FTP工作原理-「两条连接-控制和数据传输分离」"><a href="#FTP工作原理-「两条连接-控制和数据传输分离」" class="headerlink" title="FTP工作原理 「两条连接 控制和数据传输分离」"></a>FTP工作原理 「两条连接 控制和数据传输分离」</h3><p><strong>两端的进程会分别启动 控制和数据传送进程(它们是主进程的从属进程 并且相互独立)</strong></p><ol><li><strong>客户通过临时端口号N 和 FTP服务器(端口号 21 这是个熟知端口)  建立TCP链接</strong><ul><li><strong>这条连接 只是用来控制 由客户发起 服务器接受。 客户端输入的命令从这里发到服务器中</strong></li></ul></li><li><strong>服务器并不会马上 建立传输连接，而是在客户发起命令 确认一个文件之后</strong> </li><li><strong>服务器通过 <em>端口号20</em> 与<em>客户端口号N+1</em> 建立TCP连接</strong><ul><li>*<em>这条连接 只是用来传输 <em>由服务器发起 也会由服务器结束</em>。</em>*</li></ul></li></ol><h3 id="FTP交互方式的特点"><a href="#FTP交互方式的特点" class="headerlink" title="FTP交互方式的特点"></a>FTP交互方式的特点</h3><ol><li>两个不同的端口号分别建立控制连接和数据连接 目的是让命令交互 和 文件数据交互 之间不互相干扰</li><li>服务器在完成文件传递后 关闭数据连接 给客户端一个 文件结束条件</li><li>FTP命令可以控制远程计算机上的文件操作 就好像在操作本地文件一样</li></ol><h3 id="FTP登陆-和-常用命令"><a href="#FTP登陆-和-常用命令" class="headerlink" title="FTP登陆 和 常用命令"></a>FTP登陆 和 常用命令</h3><ol><li>输入 Open计算机域名 和这个计算机建立TCP连接。 使用Close 来关闭连接(并不是关闭FTP程序！)</li><li>对于私有的FTP服务 需要输入用户名+口令； 而有些开放的FTP服务 使用anonymous(guest) &#x2F; 电邮账户 即可实现访问了</li></ol><p><strong>FTP 一般使用命令行进行交互 客户端有约50条命令</strong></p><p>通用标准化处理(解决跨平台(OS)传输)</p><p>我们想要做到OS对FTP的C&#x2F;S透明。因此定义了 <strong>Telnet NVT(Network Vietual Terminal)网络虚拟终端</strong></p><p>这样 FTP和OS就不进行直接的交互了 而是通过NVT标准格式接口 在传输过程中 实际上就是</p><p>本地终端格式 $\rightarrow$转换为 NVT格式 $\rightarrow$ 传输 $\rightarrow$ NVT转换为本地主机格式 $\rightarrow$ 本地主机格式</p><p>NVT格式 统一使用8bit通信 7位ASCII码 最高位 为1 $\rightarrow$ 控制命令</p><h3 id="NFS-Network-File-System"><a href="#NFS-Network-File-System" class="headerlink" title="NFS(Network File System)"></a>NFS(Network File System)</h3><p>一般被集成在一个大的文件系统里</p><p>和FTP类似 但不传输文件副本 一般只传递 复制&#x2F;改变 文件的小片段</p><p>使用TCP和UDP 实现不同操作系统的各种终端和主机间远程登录和文件命令操作</p><blockquote><p><strong>1、怎样理解NVT？</strong></p></blockquote><blockquote><p><strong>2、FTP目前主要使用在什么场合，为什么不十分流行？</strong></p><p>FTP目前一般在公司或单位的内部进行公开的文件传输时使用。</p><p>不流行的原因：<br>\1. 使用命令行进行交互 没有图形界面 这意味着使用FTP的门槛要更高。</p><p>\2. 安全性不够高，FTP的信息在信道上可能被劫持 这样信息就全部泄漏了。</p><p>\3. FTP诞生时间太早，不适合现在的网络架构。使用两条TCP连接比较浪费，虽然是稳定的传输，但效率不够高，会浪费一些网络资源。</p></blockquote><blockquote><p><strong>3、在一条传输链路连接的网络两端，用FTP传输一个大文件，然后根据文件字节数和传输的时间测量链路的数据传输容量，是否准确？试说明理由。</strong></p><p>不准确。因为FTP的底层是TCP传输(TCP传输又需要进行IP层的封装)，这意味着大文件 会被封装成TCP报文段。大文件长度很可能大大超过了MTU，这意味着需要很多个TCP报文段来传输这个文件。如果只算文件字节数而忽略TCP报文头和IP报文头，算出的数据传输容量会有较大的偏差(会偏小)。</p></blockquote><blockquote><p><strong>4、二进制模式和文本模式下传输同一个文本文件，试说明两种模式传输时间哪个大？为什么？</strong></p><p>文本模式下 会花费更长时间。 FTP的文本使用ASCII&#x2F;EBCDIC 字符集，在FTP发送和接收前需要经过转换(本地文本文件$\rightarrow$ ASCII&#x2F;EBCDIC $\rightarrow$ 本地文本文件)，并且还需要加入控制字符。而二进制是不进行任何表达转换处理，直接传输文件副本。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>互联网原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络服务模式&amp;API</title>
    <link href="/2021/01/04/C:S%E4%B8%8EAPI/"/>
    <url>/2021/01/04/C:S%E4%B8%8EAPI/</url>
    
    <content type="html"><![CDATA[<h1 id="网络服务模式与API"><a href="#网络服务模式与API" class="headerlink" title="网络服务模式与API"></a>网络服务模式与API</h1><h2 id="Client-x2F-Server-模式"><a href="#Client-x2F-Server-模式" class="headerlink" title="Client&#x2F;Server 模式"></a>Client&#x2F;Server 模式</h2><h3 id="因特网的基本通信模式"><a href="#因特网的基本通信模式" class="headerlink" title="因特网的基本通信模式"></a>因特网的基本通信模式</h3><ul><li><h5 id="流模式-如-Web通信"><a href="#流模式-如-Web通信" class="headerlink" title="流模式(如: Web通信)"></a>流模式(如: Web通信)</h5></li><li><h5 id="报文模式"><a href="#报文模式" class="headerlink" title="报文模式"></a>报文模式</h5></li></ul><h3 id="C-x2F-S模式基本概念"><a href="#C-x2F-S模式基本概念" class="headerlink" title="C&#x2F;S模式基本概念"></a>C&#x2F;S模式基本概念</h3><h5 id="一种基于网络的信息交互-计算-分布模式"><a href="#一种基于网络的信息交互-计算-分布模式" class="headerlink" title="一种基于网络的信息交互/计算 分布模式"></a><code>一种基于网络的信息交互/计算 分布模式</code></h5><p><strong>网络软件被分为client和server 这两个名词直接指向通信中的两个进程，而不是主机</strong></p><h3 id="C-x2F-S模式的关系和特点"><a href="#C-x2F-S模式的关系和特点" class="headerlink" title="C&#x2F;S模式的关系和特点"></a>C&#x2F;S模式的关系和特点</h3><ul><li>对于C&#x2F;S模式 一定&#x3D;&#x3D;由客户发起请求，而服务器只被动响应&#x3D;&#x3D; $\rightarrow$ 请求&amp;应答 的分布计算(会话)模式</li><li>应用进程可以同时是服务器和客户</li></ul><blockquote><p>对于服务器软件 $\rightarrow$ <strong>主体框架 + 单个服务请求处理 + 并发服务请求处理</strong></p><ul><li>在共享计算机上首先运行，当系统启动时自动调用并不断运行</li><li>被动等待并且接受来自任意客户的通信请求 在大部分情况下 服务器软件提供单一的服务</li><li>可以同时处理多个远地&#x2F;本地客户的请求，但也需要强大的硬件和高级的操作系统支持  <strong>并发执行是服务器必须具备的</strong></li><li><strong>一个服务器软件包括 接收请求、处理单个请求和生成新线程三个部分</strong></li></ul></blockquote><blockquote><p>对于客户软件 $\rightarrow$ <strong>客户软件只是一个应用程序在进行服务器访问时的称呼</strong></p><ul><li>是任意的应用程序，它一般还能在本地做其它的事情</li><li>被用户调用 主动向远地服务器发起通信</li></ul></blockquote><h5 id="较复杂的C-x2F-S交互"><a href="#较复杂的C-x2F-S交互" class="headerlink" title="较复杂的C&#x2F;S交互"></a>较复杂的C&#x2F;S交互</h5><ul><li>客户应用不限制访问一个服务器，它需要同时和多个服务器通信。</li><li>服务器在提供服务的同时也需要作为另一个服务器的客户</li><li>服务器间可能会出现循环依赖</li></ul><p>在早期C&#x2F;S系统中 服务器计算机通常作为信息共享的设备部署(文件服务器、数据库服务器) 客户端自己来计算和跑程序</p><p>现今阶段 服务器是数据与业务功能处理中心 客户端则主要是UI界面+少量辅助功能处理</p><hr><h3 id="服务器识别"><a href="#服务器识别" class="headerlink" title="服务器识别"></a>服务器识别</h3><p><strong>Protocol Port Number 协议端口号 (OSI 术语是运输层服务访问点TSAP) 是TCP&#x2F;UDP给每种服务定义的标识</strong></p><p>对于源进程(它发起了请求)交付通信时通过 端口号明确自己的身份 还有接收方身份</p><p>收端进程会通过端口号来向目的进程交付。(很明显 这一切都发生在运输层)</p><p>对于服务器 通过端口号来明确提供的服务</p><h5 id="服务器端口号必须是唯一定义的-而客户端的端口号可以是临时指定的-只在本地有意义"><a href="#服务器端口号必须是唯一定义的-而客户端的端口号可以是临时指定的-只在本地有意义" class="headerlink" title="服务器端口号必须是唯一定义的 而客户端的端口号可以是临时指定的(只在本地有意义)"></a>服务器端口号必须是唯一定义的 而客户端的端口号可以是临时指定的(只在本地有意义)</h5><blockquote><p><strong>在使用TCP通信时 只有端口号是不够的 TCP的两个端点由Socket 插口 :(IP地址，端口号)定义</strong> (或者叫端地址)</p></blockquote><h5 id="协议端口号定义"><a href="#协议端口号定义" class="headerlink" title="协议端口号定义"></a>协议端口号定义</h5><p>TCP&#x2F;UDP定义一套16bit整数值 端口号被分为熟知端口号和一般端口号两列</p><p>熟知端口号 : FTP $\rightarrow$ 21    Telnet $\rightarrow$ 23    SMTP $\rightarrow$ 25    DNS $\rightarrow$ 53    TFTP $\rightarrow$ 69    HTTP $\rightarrow$ 80    SNMP $\rightarrow$ 161</p><p>一般端口号可以在规定区域内随意定义和分配</p><p>主要的端口号在1-225之间</p><p>端口号256-1023由Unix系统占用 </p><p>1024-5000作为临时端口 5000+不常出现 </p><h3 id="其他的交互模式"><a href="#其他的交互模式" class="headerlink" title="其他的交互模式"></a>其他的交互模式</h3><blockquote><p>C&#x2F;S模式比较简单 但容易造成网络瓶颈 并且负载不均衡问题也会使得服务器常常过载</p></blockquote><h5 id="P2P-peer-to-peer-：无中心服务器的流行网络技术-依赖所有参与者的计算能力和带宽-占到因特网流量的50-90"><a href="#P2P-peer-to-peer-：无中心服务器的流行网络技术-依赖所有参与者的计算能力和带宽-占到因特网流量的50-90" class="headerlink" title="P2P (peer to peer)：无中心服务器的流行网络技术 依赖所有参与者的计算能力和带宽 占到因特网流量的50%-90%"></a>P2P (peer to peer)：无中心服务器的流行网络技术 依赖所有参与者的计算能力和带宽 占到因特网流量的50%-90%</h5><hr><blockquote><p><strong>因特网通信模式和C&#x2F;S模式各自说明什么问题</strong></p><p>因特网通信模式：流模式和报文模式有着比较鲜明的特点，说明我们对因特网功能的需求是多样的，而网络技术也可以用不同的通信模式来满足不同的用户需求，但也说明想要实现稳定可能就需要牺牲效率，实现高效可能就保证不了可靠的传输。</p><p>C&#x2F;S模式：早期的C&#x2F;S模式以文件数据访问服务为主，客户程序也需要进行计算。而现今的C&#x2F;S模式在强大的服务器算力支撑下，客户端几乎不用承担计算任务，这说明C&#x2F;S模式的确得到了大规模的应用，所以服务器技术才能发展的如此迅速。</p></blockquote><blockquote><p><strong>简述客户软件和服务器软件主要特点</strong></p><p>服务器软件：</p><ol><li>专门提供某类服务的程序，一定可以并行的处理多个客户请求。</li><li>运行在共享计算机上，只要系统不关闭，就一直运行。</li><li>被动等待并且接收来自任意用户的通信请求</li><li>一般需要较强大的硬件和高级的操作系统支持</li></ol><p>客户软件：</p><ol><li>只有在进行通信时才被称为客户，它也可能可以在本地进行其他的计算并且实现其他功能。</li><li>由用户调用，在用户本地计算机上运行，在用户有需要时主动向远地服务器发起通信请求。</li><li>可以与多个服务器通信 并且一般不需要特殊硬件和复杂的操作系统</li></ol></blockquote><blockquote><p><strong>一个服务器软件通常需要包括哪些主要的功能部分？</strong></p><p>一个服务器软件主要包括：等待接收请求、处理单个请求和生成新线程</p></blockquote><blockquote><p><strong>为什么通常服务器端口号是唯一定义的，而客户端的端口号可以临时指定？</strong></p><p>服务器端口号唯一定义是为了让所有的客户都能正确找到它。因为C&#x2F;S交互的身份问题，客户端的端口号只需要做到不和自己同时运行的其他进程混淆即可，临时指定端口号也可以实现同一个端口号的复用(当某个客户软件不运行时就不占用端口号了)</p></blockquote><hr><h1 id="API-Application-Program-Interface"><a href="#API-Application-Program-Interface" class="headerlink" title="API [Application Program Interface]"></a>API [Application Program Interface]</h1><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h5 id="是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节"><a href="#是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节" class="headerlink" title="是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节"></a><code>是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节</code></h5><ul><li><strong>在应用从操作系统中获得相关服务时 通过调用API 将任务和控制权都交给操作系统，在执行完毕后，操作系统会交还控制权</strong></li><li>网络通信和数据交互调用API $\rightarrow$ 网络API(他是应用程序和TCP&#x2F;IP协议通信交互的接口)</li><li><strong>API造就了 应用和网络 的一体 和 分离 $\rightarrow$  在使用时一体，在开发时分离</strong></li></ul><p>互联网中主要有两类API 伯克利版 $\rightarrow$ Socket API 以及 A&amp;AT版 $\rightarrow$ TLI[Transport Lay Interface]</p><p>其中Socket API被主流操作系统使用，成为标准。</p><h3 id="Socket-API"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h3><ul><li>它来自Unix 由于Unix一切皆文件(open - read - write - close)的哲学影响，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</li><li><strong>在通信前 APP要向OS申请一个 套接字(也叫通信描述符)，OS返回一个小的整形数作为描述符来识别这个套接字 在通信结束后，这个代表特殊参数的套接字会被回收</strong></li><li><strong>套接字API 定义并调用多个函数来确定参数和选项 (创建套接字(返回描述符)，然后调用这些函数来完成对接)</strong></li></ul><h3 id="实现套接字API的函数"><a href="#实现套接字API的函数" class="headerlink" title="实现套接字API的函数"></a>实现套接字API的函数</h3><ol><li><p><code>Socket</code>函数 <strong>&#x2F;&#x2F; 创建套接字并返回整型描述符</strong></p><p>$Descriptor &#x3D; socket(pf,type,protocol)$ </p><p>pf $\rightarrow$ ProtocolFamily:协议栈(TCP&#x2F;IP)  Type $\rightarrow$ 连接&#x2F;无连接 protocol $\rightarrow$ 具体协议</p></li><li><p><code>Bind</code> 函数 <strong>&#x2F;&#x2F; 赋予套接字特定的端地址，实现socket和端地址的联编</strong> &#x3D;&#x3D;联编相当于 绑定&#x3D;&#x3D;</p><p>$Bind(socket,locaaddr,addrlen)$ <strong>&#x2F;&#x2F; 不建立连接的话，bind函数之后就可以交互数据了</strong></p><p>loca addr $\rightarrow$ 本地端地址的一般socket地址描述结构。</p></li><li><p><code>Close</code> 函数 <strong>&#x2F;&#x2F; 告诉系统终止对一个套接字的使用(释放这个套接字)</strong></p><p>$close(socket)$ <strong>&#x2F;&#x2F; 如果面向连接，则先关闭连接，再回收套接字</strong></p></li><li><p><code>Listen</code> 函数 **&#x2F;&#x2F; (<em>只有面向连接使用) 套接字被设置为被动模式，等待连接请求</em>*</p><p>$Listen(socket,queuesize)$ Queue size $\rightarrow$ 客户请求队列长度</p></li><li><p><code>Connect</code>函数 <strong>&#x2F;&#x2F; 面向连接时使用，启动与服务器的连接(前提是服务器已经调用了listen和accept)</strong></p><p>$connect(socket,saddress,saddresslen)$  &#x2F;&#x2F;在UDP时 也可以使用 此时完成socket和目的服务器端地址联编</p></li><li><p><code>Accept</code>函数 **&#x2F;&#x2F; (<em>只有面向连接使用) 确定客户端的地址，确认连接，这时需要创建一个新的套接字，通信结束后回收</em>*</p><p>$newsock &#x3D; accept(caddress,caddresslen)$</p><p>c address$\rightarrow$按照socket地址结构描述的<strong>客户端IP地址</strong></p></li><li><p><code>Send</code>函数 <strong>&#x2F;&#x2F; 客户和服务器使用这个函数来发送消息</strong></p><p>$send(socket,data,length,flags)$ </p><p>data $\rightarrow$ 内存待发数据的地址    length $\rightarrow$ 数据字节数    flags $\rightarrow$ 特殊选项(用来调试系统)</p><p>$sendto(socket,data,length,flags,destaddress,addresslen)$ <strong>&#x2F;&#x2F;无连接使用sendto函数</strong></p><p>$sendmgs(socket,mgsstruct,flags)$ 作用和sendto类似</p></li><li><p><code>Recv</code>函数 <strong>&#x2F;&#x2F; 客户和服务器从套接字接收数据</strong></p><p>$recv(socket,buffer,length,flags)$</p><p>buffer $\rightarrow$ 内存中收到数据的地址    length $\rightarrow$ 缓冲区大小    flags$\rightarrow$特殊选项</p><p>$recvfrom(socket,buffer,length,flags,sndraddr,saddrlen)$ <strong>&#x2F;&#x2F;无连接使用recvfrom函数</strong></p><p>$recvmgs(socket,mgsstrucct,flags)$ 作用和recvfrom类似 <strong>sendmgs和recvmgs是原函数的简化参数版本</strong></p></li><li><p>其他</p><ol><li>$write(socket,buffer,length) &#x2F; read(socket,buffer,length)$ Unix的I&#x2F;O一般操作 在连接之后和send-recv一样</li><li>$getpeername$ <strong>&#x2F;&#x2F;调用accept接收连接请求后调用这个函数获取客户端地址</strong></li><li>$gethostname$ <strong>&#x2F;&#x2F;调用这个函数获取本机的完整信息，可以是域名，也可能是其他</strong></li><li>$ gethostbyname$ <strong>&#x2F;&#x2F;知道域名时 调用这个函数获取本机IP地址</strong></li><li>$getprotobyname$ <strong>&#x2F;&#x2F;知道域名时 调用这个函数获取 socket使用的二进制形式IP地址</strong></li><li>$gethostbyaddr$ <strong>&#x2F;&#x2F;知道IP地址，获取域名     这两个函数在API中完成IP地址和域名的转换</strong></li></ol></li></ol><p>备注：</p><ol><li><code>Accept</code>确认连接地址之后 需要创建一个新的socket (可以根据C&#x2F;S模式理解成，服务器创建新线程)，只要连接建立，原来的套接字就会用来和下一个客户进行连接。</li><li>服务器可以并发，服务器创建并发线程时套接字也会产生一个副本，这样就实现了并发线程都能调用所有的套接字功能</li><li><code>Listen</code>和 <code>Accept</code>函数是<em><strong>面向连接通信时</strong></em>服务器必须进行的调用</li></ol><h3 id="套接字API与C-x2F-S"><a href="#套接字API与C-x2F-S" class="headerlink" title="套接字API与C&#x2F;S"></a>套接字API与C&#x2F;S</h3><p>刚刚的程序每次收到请求都会打印一段信息(建立连接)。 </p><p>可以注意的是 <em><strong>客户端不需要 socket和端地址联编</strong></em> 因为客户端的端口号可以是临时指定的(端地址也就相当于是可变的)，如果客户端需要向服务器发送报文，那另说。</p><hr><blockquote><p><strong>API是否由TCP&#x2F;IP所定义，目前互联网最常用的API体系是什么。</strong></p><p>不是。API是宏观的概念，而网络中使用的API主要分为Socket API(它由Berkeley UNIX定义)和TLI ，其中Socket API被主流的操作系统使用，所以Socket API是互联网最常用的API体系。</p></blockquote><blockquote><p><strong>API接口与协议端口、插口有什么区别？</strong></p><p>在网络中使用的API，指的是应用程序和TCP&#x2F;IP协议通信交互的接口，它是经过抽象后定义的一组(函数)操作，由操作系统来调用它。API使得应用进程和TCP&#x2F;IP(运输层)实现透明。</p><p>协议端口是TCP&#x2F;UDP给每种服务定义的标识，在进程进行交互时协助对接。协议端口使得两端的操作系统都能识别身份和服务。</p></blockquote><blockquote><p><strong>服务器套接字API有哪些专门的函数（过程）；对一个面向连接的TCP通信，服务器端套接字API的实现要经过那些过程调用？</strong></p><ol><li>socket    bind    listen    accept    connect    close    send(sendto)    recv(recvfrom)    getpeername    gethostname    gethostbyname    getprotobyname    gethostbyaddr等</li><li>对于面向连接 服务器端API的实现要经过<ol><li>getprotobyname 获取IP地址</li><li>Socket 建立套接字</li><li>bind (socket和端口号联编)</li><li>listen 套接字设置为被动模式，等待连接请求</li><li>accept 确定客户端的地址，确认连接，并且返回一个新创建的套接字 </li><li>send&amp;recv 发送和接收数据</li><li>close 关闭连接 回收套接字</li></ol></li></ol></blockquote><blockquote><p><strong>对一个非连接通信，客户端套接字为什么不必和本地端地址绑定？</strong></p><p>因为客户端的端口号可以是临时指定的(端地址也就相当于是可变的)，这个端地址仅仅具有本地的意义，由于端地址已经可以在本地唯一的标识进程，即使不绑定套接字OS和TCP&#x2F;IP也都能通过端地址来找到应用进程。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>互联网原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>因特网路由与协议</title>
    <link href="/2021/01/04/%E5%9B%A0%E7%89%B9%E7%BD%91%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%8D%8F%E8%AE%AE/"/>
    <url>/2021/01/04/%E5%9B%A0%E7%89%B9%E7%BD%91%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="因特网路由与协议"><a href="#因特网路由与协议" class="headerlink" title="因特网路由与协议"></a>因特网路由与协议</h1><p>RIP BGP位于应用层</p><h5 id="3个概念：路由选择-路由协议-路由算法"><a href="#3个概念：路由选择-路由协议-路由算法" class="headerlink" title="3个概念：路由选择 路由协议 路由算法"></a>3个概念：路由选择 路由协议 路由算法</h5><p><strong>路由选择</strong>$\rightarrow$通过互连网络从源节点向目的节点传输信息的通道，且中间至少有一个中间节点</p><p><strong>路由协议</strong>$\rightarrow$路由指导IP数据报发送过程中事先约定好的规定和标准(规定了IP数据报在网络中存储和转发的方式)</p><p>​    <em>路由协议决定了路由选择，而路由算法是路由协议的实现。</em></p><p>​    <em>在一个Autonomous System内的路由协议被称为Interior Gateway Protocol</em></p><p>​    <em>而AS之间的路由协议则是Exterior Gateway Protocol</em></p><p>​    <em>内部网关协议：RIP IGRP EIGRP IS-IS OSPF</em></p><p>​    <em>外部网关协议：EGP BGP</em></p><p><strong>路由算法</strong>$\rightarrow$提高路由协议的功能，尽量减少路由时带来的开销的算法</p><h2 id="分层的路由选择协议"><a href="#分层的路由选择协议" class="headerlink" title="分层的路由选择协议"></a>分层的路由选择协议</h2><p>实际上的Internet是由各个组织的自治域系统AS(Autonomous System)网络互连而成。</p><p>而作用在AS内部的 被称为内部网关协议IGP(RIP,OSPF)，外部的则称为外部网关协议EGP(BGP)</p><hr><h5 id="目前主要使用自适应-分布式协议，对于理想的路由协议-如何实现"><a href="#目前主要使用自适应-分布式协议，对于理想的路由协议-如何实现" class="headerlink" title="目前主要使用自适应 分布式协议，对于理想的路由协议 如何实现?"></a>目前主要使用自适应 分布式协议，对于理想的路由协议 如何实现?</h5><blockquote><p>正确性+完整性$\rightarrow$沿着路由表 肯定能到达所有主机</p><p>简洁性+合理性$\rightarrow$是保证时延最小 占有系统资源少 同时要求算法技术复杂性尽可能低</p><p>健壮性+可靠性$\rightarrow$根据结点故障，拥塞情况等进行动态的调整</p><p>稳定性$\rightarrow$网络结构稳定时避免路由表不断变化</p><p>公平性$\rightarrow$除非紧急，否则所有用户数据报进行一样的处理</p></blockquote><h2 id="内部网关协议RIP"><a href="#内部网关协议RIP" class="headerlink" title="内部网关协议RIP"></a>内部网关协议RIP</h2><h5 id="RIP简介"><a href="#RIP简介" class="headerlink" title="RIP简介"></a>RIP简介</h5><p>路由信息协议Router Information Protocol 是最早的广泛应用的分布式路由选择协议 </p><p>是比较简单的内部网关协议Interior Gateway Protocol</p><p>包括了RIP-1和RIP-2 其中2是1的扩充版</p><h5 id="最大的特点：好消息传的快-坏消息传的慢"><a href="#最大的特点：好消息传的快-坏消息传的慢" class="headerlink" title="最大的特点：好消息传的快 坏消息传的慢"></a>最大的特点：好消息传的快 坏消息传的慢</h5><blockquote><p>它的设计基于距离矢量算法(Distance-Vector)，使用Hop Count(跳数)来度量和目的网络之间的距离</p><p>与设备直连时跳数为0，这个度量值等于到达目的网络间的设备数量。</p></blockquote><p>&#x3D;&#x3D;为了限制收敛时间，RIP规定度量值取0～15之间的整数 大于等于16目的网络不可达 <strong>这也直接使得RIP不可能应用在大型网络里</strong>&#x3D;&#x3D;</p><blockquote><p>ps: 什么是路由收敛，什么是收敛时间</p></blockquote><p><strong><u>路由收敛 $\rightarrow$ 所有路由器对当前的网络结构和路由转发达成一致的状态</u></strong></p><p><strong><u>收敛时间 $\rightarrow$ 从网络拓扑发生变化，到所有相关路由器都得知这个变化并作出相应改变所需要的时间</u></strong></p><h5 id="RIP如何工作"><a href="#RIP如何工作" class="headerlink" title="RIP如何工作"></a>RIP如何工作</h5><blockquote><p>路由器A只和邻居路由器交换信息(同一网段所有路由器的接口)，采用主动发送 被动接收的方式</p><p>RIP交换的信息是路由器当前所知的全部信息(路由表主体)</p><p>每<strong>30s</strong>完成一次信息交换，更新各自路由器的路由表 &#x3D;&#x3D;在更新时，RIPv1总是广播更新，而v2是组播更新&#x3D;&#x3D;</p><p>(具体的情况就是 在第一次交换之前 路由器只有直连网络的信息，在几次交换之后，会得到整个自治域的最短距离信息) 在几次交换之后，就能实现每次转发距离最小。</p></blockquote><h5 id="形成RIP路由表"><a href="#形成RIP路由表" class="headerlink" title="形成RIP路由表"></a>形成RIP路由表</h5><ul><li>RouterA启动了RIP协议，向相邻路由器广播一个Request报文</li><li>RouterB是A的邻居，受到Request报文后将自己的<strong>整个路由表</strong>封装在Response报文里，向接口对应的网络广播</li><li>RouterA根据B的报文形成自己的路由表</li></ul><h5 id="与RIPv1相比，RIPv2的不同"><a href="#与RIPv1相比，RIPv2的不同" class="headerlink" title="与RIPv1相比，RIPv2的不同"></a>与RIPv1相比，RIPv2的不同</h5><ol><li>v1是有类路由协议，v2是无类路由协议</li><li>v1不支持VLSM v2支持</li><li>v1没有认证功能，v2有明文和MD5认证</li><li>v1没有手工汇总，必须自动；v2可以关闭自动汇总</li><li><strong>V1总是广播更新，v2组播更新</strong></li><li>v1没有路由标记 不能过滤和实施策略</li><li>v1发送的updata包没有next-hop属性，这个属性可以用来进行路由更新的重定</li><li>使用v1的路由器可以接收v2的报文，而使用v2的则不能接收v1的报文</li></ol><h5 id="RIP协议-如何出现环路？"><a href="#RIP协议-如何出现环路？" class="headerlink" title="RIP协议 如何出现环路？"></a>RIP协议 如何出现环路？</h5><p>在如下的网段里，R1和C直连 跳数为1 R2到C跳数则为2</p><p>现在C网段出现故障 R1到C距离为16 不可达</p><p><code>R1</code>准备在下一个30秒内告诉<code>R2</code>这个坏消息，但是<code>R2</code>先把自己的所有信息都告诉了<code>R1</code>,<code>R1</code>一看咦？<code>R2</code>到<code>C</code>的跳数是2，我到<code>R2</code>就一跳，现在虽然我不能直接到<code>C</code>了，那么绕道<code>R2</code>不就可以了吗？说干就干，于是把自己到<code>C</code>的跳数改为<code>3</code>.好了，真相被谎言掩盖了。</p><p><code>R1</code>向<code>R2</code>这个坦白所有的信息，<code>R2</code>看到<code>R1</code>到<code>C</code>的距离变为3了，<code>R2</code>知道自己是经过<code>R1</code>才到达的<code>C</code>，于是毫不犹豫的改为4.下一次再把全部信息告诉<code>R1</code>,<code>R1</code>收到一看，咋回事啊，怎么又加一跳了呢！<code>R2</code>那边发生了什么？但是还是得根据规则，毫不犹豫的修改到C的距离跳数。<strong>就这样不断增加，直到都为16</strong>，才恍然大悟，原来大家都到不了了啊。</p><hr><h2 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h2><h5 id="OSPF简介"><a href="#OSPF简介" class="headerlink" title="OSPF简介"></a>OSPF简介</h5><p>Open Shortest Path First 开放最短路径优先协议 是为了克服RIP的缺陷而设计的。</p><p>属于典型链路状态(link-state)协议。在区域内的所有路由器维护共同的链路状态数据库。</p><p>维护的数据包括    链路标号    两端连接路由器    链路度量(距离 费用 带宽 时延)</p><p><em><strong>可以用在较大的网络中 但路由协议和算法比较复杂</strong></em></p><blockquote><p>AS 被OSPF划分成若干个区域，每个区域路由器数量不超过200个，并由32位区域标识符描述。</p><p>在某个区域的所有路由器，只需要知道本区域的网络拓扑结构即可。这使得OSPF协议的效率比较高</p></blockquote><p>AS被划分成 Backbone Area(主干区域,0.0.0.0) 和Area，主干区域路由器就是主干路由器，区域之间设置区域边界路由器，这个路由器和主干路由器连接。</p><h5 id="OSPF工作原理"><a href="#OSPF工作原理" class="headerlink" title="OSPF工作原理"></a>OSPF工作原理</h5><blockquote><p>在区域中使用flooding(泛洪法)，由路由器所有输出接口向相邻路由器发送某个特定链路状态信息(我所知的相邻路由器的链路状态)，再由相邻路由器向其他地方转发(不会发回来) 注意：转发的是人家的包？</p><p>经过信息交换，区域中的每个路由器都保存了所有路由链路状态信息 据此组成相同链路状态数据库(LSDB)</p><p>在进行数据报的路由选择时，可以通过链路状态计算得到最短路径，并且通过链路度量，能更加灵活的处理</p><p>链路发生变化时，OSPF才使用泛洪法发送变化的信息</p></blockquote><p>分层区域设置 让交换路由信息的种类增加。随着层次增加，OSPF会逐渐变的更加复杂 但在更强大的设备加持下，OSPF能够有效的管理大规模的网络</p><p>网络按照层次结构设计时大规模网络普遍采用的设计原则。一般分为接入层、汇聚层(边缘层)、核心层；同样的设备在不同的层次时所完成的工作也是不同的。</p><h5 id="OSPF路由算法"><a href="#OSPF路由算法" class="headerlink" title="OSPF路由算法"></a>OSPF路由算法</h5><p>在建立链路状态数据库后 路由器相当于拥有了网络拓扑的完整信息，根据网络拓扑构建网络最短路径树，路由器就能建立自己的***<u>隐式路由表</u>***(只供自己使用)</p><blockquote><p>根据本区域的 链路状态数据库 计算到本区域的各个网络路由</p><p>根据本AS的 链路状态数据库 计算到AS中其他区域各个网络路由。</p><p>​    主干路由器根据到区域边界路由器(ABR)距离,和ABR到区内网络的距离综合选择路由</p><p>根据到AS域边界路由器+AS边界路由器到外部目的网络的距离，计算选择的路由</p></blockquote><p>OSPF可以根据IP首部的TOS(Type Of Service服务类型)对不同的链路设置代价(1-65535) 根据链路带宽 时延来计算</p><p>如果有多个相同代价的路由，还可以作多路径间多负载均衡，支持VLSM和CIDR 健壮性、稳定性、服务质量都不错。</p><h5 id="OSPF和RIP的区别"><a href="#OSPF和RIP的区别" class="headerlink" title="OSPF和RIP的区别"></a>OSPF和RIP的区别</h5><p>RIP只关注最短路径(这个路径还是只看跳数决定的)和下一跳路由器；而OSPF则能进行链路状态计算，还有链路度量机制</p><p>RIP在进行信息交换时不是转发人家发来的包，而是根据他的人包更新，然后发送自己的包(OSPF是转发)</p><p>RIP的信息交换是定时的！而OSPF则是检测到链路变化时才发送。</p><p>OSPF虽然有着更好的服务效果，但对计算能力的要求比较高</p><p><em><strong>对于距离矢量路由协议来说交换的是路由表，每个路由器的路由表都是照搬其他人的包，并不需要计算</strong></em></p><p><em><strong>而链路状态路由协议交换链路状态</strong></em></p><h2 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h2><h5 id="BGP简介"><a href="#BGP简介" class="headerlink" title="BGP简介"></a>BGP简介</h5><p>自治域间的路由选择由外部网关协议负责。    早期出现的EGP(外部网关协议)已经不再使用</p><p>Border Gateway Protocol(version 4)占有重要地位 所有的 AS都需要通过BGP-4获取彼此路由信息。</p><h5 id="在域间路由选择时面临的问题"><a href="#在域间路由选择时面临的问题" class="headerlink" title="在域间路由选择时面临的问题"></a>在域间路由选择时面临的问题</h5><blockquote><p>可扩展性 ：</p><p>域间路由器必须能转发Internet里所有可能的地址的分组。需要的路由表必须提供任何合法的IP地址分配</p><p>适应 域的自治特性：</p><p>每个自治域被允许使用自己的内部路由协议，选择一条穿越多个AS的路径的最优化是无意义的</p><p>对自治域的信任问题</p><p>在路由信息交互时，各个ISP提供的路由选择信息是否存在错误？以及域间路由的灵活策略(如一个多连接的ISP可制定通往AS1与AS3的策略 存在信任问题)</p></blockquote><h5 id="BGP的工作原理"><a href="#BGP的工作原理" class="headerlink" title="BGP的工作原理"></a>BGP的工作原理</h5><p>&#x3D;&#x3D;<em><strong>首要目标是 找到任何一条 无环的 通往预定目的地的路径(可达优先，没必要最优)</strong></em>&#x3D;&#x3D;</p><p>其处理特点是：</p><p><em><strong>能够进行路由优选 避免路由环路 更高效传递路由和维护大量路由信息</strong></em></p><p>跨越多跳路由器建立邻居关系(基于TCP协议) 在BGP路由里携带丰富的属性值</p><ol><li>自治域间路由，系统层次：自治域外提供路由信息，也就是边界路由器，一个AS设置一个发言人和其他AS交换信息</li><li>政策性约束，管理员可以配置BGP对某些路径不提供中转的策略，即使它知道如何到达目的地址</li><li>中转路由设施，当一个自治域同意某个业务流通过本系统转送到另外一个AS时，BGP会作为Transit System。当有一个以上的其他AS连接 但拒绝中转通信的AS称为Multihomed AS，只和一个AS连接 只传输本地业务流称为Stub System(桩AS)</li><li>可靠传输，BGP使用TCP通信。</li></ol><hr><blockquote><p>路由器中路由协议和路由算法各自完成什么作用？</p></blockquote><p>​    路由协议规定和指导IP数据报在网络中的存储转发方式。路由算法则需要提高路由协议的功能(工作效率),尽量减少路由时产生的开销，并且尽可能做到快速收敛。</p><p>路由协议完成路由信息动态交换，并以此建立路由表；路由算法是根据转发IP包的目的地址，依据路由表计算出最优转发路径和端口。</p><blockquote><p>什么是跳数？RIP协议为什么将最大跳数设为16？</p></blockquote><p>​    跳数(Hop Count)，从源端口到目的端口所经过的路由设备个数</p><p>​    为了限制收敛时间。在网络中有一个设备出现故障时，与其直连的设备知道网络不可达，但在更新之前如果其他不知情的路由设备向故障网段发送报文，就会出现误解的情况从而出现环路，两个设备到故障网段的跳数不断增加直到达到16时才能确认不可达。</p><blockquote><p>RIP协议工作的基本思想，主要问题在那里？</p></blockquote><p>​    1.只和相邻路由器交换信息 采取主动发送 被动接收到方式</p><p>​    2.每30s一次交换，每次都交换整个路由表</p><p>主要的问题：</p><div class="code-wrapper"><pre><code class="hljs">1. 规定最多16跳，所有路由器持有全部路由信息，不能用在大型网络上2. 只根据跳数来判断传输效率，不考虑链路带宽和延时等等其他因素3. 发生故障时，收敛速度慢4. 无法考虑多链路的负载均衡机制5. 不能识别服务等级和类型</code></pre></div><blockquote><p>目前网络路由协议主要考虑的哪些要素？</p></blockquote><p>见<code>理想路由协议如何实现</code></p><blockquote><p>简述互联网为什么要定义自治域AS，解释为什么要分层路由。</p></blockquote><p>定义自治域AS：全球有很多的公司和组织需要接入互联网，但根据其业务或条件的不同，其内部拓扑有着很大区别，并且其网络构成细节也希望不对外界公开，所以引入AS的概念来让不同的互联网实体可以无障碍沟通的同时保留自己的完整性。</p><p>分层路由：实际上的互联网是由各个AS互连而成，而由于业务等等因素的区别，每个AS的内部拓扑和使用的协议不一定相同，因此进行分层的路由，在AS内部使用IGP，只需要考虑内部的拓扑结构，而AS之间使用BGP也可以无视不同AS内部的差异。</p><blockquote><p>RIP与OSPF协议主要特点，各自处理的自治域规模一般多大？</p></blockquote><p>RIP是基于距离矢量算法设计，只考虑跳数，所以路由选择没有考虑到链路的带宽和延时，引入不可超过16跳来避免环路也让其只能用于早期的 小型的互联网。但其的算法思路简单，对路由设备算力的要求低于OSPF协议。</p><p>OSPF则属于典型链路状态协议。在区域内的所有路由器维护共同的链路状态数据库，能够考虑到各种链路因素。自治域在OSPF中被划分成了若干个区域(每区域不超过200个路由器)，这使得OSPF不仅效率高，而且也能用在较大规模的自治域中。但随着层次的增加，OSPF协议会变的更加复杂，所以对设备的配置有一定要求。</p><p>RIP只能用在小型的自治域中(如果自治域中任意两个端点的最短距离大于等于16就不能再使用RIP协议了)</p><p>OSPF可以用在大规模的自治域中。</p><blockquote><p>简单说明IGP和EGP协议主要区别。</p></blockquote><p>IGP(Interior Gateway Protocol)用在自治域的内部，用来在AS内部交换路由信息。</p><p>EGP(Exterior Gateway Protocol)用于连接不同的自治域，通过策略和过滤来控制路由信息在不同AS间的传播。</p><blockquote><p>简述自治域划分与因特网主干网、区域ISP和用户接入网的关系。</p></blockquote><p>因特网主干网作为一个自治域和多个其他主干网互连，区域ISP则可以直接接入因特网主干网，而用户接入网则作为ISP的客户接入ISP，通过ISP来访问主干网。</p><blockquote><p>BGP协议是否一定能提供最佳路径，为什么？</p></blockquote><p>我认为不是。虽然BGP协议能路由优选 避免路由环路 更高效传递路由和维护大量路由信息。但首要目标是找到任何一条无环的通往预定目的地的路径(可达性为最优先)</p><blockquote><p>简述因特网的实际结构和特点，中国因特网可能的基本组成结构是？</p></blockquote><p>​    因特网实际上是由各个组织的自治域系统AS网络互连而成，并非平面结构而是层次结构。由核心层 分布层 接入层构成。主干网，城域网(ISP)和用户网(LAN)组成了其层次结构。</p><p>组成成分：</p><ol><li>网根结构是多个主干网(AS)互连</li><li>大公司和ISP直接与一个或者多个主干网连接</li><li>小公司和个人用户作为ISP的客户接入ISP</li></ol><blockquote><p>RIP为什么称为距离向量协议？</p></blockquote><p>基于距离矢量算法设计</p><blockquote><p>路由协议有什么作用？</p></blockquote><p>路由指导数据报转送方式，是传输过程中事先约定好的规定和标准</p><blockquote><p>什么是自治域？举两个例子。</p></blockquote><p>一个自治系统（Autonomous System，AS）是一组路由器的集合，它们拥有同样的选路策略、被同一技术管理部门管理运行。  </p><blockquote><p>因特网中的路由器任何配置？</p></blockquote><blockquote><p>OSPF协议交换什么信息，路径最优含义？</p></blockquote><p>交换的是链路状态信息，包括接口上的IP地址 子网码 网络类型 代价 区域</p><p>开放最短路径优先，构建一颗最短路径优先树。</p>]]></content>
    
    
    
    <tags>
      
      <tag>互联网原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NAT</title>
    <link href="/2021/01/03/NAT%E4%B8%8EDHCP/"/>
    <url>/2021/01/03/NAT%E4%B8%8EDHCP/</url>
    
    <content type="html"><![CDATA[<h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><p>对于TCP&#x2F;IP的每一层， 有些是协议 有些是技术。</p><p>宏观来看，IPv4的地址空间不够用，导致了大量的问题</p><blockquote><p>IPv6 (128bits)</p><p>NAT &#x2F; Network Address Translation</p><p>VLSM 可变长 subnet mask</p><p>CIDR 无类域间路由</p></blockquote><h3 id="NAT-简介"><a href="#NAT-简介" class="headerlink" title="NAT 简介"></a>NAT 简介</h3><p>Network Address Translation 发明于1994年</p><p>其思路是 <strong>内网域内使用私有的IP地址空间</strong> 10网段 172.16网段 192.168网段</p><blockquote><p>10.0.0.0—10.255.255.255 A<br>172.16.0.0—172.31.255.255 B<br>192.168.0.0—192.168.255.255 C</p></blockquote><p>私有IP只在局域网里使用 互联网上不会出现这些ip</p><p>NAT的普及程度 $\rightarrow$ 70%的P2P用户位于NAT网关以内 由于P2P主要运行在PC上，这意味着大部分的PC都是通过NAT网关连接到Internet</p><ul><li>NAT技术没有公认的发明者</li></ul><h3 id="NAT工作模型"><a href="#NAT工作模型" class="headerlink" title="NAT工作模型"></a>NAT工作模型</h3><p>&#x3D;&#x3D;NAT 通常被部署在一个局域网的网络出口位置 通过**<u><em>将内部网络IP地址 替换成出口的IP地址</em></u><strong>提供</strong>公网可达性<strong>和</strong>上层协议连接能力**&#x3D;&#x3D;</p><p>&#x3D;&#x3D;目的$\rightarrow$提供一种虚拟的寻址机制&#x3D;&#x3D;</p><p>正常情况下 使用私有IP地址不需要向IANA提出申请 但是这些地址 不能作为源地址和目的地址</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul><li>在组织的出口部署 NAT gateway  其功能是：<ul><li>报文离开局域网进入Internet时 将源地址替换成公网地址(一般是出口设备的interface地址)</li><li>对访问目标来说，访问源地址自然就是NAT gateway，target会回复给NAT gateway</li><li>收到回复后 NAT gateway再把目的地址<strong>替换成私有IP地址</strong></li></ul></li><li>显然 对通信的双方来说 NAT gateway是<strong>透明</strong>的 数量庞大的内网主机 也不需要公有的IP地址了</li></ul><h4 id="注意⚠️"><a href="#注意⚠️" class="headerlink" title="注意⚠️"></a>注意⚠️</h4><ol><li><p>外网 一般无法通过IP地址访问内网主机 想要访问有两种方法</p></li><li><blockquote><p>一个全局地址 可以让不同PC同时访问<em><strong>不同</strong></em>服务器吗？$\rightarrow$ 可以 离开站点前的私有IP地址映射不一样</p><p><strong>一个全局地址 可以让不同PC同时访问<em>相同</em>服务器吗？$\rightarrow$ 不可以 因为在NAT Gateway收到服务器传回的报文时 不知道是哪个PC发送的(这个报文的源地址是服务器 目的地址是NAT Gateway的IP地址)</strong></p></blockquote></li><li><p>为实现双方的持续交流，NAT gateway需要维护一张关联表 $\rightarrow$ 地址转换表(translation table) 存储重写地址时所需的信息来实现地址转换 具体实现方法：</p><ul><li>当数据报离开站点 NAT将目的地址和发送方的私有地址记录在一起。</li><li>当数据报到达站点 NAT查询translation table 来确认哪台站内计算机接收这个相应。</li></ul></li><li><p>全局地址数量M一般远小于主机数 一个一般对应4000个内部地址</p><ul><li>内网轮流使用NAT地址池里的全局地址 当NAT地址池的全局地址被用完时 主机对外部的因特网访问将必须等待</li></ul></li><li><p>NAT gateway对交流双方是透明的</p></li></ol><h3 id="NAPT-网络地址与端口转换"><a href="#NAPT-网络地址与端口转换" class="headerlink" title="NAPT 网络地址与端口转换"></a>NAPT 网络地址与端口转换</h3><p>与NAT的区别在于 NAT是一对一转换 而NAPT则在转换时把端口号也作为参数 实现多对一转换</p><p>用于以下的两种情况 解决了 收到应答不知道给谁的问题。</p><blockquote><p>内网里两台不同主机 要同一时间 访问同一个服务器 </p><p>内网里 一台主机的 多个不同进程 要同时访问同一个服务器</p></blockquote><p>生成一个本地的端口号(临时生成 只用来区分不同主机或进程)</p><h5 id="NAPT的负载均衡器功能"><a href="#NAPT的负载均衡器功能" class="headerlink" title="NAPT的负载均衡器功能"></a>NAPT的负载均衡器功能</h5><p>外到内网服务器的访问 表的静态记录项 通过服务端口区分不同服务器的访问</p><p>接受外部主机的请求时 NAT根据已有的NAPT表 把全局地址翻译成不同内部地址 建立与多部主机的连接。根据NAPT表 转发数据包到多个内部服务器 实现服务器负载均衡(访问的是单个服务器 多个一起处理) 或不同服务器的访问</p><h5 id="外部通过NAT的访问内网-NART表项动态建立"><a href="#外部通过NAT的访问内网-NART表项动态建立" class="headerlink" title="外部通过NAT的访问内网 NART表项动态建立"></a>外部通过NAT的访问内网 NART表项动态建立</h5><p>如果是一般主机非固定的服务器，由于NAPT表中一般主机和NAT公有地址只是内到外访问时临时建立的，即NAPT表无法自动构建转换映射表，所以外部访问一般无法根据IP地址访问内网主机。一种方法通过域名访问，即建立内网域名DNS（二级域名）和NAT联用机制，由DNS触发建立NAT表的一个记录项。这时NAPT动态建立对应表项，IP地址利用率更高</p><h3 id="NAT的优缺点"><a href="#NAT的优缺点" class="headerlink" title="NAT的优缺点"></a>NAT的优缺点</h3><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><blockquote><p>节约Internet地址</p><p>解决相同IP地址的负载扩展(均衡)</p><p>消除重新编址 (现有方案能继续使用)</p></blockquote><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><blockquote><p>延迟增加</p><p>降低地址的 Traceability</p><p>某些应用功能交互更加复杂或失效(FTP TCP要解决NAT穿越问题 而要求特定的源端口和源地址的应用无法工作)</p></blockquote><hr><h1 id="因特网系统初始化设置-BOOTP-amp-DHCP"><a href="#因特网系统初始化设置-BOOTP-amp-DHCP" class="headerlink" title="因特网系统初始化设置 BOOTP &amp; DHCP"></a>因特网系统初始化设置 BOOTP &amp; DHCP</h1><ul><li>TCP&#x2F;IP 协议参数和配置 需要参数：<ul><li>硬件地址</li><li>使用协议类型</li><li>IP地址</li><li>默认IP路由器地址(下一跳地址)</li><li>地址掩码(地址类型)</li><li>DNS服务器地址</li></ul></li></ul><h5 id="协议配置-：-协议软件被-协议通用性原则-约束。-需要协议软件参数化，所以要在编译之前对参数赋值"><a href="#协议配置-：-协议软件被-协议通用性原则-约束。-需要协议软件参数化，所以要在编译之前对参数赋值" class="headerlink" title="协议配置 ： 协议软件被 协议通用性原则 约束。 需要协议软件参数化，所以要在编译之前对参数赋值"></a>协议配置 ： 协议软件被 协议通用性原则 约束。 需要协议软件参数化，所以要在编译之前对参数赋值</h5><p>如何配置协议？ <em><u><strong>在不知道IP地址情况下交流的核心思路$\rightarrow$使用广播</strong></u></em></p><blockquote><p>人工配置 手动录入(仍然是常用的方法)</p><p>存储文件配置 打开配置文件进行配置(因为系统只在启动时读取配置文件 所以修改参数配置需要重启)</p><p>自动协议配置 只要出现大量设备或者频繁修改 前两种几乎都行不通</p></blockquote><h5 id="自动协议配置方法"><a href="#自动协议配置方法" class="headerlink" title="自动协议配置方法"></a>自动协议配置方法</h5><p>要克服单机分散配置问题 在<strong>服务器端进行集中配置</strong> 然后通过请求&#x2F;应答形式 当计算机启动入网前发出请求 网络服务器返回适当配置响应</p><ol><li>配置协议前 使用RARP 用MAC多播(主要使用RARP的是无盘工作站 存储不了自己的IP地址 MAC地址在网卡上)</li><li>此时不知道默认网关 使用ICMP 掩码请求&#x2F;网关发现 用IP广播方式获取路由器参数(获取地址掩码&#x2F;默认网关地址)<ul><li><strong>地址屏蔽码</strong>(掩码)请求&#x2F;应答Address Mask Request&#x2F; Reply:主机启动时，会广播一个地址屏蔽码请求报文。服务器或路由器收到地址屏蔽码请求报文后，回送一个<strong>包含本网使用的32位地址屏蔽码</strong>的应答报文。</li></ul></li></ol><p><em>总的来说 协议从底层到高层进行配置 通过底层广播协议&#x2F;单播的方式逐步获得高层参数信息。</em></p><h5 id="自举的过程如下"><a href="#自举的过程如下" class="headerlink" title="自举的过程如下"></a>自举的过程如下</h5><blockquote><p>MAC 广播RARP request 获取IP地址</p><p>等待RARP reply 如果T1时间内无响应 返回1</p><p>广播ICMP地址掩码请求 获取IP地址掩码</p><p>等待回复 如果T2时间无响应 返回3</p><p>利用ICMP网关发现 找到默然路由器的IP地址 并将其加入路由表中</p></blockquote><p>可以注意到 需要至少3次分散的协议过程 会出现分散 延时 报文不同</p><h3 id="自举协议BOOTP-Bootstrap-Protocol"><a href="#自举协议BOOTP-Bootstrap-Protocol" class="headerlink" title="自举协议BOOTP(Bootstrap Protocol)"></a>自举协议BOOTP(Bootstrap Protocol)</h3><p>Bootstrap $\rightarrow$ pull or drag oneself by one’s own </p><h5 id="功能：一次广播一个BOOTP协议请求包-BOOTP服务器查找各项信息返回"><a href="#功能：一次广播一个BOOTP协议请求包-BOOTP服务器查找各项信息返回" class="headerlink" title="功能：一次广播一个BOOTP协议请求包 BOOTP服务器查找各项信息返回"></a>功能：一次广播一个BOOTP协议请求包 BOOTP服务器查找各项信息返回</h5><p><strong>注意： BOOTP协议由于尚未配置参数 所以进行了特殊的地址定义 IP广播地址全1 作为目的地址 全0作为源地址</strong></p><p><strong>BOOTP服务器可使用MAC地址进行单播(此时工作站还不知道自己的IP地址 所以IP单播无效) 或者全1广播地址回送 自举协议使用UDP发送(68&#x2F;67 端口)</strong></p><h5 id="自举协议的报文格式"><a href="#自举协议的报文格式" class="headerlink" title="自举协议的报文格式"></a>自举协议的报文格式</h5><h5 id="BOOTP的局限性"><a href="#BOOTP的局限性" class="headerlink" title="BOOTP的局限性"></a>BOOTP的局限性</h5><blockquote><p>在工作前 需要对BOOTP服务器上配置相关主机参数数据库 且是固定设置值。只能满足&#x3D;&#x3D;小区域固定IP配置&#x3D;&#x3D;和&#x3D;&#x3D;PC的静态接入网络&#x3D;&#x3D;需求。在大区域或不固定IP配置的情况下 很难实现。</p></blockquote><h3 id="DHCP-x2F-Dynamic-Host-Configuration-Protocol"><a href="#DHCP-x2F-Dynamic-Host-Configuration-Protocol" class="headerlink" title="DHCP&#x2F;Dynamic Host Configuration Protocol"></a>DHCP&#x2F;Dynamic Host Configuration Protocol</h3><p>1997年 IETF设计了动态主机配置协议 这个协议是在BOOTP基础上的扩展改进 </p><p><strong>DHCP的最大特点就是 可以自动获取IP地址分配(不固定)机制，也就是即插即用的联网</strong></p><blockquote><p>仍然使用IP广播地址全1作为目的地址 全0作为源地址 </p><p>DHCP服务器也可使用MAC地址进行单播 或者全1广播地址回送 (和BOOTP是一样的端口)</p><p>不同的是 如果有数据库中该主机的指定信息(这和BOOTP一致)就取出返回 <strong>如果没有(新增)从IP地址缓冲池动态选择一个IP地址分配给主机</strong></p></blockquote><h5 id="IP租借：由于DHCP是一个IP地址按需分配的-不固定机制-DHCP需要地址租期的概念。产生的地址在过了有效期-1s-136years-后就会被回收。"><a href="#IP租借：由于DHCP是一个IP地址按需分配的-不固定机制-DHCP需要地址租期的概念。产生的地址在过了有效期-1s-136years-后就会被回收。" class="headerlink" title="IP租借：由于DHCP是一个IP地址按需分配的 不固定机制 DHCP需要地址租期的概念。产生的地址在过了有效期(1s-136years)后就会被回收。"></a>IP租借：由于DHCP是一个IP地址按需分配的 不固定机制 DHCP需要地址租期的概念。产生的地址在过了有效期(1s-136years)后就会被回收。</h5><ul><li>DHCP通过IP地址缓冲池和租借IP按需分配的形式 形成对移动计算机入网的动态配置信息，不需要管理员对配置数据库进行任何修改。</li></ul><h5 id="DHCP优化"><a href="#DHCP优化" class="headerlink" title="DHCP优化"></a>DHCP优化</h5><blockquote><p>使用DHCP的主机首先随机广播发送 DHCP发现报文(短报) 减少冲撞的概率，在确认DHCP服务器后再发送请求报文。DHCP服务器地址通常会被永久保存，以后会单播(类似我们的记住已经连接过的WIFI密码)</p></blockquote><h5 id="DHCP中继"><a href="#DHCP中继" class="headerlink" title="DHCP中继"></a>DHCP中继</h5><blockquote><p>不是每个网络都需要DHCP服务器 设置一个DHCP中继 可以代理转发DHCP服务器的请求和响应(一般的路由器都有此功能)</p></blockquote><h5 id="DHCP使用和DHCP报文"><a href="#DHCP使用和DHCP报文" class="headerlink" title="DHCP使用和DHCP报文"></a>DHCP使用和DHCP报文</h5><blockquote><p>属性配置选择 $\rightarrow$ 固定IP地址&#x2F; 自动获取IP地址(选择这个就是使用DHCP)</p><p>DHCP报文和BOOTP差不多 添加了一个 FLAGS选项 让用户说明希望服务器使用广播应答还是直接应答</p></blockquote><p>由于DHCP和DNS系统不关联 对有域名计算机来说 IP地址和DNS域名的映射在从DHCP中自动获取新的IP后，计算机名字将会失效</p><hr><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="请简述自举配置协议BOOTP要解决什么问题？"><a href="#请简述自举配置协议BOOTP要解决什么问题？" class="headerlink" title="请简述自举配置协议BOOTP要解决什么问题？"></a><em><strong>请简述自举配置协议BOOTP要解决什么问题？</strong></em></h4><p>​    BOOTP用于解决在自动配置协议时 需要发送多次不同协议报文带来的分散、时延等麻烦。通过广播 一次发送一个BOOTP请求包，由BOOTP服务器查找各项信息返回。</p><p><strong>标准答案：</strong></p><p><strong>第1发现协议地址，实际上我们还是可以通过RARP形式，在未知环境中获取本机参数；</strong></p><p><strong>第2获取配置服务器参数，实际上采用ICMP的掩码请求形式，以IP广播的方法请求获取</strong></p><h4 id="请简述DHCP-协议在BOOTP基础上主要改进了什么？。"><a href="#请简述DHCP-协议在BOOTP基础上主要改进了什么？。" class="headerlink" title="请简述DHCP 协议在BOOTP基础上主要改进了什么？。"></a><em><strong>请简述DHCP 协议在BOOTP基础上主要改进了什么？。</strong></em></h4><p>​    DHCP可以自动获取IP地址分配(不固定)机制，也就是即插即用的联网。和BOOTP不同的地方在于，如果服务器数据库中没有发出请求的主机信息，DHCP能从IP地址缓冲池里动态选择一个IP地址分配给主机(在租期过后则回收这个地址)。</p><h4 id="请列出在使用BOOTP协议前，一台计算机在利用网络启动之前，必须在本地需要具有什么协议与参数。"><a href="#请列出在使用BOOTP协议前，一台计算机在利用网络启动之前，必须在本地需要具有什么协议与参数。" class="headerlink" title="请列出在使用BOOTP协议前，一台计算机在利用网络启动之前，必须在本地需要具有什么协议与参数。"></a><em><strong>请列出在使用BOOTP协议前，一台计算机在利用网络启动之前，必须在本地需要具有什么协议与参数。</strong></em></h4><p>​    1.需要知道自己的MAC地址(硬件类型)</p><p>​    2.需要支持RARP协议(能进行MAC广播)</p><p>​    3.需要支持ICMP协议(用于获取地址掩码和找到默认路由)</p><p>​    4.需要支持UDP协议(用于发送BOOTP数据包)</p><h4 id="比较使用绑定方案地址分配协议和DHCP动态地址分配协议，哪个更适用于广域网？"><a href="#比较使用绑定方案地址分配协议和DHCP动态地址分配协议，哪个更适用于广域网？" class="headerlink" title="比较使用绑定方案地址分配协议和DHCP动态地址分配协议，哪个更适用于广域网？"></a><em><strong>比较使用绑定方案地址分配协议和DHCP动态地址分配协议，哪个更适用于广域网？</strong></em></h4><p>​    我认为DHCP动态地址分配协议更适合广域网。广域网区域大，而且用户变化大，静态的地址分配方案无法满足大量用户的需求，使用DHCP可以满足大量用户动态接入网络的需求，同时还能提高地址的利用率(不是每台主机都一直工作，如果静态分配会产生大量闲置时间)。与此同时，DHCP优化还可以减少发广播的次数。不管是从效率还是从可行性上看，都应该选择DHCP动态地址分配协议。</p>]]></content>
    
    
    
    <tags>
      
      <tag>互联网原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mass Media &amp; VoIP</title>
    <link href="/2020/12/08/%E5%A4%9A%E5%AA%92%E4%BD%93-&amp;-IP%E7%94%B5%E8%AF%9D(VoIP)/"/>
    <url>/2020/12/08/%E5%A4%9A%E5%AA%92%E4%BD%93-&amp;-IP%E7%94%B5%E8%AF%9D(VoIP)/</url>
    
    <content type="html"><![CDATA[<h1 id="多媒体-amp-IP电话-VoIP"><a href="#多媒体-amp-IP电话-VoIP" class="headerlink" title="多媒体 &amp; IP电话(VoIP)"></a>多媒体 &amp; IP电话(VoIP)</h1><h2 id="互联网中的实时业务"><a href="#互联网中的实时业务" class="headerlink" title="互联网中的实时业务"></a>互联网中的实时业务</h2><ul><li>多媒体「multimedia」 一般用来指含有音频&#x2F;视频的数据，当然也适用于文本</li></ul><p>这类信号在数字化后如果按照因特网传输数据的方式到达接收方，<strong>并实时的展示出来</strong> 其结果是难以接受的</p><p>我们知道 音视频信号的传播过程 包括 抽样、编码(D&#x3D;&gt;S)、网络传输、解码</p><p>而因特网存在的 丢包 和 乱序问题</p><p>丢包 $\Rightarrow$ 抽样值丢失</p><p>乱序 $\Rightarrow$ 抽样值时延不一致！这会造成以下我们所说的 <code>抖动</code></p><ul><li><h4 id="网络吞吐率T-单位时间内-有效传输的-比特-x2F-字节数「与带宽、速率的区别在于-它们俩用来表示某条链路-而不是整个网络」"><a href="#网络吞吐率T-单位时间内-有效传输的-比特-x2F-字节数「与带宽、速率的区别在于-它们俩用来表示某条链路-而不是整个网络」" class="headerlink" title="网络吞吐率T 单位时间内 有效传输的 比特&#x2F;字节数「与带宽、速率的区别在于 它们俩用来表示某条链路 而不是整个网络」"></a>网络吞吐率T 单位时间内 有效传输的 比特&#x2F;字节数「与带宽、速率的区别在于 它们俩用来表示某条链路 而不是整个网络」</h4></li><li><h4 id="网络时延D-一个分组-通过网络需要的时间"><a href="#网络时延D-一个分组-通过网络需要的时间" class="headerlink" title="网络时延D 一个分组 通过网络需要的时间"></a>网络时延D 一个分组 通过网络需要的时间</h4></li></ul><p>处理实时业务时碰到的最大困难， 不是分组丢失 而是 <strong><code>抖动「jitter」</code></strong> 这意味着「**<code>与常规的传输协议不同，传输实时数据的协议 只需要处理抖动问题，而不需要重传丢失的分组</code>**」</p><p><em><u>抖动的定义：「信号的某特定时刻相对于其理想时间位置上的短期偏离」</u></em> 相当于“跳ping、很小的延迟变化”</p><p>因特网无法要求底层的网络具有处理实时业务的功能 所以解决方案有两个</p><ol><li><h4 id="设计等时延、无抖动的网络-PSTN-TDM电路"><a href="#设计等时延、无抖动的网络-PSTN-TDM电路" class="headerlink" title="设计等时延、无抖动的网络(PSTN\TDM电路)"></a>设计等时延、无抖动的网络(PSTN\TDM电路)</h4></li><li><h4 id="设计抖动补偿协议-实现平滑重放「playback」-这又包含了两种主要的模式"><a href="#设计抖动补偿协议-实现平滑重放「playback」-这又包含了两种主要的模式" class="headerlink" title="设计抖动补偿协议 实现平滑重放「playback」 这又包含了两种主要的模式"></a>设计抖动补偿协议 实现<em><strong>平滑重放「playback」</strong></em> 这又包含了两种主要的模式</h4><ol><li><h5 id="时间戳「timestamp」-每个小片提供一个时间戳，接收方按照时间戳重放"><a href="#时间戳「timestamp」-每个小片提供一个时间戳，接收方按照时间戳重放" class="headerlink" title="时间戳「timestamp」 每个小片提供一个时间戳，接收方按照时间戳重放"></a>时间戳「timestamp」 每个小片提供一个时间戳，接收方按照时间戳重放</h5></li><li><h5 id="抖动缓冲「jitter-buffer」缓冲收到的数据、然后推迟重放"><a href="#抖动缓冲「jitter-buffer」缓冲收到的数据、然后推迟重放" class="headerlink" title="抖动缓冲「jitter buffer」缓冲收到的数据、然后推迟重放"></a>抖动缓冲「jitter buffer」缓冲收到的数据、然后推迟重放</h5></li></ol><p>实现抖动缓冲 我们只需要维护一个cache然后延迟d个时间单位，虽然分组到达的时间略有不同，但总会在d时间之内到达，我们均匀的输出分组，就没有关系了</p></li></ol><ul><li>想要实现流式传输有两种方法 ： 实时流式传输「RTS」 和 顺序流式传输</li><li>新世纪以来，流式存储下载的局限性越来越明显，而顺序流式传输「progressive streaming」成为主流</li></ul><h2 id="实时传输协议RTP「Real-time-Transport-Protocol」"><a href="#实时传输协议RTP「Real-time-Transport-Protocol」" class="headerlink" title="实时传输协议RTP「Real-time Transport Protocol」"></a>实时传输协议RTP「Real-time Transport Protocol」</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p>来自应用层｜支持单播&#x2F;多播｜提供时间信息+实现流同步｜<strong>通常使用UDP 也可在TCP&#x2F;ATM等协议上工作</strong></p><p><strong>RTP &#x3D; RTP数据协议+RTP控制协议</strong></p><h3 id="RTP的架构如下："><a href="#RTP的架构如下：" class="headerlink" title="RTP的架构如下："></a>RTP的架构如下：</h3><ul><li>version｜P: 载荷是否为0填充｜X：是否有扩展头部 ｜ M：特殊帧标志</li><li><strong>CC「CSRC计数」：即有多少个源(媒体流被按照规则封装成一个个源)</strong><ul><li>一个多媒体文件中， 视频、音频、字幕···会来自不同的轨道 它们被封装成不同的源 然后在接收端混合输出</li></ul></li><li><strong>PT：载荷的编码特性「包括 编码算法 采样频率 承载通道」 用来指示接收端如何解码</strong></li><li><strong>序列号</strong> 每个数据分组有一个16位的序列号，每次自加1。类似TCP序列号， 用来检测<strong>是否丢包</strong> 序列号初始值是随机的 因为要防范对加密数据的攻击</li><li><strong>时间戳(时标)</strong> 32位 反映RTP数据包中第一个数据的 <strong>采样时刻</strong> 初始时间戳是随机选择的，而随后从单调且线性增加的时钟导出，以解决同步与抖动计算。 时间戳的单位不是固定的s&#x2F;ms 而是根据载荷类型确定</li></ul><blockquote><p>序列号与时间戳 是完全独立的</p><p>因为分组顺序 和 时间顺序 并不是线性相关的</p><p>「⚠️ 意思不只是 每个分组和分组到达的时间不是线性相关。 问题的关键在于 信号是数字化(离散)的，而时间戳会随着时间一直累加，而如果信号进入了空白帧，那么分组可以进入缓变状态(等到有数据了 再发送这个分组)」</p></blockquote><ul><li><strong>CSRC列表：接收端会对多个源的数据进行混合输出 以此列表作为参照</strong> </li><li>SSRC：标识多个源进行同步。 不是随机选择，每个RTP包里的每个同步源(需要同步播放)都有不同的SSRC标识</li></ul><h2 id="RTCP协议「Real-time-Transport-Control-Protocol」它和RTP是连体婴儿-不可分割"><a href="#RTCP协议「Real-time-Transport-Control-Protocol」它和RTP是连体婴儿-不可分割" class="headerlink" title="RTCP协议「Real-time Transport Control Protocol」它和RTP是连体婴儿 不可分割"></a>RTCP协议「Real-time Transport Control Protocol」它和RTP是连体婴儿 不可分割</h2><p><strong>不对实际音视频数据进行封装，是控制短分组协议</strong></p><h3 id="RTCP的任务："><a href="#RTCP的任务：" class="headerlink" title="RTCP的任务："></a>RTCP的任务：</h3><ul><li>服务质量监控和反馈<ul><li>接收端会多播发送丢包率、抖动···，发送端会多播发送 分组数、时间戳、绝对时间</li></ul></li><li>多源媒体之间的标识和同步</li></ul><h2 id="IP电话-IP-telephony-x2F-IP语音-Voice-over-IP-x2F-VoIP"><a href="#IP电话-IP-telephony-x2F-IP语音-Voice-over-IP-x2F-VoIP" class="headerlink" title="IP电话(IP telephony)&#x2F;IP语音(Voice over IP&#x2F; VoIP)"></a>IP电话(IP telephony)&#x2F;IP语音(Voice over IP&#x2F; VoIP)</h2><p>使用IP路由器取代传统电话交换机的动机很简单：💰</p><p>而且由于底层的网络设施共享，只要有了基本的设备就可以实现IP通话</p><p>IP电话的应用所面对的最大挑战就是 设计者希望IP电话能和已有的公共电话交换网络PSTN(Public Switched Telephone Network)兼容(向后兼容)，它们需要实现双向可通话。</p><h2 id="信令与VoIP标准"><a href="#信令与VoIP标准" class="headerlink" title="信令与VoIP标准"></a>信令与VoIP标准</h2><p>目前有两个组织为IP电话制定了标准：</p><p>国际电信联盟International Telecommunications Union 制定电话标准</p><p>因特网工程任务组Internet Engineering Task Force&#x2F; IETF 制定TCP&#x2F;IP标准</p><h3 id="IP电话的基础技术"><a href="#IP电话的基础技术" class="headerlink" title="IP电话的基础技术"></a>IP电话的基础技术</h3><ul><li>音频采用脉冲编码调制(PCM&#x2F; Pulse Code Modulation) 编码</li><li>数字化音频使用 RTP进行传输</li></ul><h3 id="IP电话的主要复杂之处在于-呼叫建立和呼叫管理-而我们把「建立和终止呼叫的过程-称为-信令-signaling-」"><a href="#IP电话的主要复杂之处在于-呼叫建立和呼叫管理-而我们把「建立和终止呼叫的过程-称为-信令-signaling-」" class="headerlink" title="IP电话的主要复杂之处在于 呼叫建立和呼叫管理  而我们把「建立和终止呼叫的过程 称为 信令(signaling)」"></a>IP电话的主要复杂之处在于 呼叫建立和呼叫管理  而我们把「建立和终止呼叫的过程 称为 信令(signaling)」</h3><p>电话中处理呼叫管理所采用的机制 就是<code>信令系统</code></p><p>为了和已有的电话系统兼容，我们需要和SS7(Signaling System 7)兼容 IETF剔除了 会话初启协议「Session Initiation Protocol，SIP」   </p><p><code>SDP（Session Description Protocol）是一个用来描述多媒体会话的应用层控制协议，它是一个基于文本的协议，用于会话建立过程中的媒体类型和编码方案的协商等</code></p><p><code>H.323 ITU定义的IP电话信令协议</code></p><h3 id="IP电话质量控制"><a href="#IP电话质量控制" class="headerlink" title="IP电话质量控制"></a>IP电话质量控制</h3><p>要求：</p><ul><li>使用光纤网络+特殊补偿算法 可以容忍最多30%的丢包率</li><li>电话通信端到端延时要求 &lt; 250ms。</li></ul><h2 id="SIP协议「Session-Initialization-Protocol」"><a href="#SIP协议「Session-Initialization-Protocol」" class="headerlink" title="SIP协议「Session Initialization Protocol」"></a>SIP协议「Session Initialization Protocol」</h2><p><code>用以一个或多个用户的会话建立、更改、管理、终止。不能单独完成多媒体通信的呼叫。</code></p><p>STP和SDP+RTP&#x2F;RTCP一起配合 组建完整的多媒体通信系统</p><h3 id="SIP功能："><a href="#SIP功能：" class="headerlink" title="SIP功能："></a>SIP功能：</h3><p>•用户定位：确定参加通信的终端用户位置。</p><p>•用户通信能力协商：确定通信的媒体类型和参 数。</p><p>•用户交互意愿：确定被叫加入通信的意愿。</p><p>•呼叫建立：建立主叫和被叫的会话参数。</p><p>•呼叫处理和控制：包括呼叫重定向、呼叫转移 ，终止呼叫等。</p><h3 id="SIP特点"><a href="#SIP特点" class="headerlink" title="SIP特点"></a>SIP特点</h3><ul><li>通过代理和重定向请求用户当前位置以支持用户移动性</li><li>独立于传输层协议，可以承载在不同的传输协议上 并扩展方便</li><li>只建立 更改 终止一个会话，和会话内容无关，这意味着其载体可以是任意的(甚至可以是视频和游戏)</li></ul><h3 id="SIP在网络中的主要实体："><a href="#SIP在网络中的主要实体：" class="headerlink" title="SIP在网络中的主要实体："></a>SIP在网络中的主要实体：</h3><ul><li><p>用户代理（ User Agent ）：用来发起或接收请求 的逻辑实体设备（如 IP 电话机、计算机、媒体网关等）。</p></li><li><p>用户代理客户 UAC （ User Agent Client ）：发 起请求的一方（如 SIP Phone ）；</p></li><li><p>用户代理服务器 UAS （ User Agent Server ）： 接收 请求，产生响应的一方。</p></li><li><p>定位 服务器（ Location Server ）：管理提供被 叫的位置数据库 , 如每个用户的 IP 地址集合（ IP 地址、电话号码、 email 地址）、用户订购业务 、用户偏好等，在呼叫过程中提供被叫用户的位 置信息</p></li><li><p>支持服务器（ Support Server ）：代理服务器、 重定向服务器、注册服务器，实际呼叫过程扩展 应用。 </p></li><li><p>代理服务器：作为一个实体转发用户代理客户 UAC 的请求至被叫（用户代理服务器 UAS ）或 一个代理服务器。</p></li><li><p>注册服务器：接收注册请求 , 将注册请求中的地 址映射关系更新到定位数据库中，并负责验证注 册请求和确保底层数据库一致性。</p></li><li><p>重定向服务器：为所收到的请求返回一个或多个 新的地址，用户代理客户 UAC 再向这些新的地址 发起请求。重定向服务器并不接收呼叫或拒绝呼 叫，主要完成路由重新定向，与注册过程配合可 以支持 SIP 终端的移动性</p></li></ul><h3 id="SIP协议消息类型"><a href="#SIP协议消息类型" class="headerlink" title="SIP协议消息类型"></a>SIP协议消息类型</h3><p>SIP分为请求和响应</p><hr><blockquote><p> <strong>试列举3-5种网络中可能产生的时延，什么是等时时延或非等时时延？</strong></p><p>可能的时延有 信号传播时延、信号处理时延、路由器存储转发时延、丢包重传时延、播放时延等。</p><p>等时时延&amp;非等时时延 ： </p><p>以信号传输为例 就是信号总在一段固定时间后到达，这其中的时延称为等时时延</p><p>如果每次传输信号会在不同的时间后到达，就将这段时延称为非等时时延</p></blockquote><blockquote><p><strong>在因特网丢包、乱序的状况下，分析比较对非实时email和实时IP电话所产生的影响？</strong></p><p>对于E-Mail来说，如果不使用可靠的传输协议，接收方很难收到正确、完整的信息。但由于其非实时性，借助SMTP等可靠传输协议实现差错检测和报文重传，客户发送的E-Mail几乎总能正确、完整的到达接收方处。</p><p>对于实时IP电话来说，由于音视频信号在网络上传输的特点，网络丢包、乱序导致网络抖动，使得还原出的信号产生失真。如果借助可靠传输，由于网络层丢包、乱序的状况，传输会不可避免的花费时间，会丧失实时性。如果实时传输并引入超时重传，在接收端已经收到并提取信息之后再把错误或丢失的数据包插播进来是毫无意义的。因此智能设计等时延、无抖动的网络结构 或者 设计补偿抖动的协议实现平滑重放。</p></blockquote><blockquote><p><strong>简述RTP协议中定义序列号、时标有什么作用？如何理解两者具有独立性。</strong></p><p>序列号 类似TCP序列号，用来检测是否丢包。</p><p>时间戳(时标) 反映RTP数据包中第一个数据的采样时刻，初始时间戳随机选择，随后则从单调、线性增加的时钟导出，以解决同步与抖动计算。</p><p>序列号所对应的是 分组顺序，时间戳对应的则是 时间顺序。两者之间不一定是线性相关的，因为信号的特点可能使得在一段时间内并无信号(数据帧)，或者出现可变长度视频编码(图像缓变)帧，而在这段时间内时间戳会一刻不停的累加。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>互联网原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>about C++ numeric</title>
    <link href="/2020/12/05/about%20numeric%20%E5%BA%93/"/>
    <url>/2020/12/05/about%20numeric%20%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="c-numeric-库"><a href="#c-numeric-库" class="headerlink" title="c++ numeric 库"></a>c++ numeric 库</h1><p>accumulate 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">vector&lt;?&gt; a;<br><span class="hljs-built_in">accumulate</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), initValue);  <span class="hljs-comment">// 3参数累加时候的初始值 如果是字符串则是(string)&quot;&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Programming</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SP edition 信息社会传奇</title>
    <link href="/2020/09/14/SP-edition-%E4%BF%A1%E6%81%AF%E7%A4%BE%E4%BC%9A%E4%BC%A0%E5%A5%87/"/>
    <url>/2020/09/14/SP-edition-%E4%BF%A1%E6%81%AF%E7%A4%BE%E4%BC%9A%E4%BC%A0%E5%A5%87/</url>
    
    <content type="html"><![CDATA[<h1 id="SP-edition-信息社会传奇"><a href="#SP-edition-信息社会传奇" class="headerlink" title="#SP edition 信息社会传奇"></a>#SP edition 信息社会传奇</h1><ul><li><strong>信息网络 能源 交通 是现代社会的三大基础</strong></li><li><strong>数据$\Rightarrow$  传输和存储的 可识别的数字符号</strong></li><li>信息交互 (一对一 一对多 多对多)<ul><li>有效性</li><li>安全性</li></ul></li><li><strong>计算机网络$\Rightarrow$ 将计算机或外部设备连接在一起，实现 <u>信息交互和应用服务</u>的设备 通信链路 通信规约和软件的集合</strong></li></ul><ul><li>因特网 $\Rightarrow$ 特指由美国创建和管理的全球互联网</li></ul><hr><h4 id="计算机网络发展-Web发展-x2F-快速发展期"><a href="#计算机网络发展-Web发展-x2F-快速发展期" class="headerlink" title="计算机网络发展(Web发展&#x2F;快速发展期)"></a>计算机网络发展(Web发展&#x2F;快速发展期)</h4><ul><li>Tim Berners-Lee 1989年提出了 Web， 1991年开通了第一个 WWW网站<a href="https://info.cern.ch/">https://info.cern.ch/</a>  1993年制定了全球信息浏览的Web规范</li><li>1994年8月11日 netMarket公司 建立了第一个电子商务网站并完成了全球第一笔网络零售交易</li><li>1995年 杰夫·贝佐斯创建了 Amazon</li><li>1994年4月20日 中国科学技术网成功和Internet连接(64k&#x2F;s)</li><li>1994年10月 Grand Juction公司推出第一套快速以太网</li><li>1995年3月 IEEE宣布了快速以太网标准 Fast Ethernet LAN进入100M时代</li><li>1997年6月 IEEE802.11标准出台 无线网络代替了有线网络实现高效 高速的联网方案 (WIFI)</li><li>1998～1999 高速以太网标准形成 </li><li>1998年9月7日 Google成立 &#x2F; qq出现</li><li>2001年 万兆以太网出现(有线)(用于组网核心 城域网)</li><li>2004年 Mark Zuckerberg 建立Facebook</li><li>2006年 Twitter出现</li><li>2007年6月29日 Steve Jobs的iPhone上市 移动互联网时代开启</li><li>2007年11月 Google发起的手机联盟推出Android 以Apache开源许可证的授权方式开放源代码</li></ul><hr><h4 id="计算机网络提供的服务"><a href="#计算机网络提供的服务" class="headerlink" title="计算机网络提供的服务"></a>计算机网络提供的服务</h4><p><strong><u>三大核心$\Rightarrow$应用 交互 管理</u></strong></p><ol><li>网络应用服务</li><li>具体联网和信息交互(解决不同速率 距离 成本需要的组网技术) 1973年 Vinton Cerf&#x2F;Robert Kahn指出不可能存在能满足所有需求的单一分组网络技术</li><li>大规模的组网和信息交互技术</li><li>网络辅助技术 解决网络运行时的问题</li></ol><hr><h4 id="计算机网络应用"><a href="#计算机网络应用" class="headerlink" title="计算机网络应用"></a>计算机网络应用</h4><p>互联网网络应用(服务) 建立在TCP&#x2F;IP协议之上的应用服务</p><p>连接 $\Rightarrow$ 联合</p><p>早期的Internet应用 Telnet(远程计算机访问) Email FTP(文件传送) Newsgroup(新闻组) BBS论坛</p><h5 id="应用的发展过程"><a href="#应用的发展过程" class="headerlink" title="应用的发展过程"></a>应用的发展过程</h5><p>E-mail FTP $\Rightarrow$ 静态网页 $\Rightarrow$ 动态网页 $\Rightarrow$ 网上营销 $\Rightarrow$ 电子商务 $\Rightarrow$ 移动应用服务</p><p>宏观来看 信息交互 $\Rightarrow$ 综合业务应用 多媒体应用 $\Rightarrow$ 物联网 云计算应用</p><h5 id="万维网-World-Wide-Web"><a href="#万维网-World-Wide-Web" class="headerlink" title="万维网 World Wide Web"></a>万维网 World Wide Web</h5><p>万维网起源于欧洲粒子物理研究中心CERN </p><p>核心创新： 广泛关联 文档定位 文档快速传输 多格式文档阅读</p><p>网页(超文本) 表达的不再是线性的信息 而是非线性 联想式 信息关联的信息网。 Web表示这种由超文本连接起来的信息网</p><p>网址 $\Rightarrow$ 统一资源定位符 URL (Uniform Resource Locator)</p><p><a href="http://www.baidu.com/view/25482.htm">http://www.baidu.com/view/25482.htm</a></p><p> $\Uparrow$                     $\Uparrow$                              $\Uparrow$</p><p>Protocol       Name of Computer    Index and File name</p><p>支持缺省输入(支持默认)</p><h6 id="指定URL后-如何传输？"><a href="#指定URL后-如何传输？" class="headerlink" title="指定URL后 如何传输？"></a>指定URL后 如何传输？</h6><p>浏览器按URL链接服务器 请求服务 $\Rightarrow$ 网页服务器应答 返回 $\Rightarrow$ 浏览器完成解析之后显示网页</p><p>使用超文本传输协议HTTP 让网站和浏览器协商进行网页传输</p><h6 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h6><p>基本功能 $\Rightarrow$ 输入选取URL时 向Web服务器发送请求 接收文档 进行解析和显示</p><hr><p>现代计算机网络创造了全新社会形态 </p>]]></content>
    
    
    
    <tags>
      
      <tag>互联网原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
