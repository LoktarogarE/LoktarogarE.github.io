

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar1.png">
  <link rel="icon" href="/img/avatar1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Natsumi">
  <meta name="keywords" content="">
  
    <meta name="description" content="Chapter1 Sliding Window 424. 替换后的最长重复字符「Medium」 给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。 注意：字符串长度 和 k 不会超过 \(10^4\)。 示例 1： 123输入：s &#x3D; &quot;ABAB&quot;, k &#x3D; 2输出：4解释">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode Algorithm Notes">
<meta property="og:url" content="http://www.mementos.top/2021/08/09/Leetcode%20Algorithm%20Notes/index.html">
<meta property="og:site_name" content="Natsumi&#39;s Mementos">
<meta property="og:description" content="Chapter1 Sliding Window 424. 替换后的最长重复字符「Medium」 给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。 注意：字符串长度 和 k 不会超过 \(10^4\)。 示例 1： 123输入：s &#x3D; &quot;ABAB&quot;, k &#x3D; 2输出：4解释">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1612775858-VWbhYR-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1612776085-sZFGqE-image.png">
<meta property="og:image" content="http://www.mementos.top/Users/wanglei/Library/Application%20Support/typora-user-images/image-20210206201135253.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/33/33_fig1.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/153/1.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/153/2.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/153/3.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1611415418-aCzGJI-Picture2.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1603022900-GNKGMP-Picture2.png">
<meta property="og:image" content="http://www.mementos.top/Users/wanglei/Library/Application%20Support/typora-user-images/image-20210304232713519.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1603022900-qIFpAR-Picture4.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1603022900-hnUxBz-Picture5.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/9716b1a1ead21824b8216c7d54910bee4d838c011581f4e3d82a14f71cb392a1-Picture1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/51/1.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/51/2.png">
<meta property="article:published_time" content="2021-08-09T01:48:37.000Z">
<meta property="article:modified_time" content="2022-06-02T07:41:30.286Z">
<meta property="article:author" content="Natsumi">
<meta property="article:tag" content="Programming">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png">
  
  
  
  <title>Leetcode Algorithm Notes - Natsumi&#39;s Mementos</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/scroll.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/gradient.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.mementos.top","root":"/","version":"1.9.1","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"❡"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Natsumi&#39;s Mementos</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Leetcode Algorithm Notes"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          36k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          300 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Leetcode Algorithm Notes</h1>
            
              <p class="note note-info">
                
                  
                    <!-- compatible with older versions-->
                    本文最后更新于：3 个月前
                  
                
              </p>
            
            <div class="markdown-body">
              
              <h1 id="chapter1-sliding-window">Chapter1 Sliding Window</h1>
<h3 id="替换后的最长重复字符medium"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">424.
替换后的最长重复字符「Medium」</a></h3>
<p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换
<em>k</em> 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p>
<p><strong>注意：</strong>字符串长度 和 <em>k</em> 不会超过 <span class="math inline">\(10^4\)</span>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;ABAB&quot;, k = 2<br>输出：4<br>解释：用两个&#x27;A&#x27;替换为两个&#x27;B&#x27;,反之亦然。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;AABABBA&quot;, k = 1<br>输出：4<br>解释：<br>将中间的一个&#x27;A&#x27;替换为&#x27;B&#x27;,字符串变为 &quot;AABBBBA&quot;。<br>子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<p>​
我们可以枚举字符串中的每一个位置作为右端点，然后找到其最远的左端点的位置，满足该区间内除了出现次数最多的那一类字符之外，剩余的字符（即非最长重复字符）数量不超过
<span class="math inline">\(k\)</span> 个。</p>
<p>​
这样我们可以想到使用双指针维护这些区间，每次右指针右移，如果区间仍然满足条件，那么左指针不移动，否则左指针至多右移一格，保证区间长度不减小。</p>
<p>​
虽然这样的操作会导致部分区间不符合条件，即该区间内非最长重复字符超过了
<span class="math inline">\(k\)</span>
个。但是这样的区间也同样不可能对答案产生贡献。当我们右指针移动到尽头，左右指针对应的区间的长度必然对应一个长度最大的符合条件的区间。</p>
<p>​ 实际代码中，由于字符串中仅包含大写字母，我们可以使用一个长度为 <span class="math inline">\(26\)</span>
的数组维护每一个字符的出现次数。每次区间右移，我们更新右移位置的字符出现的次数，然后尝试用它<strong>更新重复字符出现次数的历史最大值</strong>，最后我们使用该最大值计算出区间内非最长重复字符的数量，以此判断左指针是否需要右移即可。</p>
</blockquote>
<p>变式「Medium 简单版」：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">1004.
最大连续1的个数 III</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">characterReplacement</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">num</span><span class="hljs-params">(<span class="hljs-number">26</span>)</span></span>;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-type">int</span> maxn = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>            num[s[right] - <span class="hljs-string">&#x27;A&#x27;</span>]++;<br>            maxn = <span class="hljs-built_in">max</span>(maxn, num[s[right] - <span class="hljs-string">&#x27;A&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> - maxn &gt; k) &#123;<br>                num[s[left] - <span class="hljs-string">&#x27;A&#x27;</span>]--;<br>                left++;<br>            &#125;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right - left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="可获得的最大点数medium"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/">1423.
可获得的最大点数「Medium」</a></h3>
<p>几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组
cardPoints 给出。</p>
<p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k
张卡牌。</p>
<p>你的点数就是你拿到手中的所有卡牌的点数之和。</p>
<p>给你一个整数数组 cardPoints 和整数
k，请你返回可以获得的最大点数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">输入：cardPoints = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">12</span><br>解释：第一次行动，不管拿哪张牌，你的点数总是 <span class="hljs-number">1</span> 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 <span class="hljs-number">1</span> + <span class="hljs-number">6</span> + <span class="hljs-number">5</span> = <span class="hljs-number">12</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">输入：cardPoints = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>], k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">4</span><br>解释：无论你拿起哪两张卡牌，可获得的点数总是 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">输入：cardPoints = [<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>], k = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">55</span><br>解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。<br></code></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">输入：cardPoints = [<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br>解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 <span class="hljs-number">1</span> 。 <br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<p>我们考虑到每次拿牌都是从首尾拿一张，总共拿 <code>k</code>
张，与其去想拿首或者尾的一张，那么不妨逆向思维一下，拿走 <code>k</code>
张之后还剩下 <code>n - k</code> 张，我们只需要保证剩下的
<code>n - k</code>
张牌的点数之和<strong>最小</strong>，这样就可以保证拿走的牌的点数之和最大，这样，我们就可以维护一个滑动窗口来求剩下点数的最小值。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(cardPoints []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(cardPoints)<br>    sum := <span class="hljs-number">0</span><br>    windowSize := n - k<br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> cardPoints[:windowSize] &#123;<br>        sum += val<br>    &#125;<br>    minSum := sum<br>    <span class="hljs-keyword">for</span> i := windowSize; i &lt; n; i++ &#123;<br>        sum += cardPoints[i] - cardPoints[i - windowSize]<br>        minSum = min(minSum, sum)<br>    &#125;<br>    total := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> cardPoints &#123;<br>        total += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> total - minSum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="接雨水hard"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">42.
接雨水「Hard」</a></h3>
<p>给定 <em>n</em> 个非负整数表示每个宽度为 1
的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" srcset="/img/loading.gif" lazyload alt="picture">
<figcaption aria-hidden="true">picture</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入：height = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">6</span><br>解释：上面是由数组 [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 表示的高度图，在这种情况下，可以接 <span class="hljs-number">6</span> 个单位的雨水（蓝色部分表示雨水）。 <br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<ol type="1">
<li>我们维护两个指针分别指向首尾两端 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(left=0,~right=n-1\)</span>
以及两个变量维护左边和右边的最大高度 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(left\_most\)</span> 和 <span class="math inline">\(right\_most\)</span>.</li>
<li>此时我们依次遍历，可以分两种情况讨论：
<ul>
<li>当 <span class="math inline">\(left\_most&lt;right\_most\)</span>
时，当前位置能存储的水的最大高度取决于 <span class="math inline">\(left\_most\)</span>，无论中间的柱子情况如何，我们此时一定可以存储
<span class="math inline">\(left\_most-nums[i]\)</span>
高度的水，直至在左边遇到高度大于 <span class="math inline">\(left\_most\)</span> 的柱子，然后更新 <span class="math inline">\(left\_most\)</span> 的值。</li>
<li>当 <span class="math inline">\(left\_most&gt;=right\_most\)</span>
时，当前位置能存储的水的最大高度取决于 <span class="math inline">\(right\_most\)</span>，无论中间的柱子情况如何，我们此时一定可以存储
<span class="math inline">\(right\_most-nums[i]\)</span>
高度的水，直至在右边遇到高度大于 <span class="math inline">\(right\_most\)</span> 的柱子，然后更新 <span class="math inline">\(right\_most\)</span> 的值。</li>
</ul></li>
<li>运行至 <span class="math inline">\(left=right\)</span> 结束。</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> left_most = <span class="hljs-number">0</span>, right_most = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) &#123;<br>                height[left] &gt;= left_most ? left_most = height[left] : count += left_most - height[left];<br>                ++left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                height[right] &gt;= right_most ? right_most = height[right] : count += right_most - height[right];<br>                --right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="最小覆盖子串hard"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/">76.
最小覆盖子串「Hard」</a></h3>
<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回
<code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果
<code>s</code> 中不存在涵盖 <code>t</code>
所有字符的子串，则返回空字符串 "" 。</p>
<p>注意：如果 <code>s</code>
中存在这样的子串，我们保证它是唯一的答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;<br>输出：&quot;BANC&quot;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<p>本问题要求我们返回字符串 <code>s</code> 中包含字符串 <code>t</code>
的全部字符的<strong>最小</strong>窗口。我们称包含 <code>t</code>
的全部字母的窗口为「可行」窗口。</p>
<p>我们考虑使用滑动窗口来解决此问题，维护两个指针 <span class="math inline">\(left\)</span> 和 <span class="math inline">\(right\)</span>，其中 <strong><em><span class="math inline">\(right\)</span> 用来「延展」窗口，<span class="math inline">\(left\)</span> 用来
「收缩」窗口</em></strong>。</p>
<p>我们的遍历在字符串 <code>s</code> 中进行，会出现以下几种情况：</p>
<ul>
<li>首先，不断右移 <span class="math inline">\(right\)</span>
指针，直至目前的子串完全包含 <code>t</code> 中的所有字符.</li>
<li>其次，我们开始收缩 <span class="math inline">\(left\)</span>
指针，直至 <span class="math inline">\([left,~right]\)</span>
区间内<strong>不完全</strong>包含 <code>t</code>
中所有字符，其中我们使用变量 <code>begin</code>
保存答案字符串的开头位置，<code>len</code>
表示符合条件字符串的长度.</li>
<li>当 <span class="math inline">\(right\)</span> 指针遍历至
<code>s</code> 的末尾，遍历结束.</li>
</ul>
<p>Details：</p>
<p>我们使用两个哈希表 <code>SFreq</code> 和 <code>TFreq</code>
来存储各个出现字符的次数，<code>check()</code>
函数用于判断这两个哈希表之间是否具有<strong>包含关系</strong>.</p>
<p><strong>算法缺陷</strong>：</p>
<p>每次左指针 <span class="math inline">\(left\)</span>
移动我们都需要判断两个哈希表之间的差异，造成了时间上的浪费，因此我们可以做一些优化.</p>
<p><strong><em>优化算法</em></strong>：</p>
<p>我们使用一个变量 <code>distant</code> 来维护目前滑动窗口中出现了与
<code>t</code> 字符串中的匹配数目，当 <code>distant = tlen</code>
的时候，我们此时就可以移动 <span class="math inline">\(left\)</span>
指针了，移动的过程中更新答案字符串的开头和长度，直至 <span class="math inline">\([left,~right]\)</span>
区间内<strong>不完全</strong>包含 <code>t</code> 中所有字符.</p>
<p>Details：</p>
<p>要清楚答案字符串的长度是 <span class="math inline">\(right -
left+1\)</span> 还是 <span class="math inline">\(right-left\)</span>，这个长度取决于 <span class="math inline">\(right\)</span>
的自加过程是在「收缩」阶段的前面或者后面，具体细节自己体会.</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutation-in-string/">567.
字符串的排列</a> 是本题的简单版，可以作为练习加深印象.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; SFreq, TFreq;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;p: TFreq) &#123;<br>            <span class="hljs-keyword">if</span> (SFreq[p.first] &lt; p.second) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; c : t) &#123;<br>            ++TFreq[c];<br>        &#125;<br>        <span class="hljs-type">int</span> begin = <span class="hljs-number">-1</span>, slen = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> len = INT_MAX;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; slen) &#123;<br>           <span class="hljs-keyword">if</span> (TFreq.<span class="hljs-built_in">count</span>(s[++right])) &#123;<br>                ++SFreq[s[right]];<br>            &#125;<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">check</span>() <span class="hljs-keyword">and</span> left &lt;= right) &#123;<br>                <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &lt; len) &#123;<br>                    len = right - left + <span class="hljs-number">1</span>;<br>                    begin = left;<br>                &#125;<br>               <span class="hljs-keyword">if</span> (TFreq.<span class="hljs-built_in">count</span>(s[left])) &#123;<br>                    --SFreq[s[left]];<br>                &#125;<br>                ++left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> begin *** <span class="hljs-number">-1</span> ? <span class="hljs-built_in">string</span>() : s.<span class="hljs-built_in">substr</span>(begin, len);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>优化代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; SFreq, TFreq;<br>        <span class="hljs-type">int</span> slen = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">size</span>(), tlen = (<span class="hljs-type">int</span>)t.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (slen *** <span class="hljs-number">0</span> || tlen *** <span class="hljs-number">0</span> || slen &lt; tlen) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c : t) &#123;<br>            ++TFreq[c];<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> distant = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> len = slen + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// [left, right)</span><br>        <span class="hljs-keyword">while</span> (right &lt; slen) &#123;<br>            <span class="hljs-keyword">if</span> (TFreq[s[right]] *** <span class="hljs-number">0</span>) &#123;<br>                ++right;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (SFreq[s[right]] &lt; TFreq[s[right]]) &#123;<br>                distant++;<br>            &#125;<br>            <br>            SFreq[s[right]]++;<br>            right++;<br>            <br>            <span class="hljs-keyword">while</span> (distant *** tlen) &#123;<br>                <span class="hljs-keyword">if</span> (right - left &lt; len) &#123;<br>                    len = right - left;<br>                    begin = left;<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span> (TFreq[s[left]] *** <span class="hljs-number">0</span>) &#123;<br>                    ++left;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span> (SFreq[s[left]] *** TFreq[s[left]]) &#123;<br>                    distant--;<br>                &#125;<br>                <br>                SFreq[s[left]]--;<br>                left++;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> len *** slen + <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;&quot;</span> : s.<span class="hljs-built_in">substr</span>(begin, len);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="k-个不同整数的子数组hard"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/">992.
K 个不同整数的子数组「Hard」</a></h3>
<p>给定一个正整数数组 <code>A</code>，如果 <code>A</code>
的某个子数组中不同整数的个数恰好为 <code>K</code>，则称 <code>A</code>
的这个连续、不一定独立的子数组为<em>好子数组</em>。</p>
<p>( 例如，<code>[1,2,3,1,2]</code> 中有 <code>3</code>
个不同的整数：<code>1</code>，<code>2</code>，以及 <code>3</code>。)</p>
<p>返回 <code>A</code> 中<em>好子数组</em>的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：A = [1,2,1,2,3], K = 2<br>输出：7<br>解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：A = [1,2,1,3,4], K = 3<br>输出：3<br>解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= A.length &lt;= 20000</code></li>
<li><code>1 &lt;= A[i] &lt;= A.length</code></li>
<li><code>1 &lt;= K &lt;= A.length</code></li>
</ul>
<blockquote>
<p>算法分析：</p>
<p>滑动窗口的<strong><em>思维定势</em></strong>：</p>
<p>我们一般考虑滑动窗口的时候都是每轮循环使 <span class="math inline">\(right\)</span> 向右移动一位，然后固定 <span class="math inline">\(right\)</span>，然后「收缩」<span class="math inline">\(left\)</span>，但是考虑本题，<span class="math inline">\(right\)</span> 指针其实并不固定：</p>
<p>对于一个固定的左边界来说，满足「恰好存在 <code>K</code>
个不同整数的子区间」的右边界 <strong>不唯一</strong>，且形成区间。</p>
<p>示例：左边界固定的时候，恰好存在 <span class="math inline">\(2\)</span> 个不同整数的子区间为
<code>[1, 2], [1, 2, 1], [1, 2, 1, 2]</code>，总数为 <span class="math inline">\(3\)</span>。</p>
<p><img src="https://pic.leetcode-cn.com/1612775858-VWbhYR-image.png" srcset="/img/loading.gif" lazyload alt="picture" style="zoom:67%;"></p>
<p>但是本题是<strong><em>「恰好存在 <code>K</code>
个不同整数的子区间」</em></strong>，所以我们需要找到左边界固定的情况下，满足「恰好存在
<code>K</code> 个不同整数的子区间」最小右边界和最大右边界。</p>
<p>对比以前我们做过的，使用「滑动窗口」解决的问题的问法基本都会出现「最小」、「最大」这样的字眼。那么这题如何解决呢？对此，我们可以进行一定的转换：</p>
<p>把「<strong>恰好</strong>」改成「<strong>最多</strong>」就可以使用双指针一前一后交替向右的方法完成，这是因为
<strong>对于每一个确定的左边界，最多包含</strong> <span class="math inline">\(K\)</span>
<strong>种不同整数的右边界是唯一确定的</strong>，并且在左边界向右移动的过程中，右边界或者在原来的地方，或者在原来地方的右边。</p>
<p>而「最多存在 <span class="math inline">\(K\)</span>
个不同整数的子区间的个数」与「恰好存在 <code>K</code>
个不同整数的子区间的个数」的差恰好等于「最多存在 <span class="math inline">\(K-1\)</span> 个不同整数的子区间的个数」。</p>
<figure>
<img src="https://pic.leetcode-cn.com/1612776085-sZFGqE-image.png" srcset="/img/loading.gif" lazyload alt="picture">
<figcaption aria-hidden="true">picture</figcaption>
</figure>
<p>因此原问题就可以转换为求解「最多存在 <span class="math inline">\(K\)</span> 个不同整数的子区间的个数」和 「最多存在
<span class="math inline">\(K-1\)</span>
个不同整数的子区间的个数」。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 主求解函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subarraysWithKDistinct</span><span class="hljs-params">(A []<span class="hljs-type">int</span>, K <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> atMostKDistinct(A, K) - atMostKDistinct(A, K - <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">atMostKDistinct</span><span class="hljs-params">(A []<span class="hljs-type">int</span>, K <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(A)<br>    <span class="hljs-comment">// count 代表 [left, right) 里不同整数的个数</span><br>    res, count, left, right := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    freq := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment">// [left, right) 包含不同整数的个数小于等于 K</span><br>    <span class="hljs-keyword">for</span> right &lt; n &#123;<br>        <span class="hljs-keyword">if</span> freq[A[right]] *** <span class="hljs-number">0</span> &#123;<br>            count++<br>        &#125;<br>        <br>        freq[A[right]]++<br>        right++<br>        <br>        <span class="hljs-keyword">for</span> count &gt; K &#123;<br>            freq[A[left]]--<br>            <span class="hljs-keyword">if</span> freq[A[left]] *** <span class="hljs-number">0</span> &#123;<br>                count--<br>            &#125;<br>            left++<br>        &#125;<br>        <br>        <span class="hljs-comment">// [left, right) 区间的长度就是对结果的贡献</span><br>        res += right - left<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="k-连续位的最小翻转次数hard"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-number-of-k-consecutive-bit-flips/">995.
K 连续位的最小翻转次数「Hard」</a></h3>
<p>在仅包含 <code>0</code> 和 <code>1</code> 的数组 <code>A</code>
中，一次 <code>K</code> 位翻转包括选择一个长度为 <code>K</code>
的（连续）子数组，同时将子数组中的每个 <code>0</code> 更改为
<code>1</code>，而每个 <code>1</code> 更改为 <code>0</code>。</p>
<p>返回所需的 <code>K</code> 位翻转的最小次数，以便数组没有值为
<code>0</code> 的元素。如果不可能，返回 <code>-1</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：A = [0,1,0], K = 1<br>输出：2<br>解释：先翻转 A[0]，然后翻转 A[2]。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：A = [0,0,0,1,0,1,1,0], K = 3<br>输出：3<br>解释：<br>翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]<br>翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]<br>翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol type="1">
<li><code>1 &lt;= A.length &lt;= 30000</code></li>
<li><code>1 &lt;= K &lt;= A.length</code></li>
</ol>
<blockquote>
<p>算法分析：</p>
<p>*****方法一：差分数组*****</p>
<p>由于对同一个子数组执行两次翻转操作不会改变该子数组，所以对每个长度为
<span class="math inline">\(K\)</span>
的子数组，应至多执行一次翻转操作。</p>
<p>对于若干个 <span class="math inline">\(K\)</span>
位翻转操作，改变先后顺序并不影响最终翻转的结果。不妨从 <span class="math inline">\(A[0]\)</span> 开始考虑，若 <span class="math inline">\(A[0]=0\)</span>，则必定要翻转从位置 <span class="math inline">\(0\)</span> 开始的子数组；若 <span class="math inline">\(A[0]=1\)</span>，则不翻转从位置 <span class="math inline">\(0\)</span> 开始的子数组。</p>
<p>按照这一策略，我们从左到右地执行这些翻转操作。由于翻转操作是唯一的，若最终数组元素均为
<span class="math inline">\(1\)</span>，则执行的翻转次数就是最小的。</p>
<p>若直接模拟上述过程，复杂度将会是 <span class="math inline">\(O(NK)\)</span> 的。考虑优化问题：</p>
<p>考虑不去翻转数字，而是统计每个数字需要翻转的次数。对于一次翻转操作，相当于把子数组中所有数字的翻转次数加
<span class="math inline">\(1\)</span>.</p>
<p>这启发我们用<strong>差分数组</strong>的思想来计算当前数字需要翻转的次数。我们可以维护一个差分数组
<span class="math inline">\(diff\)</span>，其中 <span class="math inline">\(diff[i]\)</span> 表示两个相邻元素 <span class="math inline">\(A[i-1]\)</span> 和 <span class="math inline">\(A[i]\)</span> 的翻转次数的差，对于区间 <span class="math inline">\([l,r]\)</span>，将其元素全部加 <span class="math inline">\(1\)</span>，只会影响到 <span class="math inline">\(l\)</span> 和 <span class="math inline">\(r+1\)</span> 处的差分值，故
<code>diff[l]++ &amp;&amp; diff[r + 1]--</code>.</p>
<p>通过累加差分数组可以得到当前位置需要翻转的次数，我们用变量 <span class="math inline">\(revCnt\)</span> 来表示这一累加值。</p>
<p>遍历到 <span class="math inline">\(A[i]\)</span> 时，<strong><em>若
<span class="math inline">\(A[i]+revCnt\)</span>
是偶数，则说明当前元素的实际值为 <span class="math inline">\(0\)</span>，需要翻转区间 <span class="math inline">\([i,i+K-1]\)</span></em></strong> ，我们可以直接将
<span class="math inline">\(revCnt\)</span> 增加 <span class="math inline">\(1\)</span>，<span class="math inline">\(diff[i+K]\)</span> 减少 <span class="math inline">\(1\)</span>.</p>
<p>注意到若 <span class="math inline">\(i+K&gt;n\)</span>
则无法执行翻转操作，此时应返回 <span class="math inline">\(-1\)</span>.</p>
<p>*****方法二：滑动窗口*****</p>
<p>我们考虑能否将空间复杂度简化为 <span class="math inline">\(O(1)\)</span> ?</p>
<p>回顾方法一的代码，当遍历到位置 <span class="math inline">\(i\)</span>
时，若能知道位置 <span class="math inline">\(i-K\)</span>
上发生了翻转操作，便可以直接修改 <span class="math inline">\(revCnt\)</span> 从而去掉 <span class="math inline">\(diff\)</span> 数组。</p>
<p>注意到 <span class="math inline">\(0≤A[i]≤1\)</span>，我们可以<em><strong>用 <span class="math inline">\(A[i]\)</span>
范围</strong>之外<strong>的数来表达「是否翻转过」的含义</strong></em>。</p>
<p>具体来说，若要翻转从位置 <span class="math inline">\(i\)</span>
开始的子数组，可以将 <span class="math inline">\(A[i]\)</span> 加 <span class="math inline">\(2\)</span>，这样当遍历到位置 <span class="math inline">\(i&#39;\)</span> 时，若有 <span class="math inline">\(A[i&#39;-K]&gt;1\)</span>，则说明在位置 <span class="math inline">\(i&#39;-K\)</span> 上发生了翻转操作。</p>
</blockquote>
<p>方法一：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minKBitFlips</span><span class="hljs-params">(A []<span class="hljs-type">int</span>, K <span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    n := <span class="hljs-built_in">len</span>(A)<br>    diff := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    revCnt := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> A &#123;<br>        revCnt += diff[i]<br>        <span class="hljs-keyword">if</span> (v + revCnt) % <span class="hljs-number">2</span> *** <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> i + K &gt; n &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>            &#125;<br>            ans++<br>            revCnt++<br>            diff[i + K]--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于模 <span class="math inline">\(2\)</span>
意义下的加减法与异或等价，我们也可以用异或改写上面的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minKBitFlips</span><span class="hljs-params">(A []<span class="hljs-type">int</span>, K <span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    n := <span class="hljs-built_in">len</span>(A)<br>    diff := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    revCnt := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> A &#123;<br>        revCnt ^= diff[i]<br>        <span class="hljs-keyword">if</span> v *** revCnt &#123; <span class="hljs-comment">// v ^ revCnt *** 0</span><br>            <span class="hljs-keyword">if</span> i + K &gt; n &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>            &#125;<br>            ans++<br>            revCnt ^= <span class="hljs-number">1</span><br>            diff[i + K] ^= <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minKBitFlips</span><span class="hljs-params">(A []<span class="hljs-type">int</span>, K <span class="hljs-type">int</span>)</span></span> (ans <span class="hljs-type">int</span>) &#123;<br>    n := <span class="hljs-built_in">len</span>(A)<br>    revCnt := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> A &#123;<br>        <span class="hljs-keyword">if</span> i &gt;= K &amp;&amp; A[i - K] &gt; <span class="hljs-number">1</span> &#123;<br>            revCnt ^= <span class="hljs-number">1</span><br>            A[i - K] -= <span class="hljs-number">2</span> <span class="hljs-comment">// 复原数组元素，若允许修改数组 A，则可以省略</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> v *** revCnt &#123;<br>            <span class="hljs-keyword">if</span> i + K &gt; n &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>            &#125;<br>            ans++<br>            revCnt ^= <span class="hljs-number">1</span><br>            A[i] += <span class="hljs-number">2</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="存在重复元素-iiimedium"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contains-duplicate-iii/">220.
存在重复元素 III「Medium」</a></h3>
<p>给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和
<code>t</code> 。请你判断是否存在 <strong>两个不同下标</strong>
<code>i</code> 和 <code>j</code>，使得
<code>abs(nums[i] - nums[j]) &lt;= t</code> ，同时又满足
<code>abs(i - j) &lt;= k</code>.</p>
<p>如果存在则返回 <code>true</code>，不存在返回 <code>false</code>.</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [1,2,3,1], k = 3, t = 0<br>输出：true<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [1,0,1,1], k = 1, t = 2<br>输出：true<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<p><strong><em>方法一：滑动窗口 &amp; 有序集合</em></strong></p>
<p>根据题意，对于任意一个位置 <span class="math inline">\(i\)</span> (
假设其值为 <span class="math inline">\(u\)</span>
)，我们其实是希望在下标范围为 <span class="math inline">\([max(0,~i-k),i]\)</span> 内找到值范围在 <span class="math inline">\([u-t,u+t]\)</span> 的数.</p>
<p>因此我们可以使用一个「有序集合」去维护长度为 <span class="math inline">\(k\)</span> 的滑动窗口内的数.</p>
<p>每次都在「有序集合」中应用「二分查找」，找到「小于等于 <span class="math inline">\(u\)</span> 的最大值」和「大于等于 <span class="math inline">\(u\)</span> 的最小值」，即「有序集合」中的最接近
<span class="math inline">\(u\)</span> 的数。然后判断两值是否落在 <span class="math inline">\([u-t,u+t]\)</span> 范围内.</p>
<p>由于我们希望对「有序集合」应用「二分」，找到最接近 <span class="math inline">\(u\)</span> 的数，因此我们需要使用 <span class="math inline">\(TreeSet\)</span>
数据结构（基于红黑树，因此查找和插入都具有折半的效率），并且由于 <span class="math inline">\(nums\)</span> 中的数较大，会存在 <span class="math inline">\(int\)</span> 溢出问题，我们需要使用 <span class="math inline">\(long\)</span> 来存储.</p>
<ul>
<li>时间复杂度： <span class="math inline">\(TreeSet\)</span>
基于红黑树，查找和插入都是 <span class="math inline">\(O(\log
k)\)</span> 复杂度。整体复杂度为 <span class="math inline">\(O(n\log
k)\)</span>.</li>
<li>空间复杂度：<span class="math inline">\(O(k)\)</span>.</li>
</ul>
<p><strong><em>方法二：桶排序</em></strong></p>
<p>上述解法无法做到线性的原因是：我们需要在大小为 <span class="math inline">\(k\)</span> 的滑动窗口所在的「有序集合」中找到与
<span class="math inline">\(u\)</span> 接近的数.</p>
<p>如果我们能够将 <span class="math inline">\(k\)</span> 个数字分到
<span class="math inline">\(k\)</span> 个桶的话，那么我们就能 <span class="math inline">\(O(1)\)</span> 的复杂度确定是否有 <span class="math inline">\([u-t,u+t]\)</span> 的数字 ( 检查目标桶是否有元素
).</p>
<p>具体的做法为：令桶的大小为 <span class="math inline">\(size =
t+1\)</span>，根据 <span class="math inline">\(u\)</span>
计算所在桶编号：</p>
<ul>
<li>如果已经存在该桶，说明前面已有 <span class="math inline">\([u-t,u+t]\)</span> 的数字，返回 <span class="math inline">\(true\)</span>.</li>
<li>如果不存在该桶，则检查相邻两个桶的元素是有 <span class="math inline">\([u-t,u+t]\)</span> 的数字，如有返回 <span class="math inline">\(true\)</span>.</li>
<li>建立目标桶，并删除下标范围不在 <span class="math inline">\([max(0,~i-k),i]\)</span> 内的桶</li>
</ul>
</blockquote>
<p>方法一：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>        set&lt;<span class="hljs-type">long</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">auto</span> lb = st.<span class="hljs-built_in">lower_bound</span>((<span class="hljs-type">long</span>)nums[i] - t);<br>            <span class="hljs-keyword">if</span> (lb != st.<span class="hljs-built_in">end</span>() <span class="hljs-keyword">and</span> *lb &lt;= (<span class="hljs-type">long</span>)nums[i] + t) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            st.<span class="hljs-built_in">insert</span>(nums[i]);<br>            <span class="hljs-keyword">if</span> (i &gt;= k) &#123;<br>                st.<span class="hljs-built_in">erase</span>(nums[i - k]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">long</span> size;<br>  <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(vector &lt;<span class="hljs-type">int</span>&gt; &amp; nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        map&lt;<span class="hljs-type">long</span>, <span class="hljs-type">long</span>&gt; m;<br>        size = t + <span class="hljs-number">1L</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-type">long</span> u = nums[i] * <span class="hljs-number">1L</span>;<br>            <span class="hljs-type">long</span> idx = <span class="hljs-built_in">getIdx</span>(u);<br>            <span class="hljs-comment">// 目标桶已存在（桶不为空），说明前面已有 [u - t, u + t] 范围的数字</span><br>            <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">find</span>(idx) != m.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 检查相邻的桶</span><br>            <span class="hljs-type">long</span> l = idx - <span class="hljs-number">1</span>, r = idx + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">find</span>(l) != m.<span class="hljs-built_in">end</span>() &amp;&amp; <span class="hljs-built_in">abs</span>(u - m[l]) &lt;= t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">find</span>(r) != m.<span class="hljs-built_in">end</span>() &amp;&amp; <span class="hljs-built_in">abs</span>(u - m[r]) &lt;= t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 建立目标桶</span><br>            m.<span class="hljs-built_in">insert</span>(&#123;idx, u&#125;);<br>            <span class="hljs-comment">// 移除下标范围不在 [max(0, i - k), i) 内的桶</span><br>            <span class="hljs-keyword">if</span> (i &gt;= k) m.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">getIdx</span>(nums[i - k]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">getIdx</span><span class="hljs-params">(<span class="hljs-type">long</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> u &gt;= <span class="hljs-number">0</span> ? u / size : (u + <span class="hljs-number">1</span>) / size - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<hr>
<h1 id="chapter2-dynamic-programming">Chapter2 Dynamic Programming</h1>
<h3 id="最长回文子串medium"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5.
最长回文子串「Medium」</a></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">optimize</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; dp, string&amp; s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        dp[i][i] = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; len; j++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; j; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] *** s[j]) &#123;<br>                <span class="hljs-keyword">if</span> (j - i &lt; <span class="hljs-number">3</span>) dp[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="编辑距离hard"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/">72.
编辑距离「Hard」</a></h3>
<p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将
<code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;<br>输出：3<br>解释：<br>horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)<br>rorse -&gt; rose (删除 &#x27;r&#x27;)<br>rose -&gt; ros (删除 &#x27;e&#x27;)<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;<br>输出：5<br>解释：<br>intention -&gt; inention (删除 &#x27;t&#x27;)<br>inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)<br>enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)<br>exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)<br>exection -&gt; execution (插入 &#x27;u&#x27;)<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<ol type="1">
<li><p>状态：<code>dp[i][j]</code> 表示 <code>word1</code> 的前
<code>i</code> 个字母和 <code>word2</code> 的前 <code>j</code>
个字母之间的编辑距离。</p></li>
<li><p>状态转移方程：</p>
<ul>
<li>当
<strong><em><code>word1[i - 1] *** word2[j - 1]</code></em></strong>
时，不需要转换，编辑距离为
<strong><em><code>dp[i] [j] = dp[i - 1] [j - 1]</code></em></strong>.</li>
<li>当
<strong><em><code>word1[i - 1] != word2[j - 1]</code></em></strong>
时，分三种情况讨论：
<ul>
<li>插入一个字符，<strong><em><code>dp[i] [j - 1]</code></em></strong>：为
<code>A</code> 的前 <code>i</code> 个字符和 <code>B</code> 的前
<code>j - 1</code> 个字符编辑距离的子问题。即对于 <code>B</code> 的第
<code>j</code> 个字符，我们在 <code>A</code>
的末尾添加了一个相同的字符</li>
<li>删除一个字符，<strong><em><code>dp[i - 1] [j]</code></em></strong>：为
<code>A</code> 的前 <code>i - 1</code> 个字符和 <code>B</code> 的前
<code>j</code> 个字符编辑距离的子问题。即对于 <code>A</code> 的第
<code>i</code> 个字符，我们在 <code>B</code>
的末尾添加了一个相同的字符</li>
<li>替换一个字符，<strong><em><code>dp[i - 1] [j - 1]</code></em></strong>：为
<code>A</code> 前 <code>i - 1</code> 个字符和 <code>B</code> 的前
<code>j - 1</code> 个字符编辑距离的子问题。即对于 <code>B</code> 的第
<code>j</code> 个字符，我们修改 <code>A</code> 的第 <code>i</code>
个字符使它们相同</li>
</ul></li>
<li>对于这三种情况，我们去其中编辑距离的最小值再加一，即
<strong><em><code>dp[i][j] = min(dp[i - 1] [j - 1], dp[i - 1] [j], dp[i] [j - 1]) + 1</code></em></strong>.</li>
</ul></li>
<li><p>边界条件：</p>
<p><img src="/Users/wanglei/Library/Application Support/typora-user-images/image-20210206201135253.png" srcset="/img/loading.gif" lazyload alt="image-20210206201135253" style="zoom:50%;"></p></li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        <span class="hljs-comment">// dp[i][j] 表示 word1 的前 i 个字母和 word2 的前 j 个字母之间的编辑距离。</span><br>        <span class="hljs-type">int</span> len1 = (<span class="hljs-type">int</span>)word1.<span class="hljs-built_in">length</span>(), len2 = (<span class="hljs-type">int</span>)word2.<span class="hljs-built_in">length</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(len1 + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(len2 + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len1 + <span class="hljs-number">1</span>; i++) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len2 + <span class="hljs-number">1</span>; j++) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len1 + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; len2 + <span class="hljs-number">1</span>; j++) &#123;<br>                <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] *** word2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示删除操作，dp[i][j-1] 表示插入操作</span><br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[len1][len2];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="比特位计数medium"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/counting-bits/">338.
比特位计数「Medium」</a></h3>
<p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤
num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1
的数目并将它们作为数组返回。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">输入: <span class="hljs-number">2</span><br>输出: [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入: 5<br>输出: [0,1,1,2,1,2]<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<ol type="1">
<li>状态：<code>bit[i]</code> 表示 <code>i</code> 的「比特数」</li>
<li>状态转移方程：对于正整数 <span class="math inline">\(x\)</span>，如果可以知道最大的正整数 <span class="math inline">\(y\)</span> 使得 <span class="math inline">\(y≤x\)</span> 且 <span class="math inline">\(y\)</span> 是 <span class="math inline">\(2\)</span> 的整数次幂，则 <span class="math inline">\(y\)</span> 的二进制表示中只有最高位是 <span class="math inline">\(1\)</span>，其余都是 <span class="math inline">\(0\)</span>，此时称 <span class="math inline">\(y\)</span> 为 <span class="math inline">\(x\)</span> 的「最高有效位」。也就是说
<code>bit[x] = bit[y - x] + 1</code></li>
<li>边界条件：判断「最高有效位」看上题，<code>(i &amp; (i - 1)) *** 0</code>.</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">bits</span><span class="hljs-params">(num + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> highBit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;<br>            <span class="hljs-keyword">if</span> ((i &amp; (i - <span class="hljs-number">1</span>)) *** <span class="hljs-number">0</span>) &#123;<br>                highBit = i;<br>            &#125;<br>            bits[i] = bits[i - highBit] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bits;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="分割回文串-iihard"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">132.
分割回文串 II「Hard」</a></h3>
<p>给你一个字符串 <code>s</code>，请你将 <code>s</code>
分割成一些子串，使每个子串都是回文。</p>
<p>返回符合要求的 <strong>最少分割次数</strong></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;aab&quot;<br>输出：1<br>解释：只需一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<p>Step1：定义状态</p>
<p>设 <span class="math inline">\(f[i]\)</span> 表示字符串的前缀 <span class="math inline">\(s[0...i]\)</span>
的<strong>最少</strong>分割次数。</p>
<p>Step2：状态转移方程</p>
<p>要想得出 <span class="math inline">\(f[i]\)</span>
的值，我们可以考虑枚举 <span class="math inline">\(s[0...i]\)</span>
分割出的最后一个回文串，这样我们就可以写出状态转移方程：</p>
<p><span class="math inline">\(f[i]=min_{0≤j&lt;i}(f[j])+1\)</span>，其中 <span class="math inline">\(s[j+1,i]\)</span> 是一个回文串.</p>
<p>即我们枚举最后一个回文串的起始位置 <span class="math inline">\(j+1\)</span>，保证 <span class="math inline">\(s[j+1,i]\)</span> 是一个回文串，那么 <span class="math inline">\(f[i]\)</span> 就可以从 <span class="math inline">\(f[j]\)</span> 转移而来，附加 <span class="math inline">\(1\)</span> 次额外的分割次数。</p>
<p>Step3：边界情况</p>
<p>注意到上面的状态转移方程中，我们还少考虑了一种情况，即 <span class="math inline">\(s[0...i]\)</span>
本身就是一个回文串。此时其不需要进行任何分割，即：<span class="math inline">\(f[i]=0\)</span>.</p>
<p>那么我们如何知道 <span class="math inline">\(s[j+1,i]\)</span> or
<span class="math inline">\(s[0...i]\)</span>
是否为回文串呢？我们可以使用 <span class="math inline">\(dp\)</span>
的预处理解决.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">optimize</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; dp, string&amp; s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>            dp[i][i] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; len; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; j; i++) &#123;<br>                <span class="hljs-keyword">if</span> (s[i] *** s[j]) &#123;<br>                    <span class="hljs-keyword">if</span> (j - i &lt; <span class="hljs-number">3</span>) dp[i][j] = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">else</span> dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> dp[i][j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCut</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n));<br>        <span class="hljs-built_in">optimize</span>(dp, s);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n, n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (dp[<span class="hljs-number">0</span>][i]) f[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                    <span class="hljs-keyword">if</span> (dp[j + <span class="hljs-number">1</span>][i]) &#123;<br>                        f[i] = <span class="hljs-built_in">min</span>(f[i], f[j] + <span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f.<span class="hljs-built_in">back</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="不同的子序列hard"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/distinct-subsequences/">115.
不同的子序列「Hard」</a></h3>
<p>给定一个字符串 <code>s</code> 和一个字符串 <code>t</code> ，计算在
<code>s</code> 的子序列中 <code>t</code> 出现的个数。</p>
<p>字符串的一个 子序列
是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串.</p>
<p>( 例如，<code>"ACE"</code> 是 <code>"ABCDE"</code> 的一个子序列，而
<code>"AEC"</code> 不是 )</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;<br>输出：3<br>解释：<br>如下图所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。<br>(上箭头符号 <span class="hljs-built_in">^</span> 表示选取的字母)<br>rabbbit<br>^^^<span class="hljs-built_in">^</span> ^^<br>rabbbit<br>^^ ^^^<span class="hljs-built_in">^</span><br>rabbbit<br>^^^ ^^^<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;babgbag&quot;, t = &quot;bag&quot;<br>输出：5<br>解释：<br>如下图所示, 有 5 种可以从 s 中得到 &quot;bag&quot; 的方案。 <br>(上箭头符号 <span class="hljs-built_in">^</span> 表示选取的字母)<br>babgbag<br>^^ <span class="hljs-built_in">^</span><br>babgbag<br>^^    <span class="hljs-built_in">^</span><br>babgbag<br><span class="hljs-built_in">^</span>    ^^<br>babgbag<br>  <span class="hljs-built_in">^</span>  ^^<br>babgbag<br>    ^^^<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<p>Preface：</p>
<p>假设字符串 <code>s</code> 和 <code>t</code> 的长度分别为
<code>m</code> 和 <code>n</code>，只有当 <code>m ≥ n</code>
的时候才有意义，当 <code>m &lt; n</code> 时返回 <code>0</code>.</p>
<ol type="1">
<li><p>定义状态</p>
<p>创建二维数组 <code>dp</code>，其中 <code>dp[i][j]</code> 表示
<code>s[i:]</code> 的子序列中 <code>t[j:]</code> 出现的个数.</p></li>
<li><p>状态转移方程</p>
<p>当 <code>i &lt; m</code> 且 <code>j &lt; n</code> 时， 我们考虑
<code>dp[i][j]</code> 的计算.</p>
<ul>
<li><p>当 <code>s[i] = t[j]</code> 时，<code>dp[i][j]</code>
由两部分组成：</p>
<ul>
<li><p>如果 <code>s[i]</code> 和 <code>t[j]</code> 匹配，则考虑
<code>t[j + 1:]</code> 作为 <code>s[i + 1:]</code> 的子序列，</p>
<p>子序列数为 <code>dp[i + 1][j + 1]</code>.</p></li>
<li><p>如果 <code>s[i]</code> 不和 <code>t[j]</code> 匹配，则考虑
<code>t[j:]</code> 作为 <code>s[i + 1:]</code> 的子序列，</p>
<p>子序列数为 <code>dp[i + 1][j]</code>.</p></li>
</ul>
<p>因此当 <code>s[i] = t[j]</code> 时，有
<code>dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j]</code>.</p></li>
<li><p>当 <code>s[i] ≠ t[j]</code> 时，<code>s[i]</code> 不和
<code>t[j]</code> 匹配，因此只考虑 <code>t[j:]</code> 作为
<code>s[i + 1:]</code> 的子序列，</p>
<p>子序列数为 <code>dp[i + 1][j]</code>.</p>
<p>因此当 <code>s[i] ≠ t[j]</code>
时，<code>dp[i][j] = dp[i + 1][j]</code>.</p></li>
</ul>
<p>最终计算得到 <code>dp[0][0]</code> 即为在 <code>s</code> 的子序列中
<code>t</code> 出现的个数.</p></li>
<li><p>边界情况</p>
<ul>
<li>当 <code>j = n</code> 时，<code>t[j:]</code>
为空字符串，由于空字符串是任何字符串的子序列，因此对任意
<code>0 ≤ i ≤ m</code>，有 <code>dp[i][n] = 1</code>.</li>
<li>当 <code>i = m</code> 且 <code>j &lt; n</code>
时，<code>s[i:]</code> 为空字符串，<code>t[j:]</code>
为非空字符串，由于非空字符串不是空字符串的子序列，因此对任意
<code>0 ≤ j &lt; n</code>，有 <code>dp[m][j] = 0</code>.</li>
</ul></li>
</ol>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(s, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(t)<br>    <span class="hljs-keyword">if</span> m &lt; n &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>        dp[i][n] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>            <span class="hljs-keyword">if</span> s[i] *** t[j] &#123;<br>                dp[i][j] = dp[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + dp[i + <span class="hljs-number">1</span>][j]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = dp[i + <span class="hljs-number">1</span>][j]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="最大子序和easy"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">53.
最大子序和「Easy」</a></h3>
<p>给定一个整数数组 <code>nums</code>
，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<ol type="1">
<li><p>定义状态</p>
<p>我们令 <span class="math inline">\(f(i)\)</span> 为以第 <span class="math inline">\(i\)</span>
个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：<span class="math inline">\(max_{0≤i&lt;n}f(i)\)</span>.</p></li>
<li><p>状态转移方程</p>
<p><span class="math inline">\(f(i)=max(f(i-1)+nums[i],nums[i])\)</span>.</p></li>
<li><p>无边界情况</p></li>
</ol>
<p><span class="math inline">\(DP\)</span> 算法优化：</p>
<p>​
每一次的状态只与前一次的状态有关，所以可以利用「滚动数组」思想优化空间，设置一个变量
<span class="math inline">\(pre\)</span> 表示前一个解的值.</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    pre, maxn := <span class="hljs-number">0</span>, nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> nums &#123;<br>        pre = max(pre + v, v)<br>        maxn = max(maxn, pre)<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxn<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="打家劫舍medium"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">198.
打家劫舍「Medium」</a></h3>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你
<strong>不触动警报装置的情况下</strong>
，一夜之内能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<ol type="1">
<li><p>定义状态：</p>
<p>由于当前考虑的房屋有两种选择：「偷」和「不偷」。我们用 <code>0</code>
表示「不偷」，用 <code>1</code> 表示「偷」，即：</p>
<ul>
<li><code>dp[i][0]</code> 表示：考虑区间 <code>[0..i]</code>
，并且下标为 <code>i</code> 的这个房间不偷，能够偷窃到的最高金额；</li>
<li><code>dp[i][1]</code> 表示：考虑区间 <code>[0..i]</code>
，并且下标为 <code>i</code> 的这个房间偷，能够偷窃到的最高金额。</li>
</ul></li>
<li><p>状态转移方程：</p>
<ul>
<li>不偷：<code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][i])</code></li>
<li>偷：<code>dp[i][1] = dp[i - 1][0] + nums[i]</code></li>
</ul></li>
<li><p>边界情况：</p>
<ul>
<li><code>dp[0][0] = 0</code></li>
<li><code>dp[0][1] = nums[0]</code></li>
</ul></li>
</ol>
<p>算法优化：</p>
<p>每层算法只与其上一层的状态有关，所以可以使用「滚动数组」来节省空间.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (len *** <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (len *** <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> norob = <span class="hljs-number">0</span>, rob = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; ++i) &#123;<br>            <span class="hljs-type">int</span> temp = norob;<br>            norob = <span class="hljs-built_in">max</span>(norob, rob);<br>            rob = temp + nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(norob, rob);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="背包问题">0-1 背包问题</h2>
<p>有 <code>n</code> 种物品，物品 <code>i</code> 的体积为 <span class="math inline">\(v_i\)</span> ，价值为 <span class="math inline">\(w_i\)</span>，有一个体积限制 <span class="math inline">\(V\)</span>，<strong>每种物品只有 1
个，只有选或者不选</strong>，而没有选几个的问题，此问题称为 01
背包问题。</p>
<blockquote>
<ol type="1">
<li><p>状态：</p>
<p><code>dp[i][j]</code> := 考虑了 <code>[0..i]</code> 里的物品，占用了
<code>j</code> 空间，所能取得的最大价值.</p></li>
<li><p>状态转移方程：</p>
<p>转移方式有两种，一种是放入，一种是不放入。</p>
<p>如果放，则区间 <code>[0...i-1]</code> 只能占 <code>j - v[i]</code>
空间；</p>
<p>如果不放，则区间 <code>[0...i-1]</code> 的物品还是占了 <code>j</code>
空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] 当前物品不选<br>           dp[i - <span class="hljs-number">1</span>][j - v[i]] + w[i] 当前物品选，j - v[i] 要大于等于 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li>
<li><p>边界情况：</p>
<p>初始化时将所有状态置为 <span class="math inline">\(0\)</span>
即可.</p></li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ZeroOnePack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; weights, vector&lt;<span class="hljs-type">int</span>&gt;&amp; values, <span class="hljs-type">int</span> capacity)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>)weights.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(capacity + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= capacity; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (i *** <span class="hljs-number">0</span>) &#123;<br>                dp[i][j] = j &lt; weights[i] ? <span class="hljs-number">0</span> : values[i];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &lt; weights[i]) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - weights[i]] + values[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">back</span>().<span class="hljs-built_in">back</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="最长有效括号hard"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32.
最长有效括号「Hard」</a></h3>
<p>给你一个只包含 <code>'('</code> 和 <code>')'</code>
的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;(()&quot;<br>输出：2<br>解释：最长有效括号子串是 &quot;()&quot;<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;)()())&quot;<br>输出：4<br>解释：最长有效括号子串是 &quot;()()&quot;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<ol type="1">
<li><p>状态：</p>
<p><code>dp[i]</code> 表示以下标 <code>i</code>
为字符结尾的最长有效字符串的长度.</p></li>
<li><p>状态转移方程：</p>
<ul>
<li><p>以 <code>(</code>
结尾的子字符串不考虑，因为不可能构成合法括号</p></li>
<li><p><code>if s[i] *** ')'</code></p>
<ul>
<li><p><code>s[i - 1] *** '('</code>，也就是字符串形如
<code>“……()”</code>，我们可以推出：<code>dp[i] = dp[i − 2] + 2</code>.</p></li>
<li><p><code>s[i - 1] *** ')'</code>，也就是字符串形如
<code>“.......))”</code>，我们可以推出：</p>
<p><code>if s[i - dp[i - 1] - 1] *** '('</code>，<code>dp[i] = dp[i − 1] + dp[i − dp[i − 1] − 2] + 2</code></p>
<p>因为如果倒数第二个
<code>)</code>是一个有效子字符串的一部分（记为<code>subs</code>），我们此时需要判断
<code>subs</code> 前面一个符号是不是 <code>(</code>
，如果恰好是<code>(</code>，我们就用 <code>subs</code> 的长度(
<code>dp[i - 1]</code> ) 加上 2
去更新<code>dp[i]</code>。除此以外，我们也会把子字符串 <code>subs</code>
前面的有效字符串的长度加上，也就是
<code>dp[i − dp[i − 1] − 2]</code>.</p></li>
</ul></li>
</ul></li>
<li><p>边界情况：</p>
<ul>
<li><code>i - 2</code> 有可能小于零越界了，这种情况下就是只有
<code>()</code> ，前面记为 0 就好了.</li>
<li><code>i - dp[i - 1] - 1</code> 和 <code>i - dp[i - 1] - 2</code>
都可能越界，越界了当成 0 来计算就可以了.</li>
</ul></li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> maxLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.length())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] *** <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] *** <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = (i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + <span class="hljs-number">2</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>] *** <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                    dp[i] = (i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> ? dp[i - dp[i - <span class="hljs-number">1</span>] - <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>) + dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br>            maxLen = <span class="hljs-built_in">fmax</span>(dp[i], maxLen);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="最长公共子序列medium"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143.
最长公共子序列「Medium」</a></h3>
<p>给定两个字符串 <code>text1</code> 和
<code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong>
的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code></p>
<p>一个字符串的 <strong>子序列</strong>
是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>"ace"</code> 是 <code>"abcde"</code> 的子序列，但
<code>"aec"</code> 不是 <code>"abcde"</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong>
是这两个字符串所共同拥有的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; <br>输出：3  <br>解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。<br></code></pre></td></tr></table></figure>
<blockquote>
<p>注：本题过于经典，算法比较简单，不多赘述了.</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1 <span class="hljs-type">string</span>, text2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(text1), <span class="hljs-built_in">len</span>(text2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m + <span class="hljs-number">1</span>)x2<br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> text1[i - <span class="hljs-number">1</span>] *** text2[j - <span class="hljs-number">1</span>] &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])<br>            &#125; <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="解码方法medium"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-ways/">91.
解码方法「Medium」</a></h3>
<p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了
<strong>编码</strong> ：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">&#x27;A&#x27; -&gt; 1<br>&#x27;B&#x27; -&gt; 2<br>...<br>&#x27;Z&#x27; -&gt; 26<br></code></pre></td></tr></table></figure>
<p>要 <strong>解码</strong>
已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>"11106"</code>
可以映射为：</p>
<ul>
<li><code>"AAJF"</code> ，将消息分组为 <code>(1 1 10 6)</code></li>
<li><code>"KJF"</code> ，将消息分组为 <code>(11 10 6)</code></li>
</ul>
<p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>"06"</code>
不能映射为 <code>"F"</code> ，这是由于 <code>"6"</code> 和
<code>"06"</code> 在映射中并不等价。</p>
<p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code>
，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p>
<ul>
<li><code>s</code> 只包含数字，并且可能包含前导零。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;12&quot;<br>输出：2<br>解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：s = &quot;226&quot;<br>输出：3<br>解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<ol type="1">
<li><p>状态：</p>
<p><span class="math inline">\(dp[i]\)</span> 表示字符串的前 <span class="math inline">\(i\)</span> 个字符可能的组合数.</p></li>
<li><p>状态转移方程：</p>
<p>对于当前位 <span class="math inline">\(i≠0\)</span>，则可以对前一项进行转移：<code>dp[i] += dp[i - 1]</code>.</p>
<p>考虑 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(i - 1\)</span>
能否组成合法数字，如果可以的话也可以转移：<code>dp[i] += dp[i - 2]</code>.</p></li>
<li><p>边界情况：</p>
<p>第 <span class="math inline">\(i - 1\)</span> 位的时候要考虑是否字符
<code>'0'</code>，若是，则此项不进行转移；同理，第 <span class="math inline">\(i - 2\)</span> 位的时候亦是如此.</p>
<p>细节点：我们如何判断不合法的字符到最后一定是 <span class="math inline">\(0\)</span> 呢？</p>
<p>若是当前字符为
<code>'0'</code>，我们就不会考虑前一项了，若是前一项与当前项组成的数字也是不合法的，我们也不会做加法，因此迭代下去则会一直是零.</p></li>
<li><p>优化：</p>
<p>使用变量来代替迭代元素</p></li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                dp[i] += dp[i - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> s[i - <span class="hljs-number">2</span>] != <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-built_in">and</span> ((s[i - <span class="hljs-number">2</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span> &lt;= <span class="hljs-number">26</span>)) &#123;<br>                dp[i] += dp[i - <span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// a = dp[i - 2], b = dp[i - 1], c = dp[i]</span><br>        <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, c;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            c = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                c += b;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span> &amp;&amp; s[i - <span class="hljs-number">2</span>] != <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ((s[i - <span class="hljs-number">2</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) &lt;= <span class="hljs-number">26</span>)) &#123;<br>                c += a;<br>            &#125;<br>            <span class="hljs-built_in">tie</span>(a, b) = &#123;b, c&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<hr>
<h1 id="chapter3-binary-search">Chapter3 Binary Search</h1>
<h3 id="搜索旋转排序数组medium"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33.
搜索旋转排序数组「Medium」</a></h3>
<p>整数数组 <code>nums</code> 按升序排列，数组中的值
<strong>互不相同</strong> 。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标
<code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了
<strong>旋转</strong>，</p>
<p>使数组变为
<code>[nums[k], nums[k + 1], ..., nums[n - 1], nums[0], nums[1], ...,nums[k - 1]]</code>（下标
<strong>从 0 开始</strong> 计数）</p>
<p>例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code>
处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数
<code>target</code> ，如果 <code>nums</code> 中存在这个目标值
<code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [4,5,6,7,0,1,2], target = 0<br>输出：4<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [4,5,6,7,0,1,2], target = 3<br>输出：-1<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<p>对于有序数组，可以使用二分查找的方法查找元素。</p>
<p>但是这道题中，数组本身不是有序的，进行旋转后只保证了数组的局部是有序的，这还能进行二分查找吗？答案是可以的。</p>
<p>可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从
<code>6</code> 这个位置分开以后数组变成了 <code>[4, 5, 6]</code> 和
<code>[7, 0, 1, 2]</code> 两个部分，其中左边 <code>[4, 5, 6]</code>
这个部分的数组是有序的，其他也是如此。</p>
<p>这启示我们可以在常规二分查找的时候查看当前 <code>mid</code>
为分割位置分割出来的两个部分 <code>[l, mid]</code> 和
<code>[mid + 1, r]</code>
哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出
<code>target</code> 在不在这个部分：</p>
<ul>
<li>如果 <code>[l, mid - 1]</code> 是有序数组，且 <code>target</code>
的大小满足 <code>[nums[l], nums[mid])</code> 则我们应该将搜索范围缩小至
<code>[l, mid - 1]</code>，否则在 <code>[mid + 1, r]</code>
中寻找。</li>
<li>如果 <code>[mid, r]</code> 是有序数组，且 <code>target</code>
的大小满足 <code>(nums[mid], nums[r]]</code> 则我们应该将搜索范围缩小至
<code>[mid + 1, r]</code>，否则在 <code>[l, mid - 1]</code>
中寻找。</li>
</ul>
<figure>
<img src="https://assets.leetcode-cn.com/solution-static/33/33_fig1.png" srcset="/img/loading.gif" lazyload alt="picture">
<figcaption aria-hidden="true">picture</figcaption>
</figure>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-keyword">if</span> (!numsSize) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (numsSize *** <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] *** target ? <span class="hljs-number">0</span> : <span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = numsSize - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 本题的二分是只在有序数组那一边的范围里找 target</span><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (nums[mid] *** target) <span class="hljs-keyword">return</span> mid;<br>        <br>        <span class="hljs-keyword">if</span> (nums[left] &lt;= nums[mid]) &#123; <span class="hljs-comment">// 左边为升序排序数组</span><br>            <span class="hljs-keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 右边为升序数组</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>变式：</strong> 数组中的值可以重复</p>
<blockquote>
<p>算法分析：</p>
<p>对于数组中有重复元素的情况，二分查找时可能会有
<code>nums[l] = nums[mid] = nums[right]</code> 此时无法判断区间
<code>[left, mid]</code> 和区间 <code>[mid + 1, right]</code>
哪个是有序的。</p>
<p>对于这种情况，我们只能将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target)</span>&#123;<br>    <span class="hljs-keyword">if</span> (!numsSize) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (numsSize *** <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] *** target ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = numsSize - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">if</span> (nums[mid] *** target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (nums[left] *** nums[mid] &amp;&amp; nums[mid] *** nums[right]) &#123;<br>            ++left;<br>            --right;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[left] &lt;= nums[mid]) &#123; <br>            <span class="hljs-keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="寻找旋转排序数组中的最小值medium"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153.
寻找旋转排序数组中的最小值「Medium」</a></h3>
<p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由
<code>1</code> 到 <code>n</code> 次 <strong>旋转</strong>
后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code>
在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到
<code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到
<code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code>
<strong>旋转一次</strong> 的结果为数组
<code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code></p>
<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code>
，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的
<strong>最小元素</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [3,4,5,1,2]<br>输出：1<br>解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<p>一个不包含重复元素的升序数组在经过旋转之后，可以得到下面可视化的折线图：</p>
<figure>
<img src="https://assets.leetcode-cn.com/solution-static/153/1.png" srcset="/img/loading.gif" lazyload alt="picture">
<figcaption aria-hidden="true">picture</figcaption>
</figure>
<p>其中横轴表示数组元素的下标，纵轴表示数组元素的值。图中标出了最小值的位置，是我们需要查找的目标.</p>
<p>我们考虑<strong>数组中的最后一个元素</strong> <span class="math inline">\(x\)</span>：在最小值右侧的元素 (
不包括最后一个元素本身 )，它们的值一定都严格小于 <span class="math inline">\(x\)</span>
而在最小值左侧的元素，它们的值一定都严格大于 <span class="math inline">\(x\)</span>.
因此，我们可以根据这一条性质，通过二分查找的方法找出最小值.</p>
<p>在二分查找的每一步中，左边界为 <span class="math inline">\(low\)</span>，右边界为 <span class="math inline">\(high\)</span>，区间的中点为 <span class="math inline">\(pivot\)</span>，最小值就在该区间内. 我们将中轴元素
<span class="math inline">\(nums[pivot]\)</span> 与右边界元素 <span class="math inline">\(nums[high]\)</span>
进行比较，可能会有以下的三种情况：</p>
<p>第一种情况是 <span class="math inline">\(nums[pivot]&lt;nums[high]\)</span>.
如下图所示，这说明 <span class="math inline">\(nums[pivot]\)</span>
是最小值右侧的元素，因此我们可以忽略二分查找区间的右半部分.</p>
<figure>
<img src="https://assets.leetcode-cn.com/solution-static/153/2.png" srcset="/img/loading.gif" lazyload alt="picture">
<figcaption aria-hidden="true">picture</figcaption>
</figure>
<p>第二种情况是 <span class="math inline">\(nums[pivot]&gt;nums[high]\)</span>.
如下图所示，这说明 <span class="math inline">\(nums[pivot]\)</span>
是最小值左侧的元素，因此我们可以忽略二分查找区间的左半部分.</p>
<figure>
<img src="https://assets.leetcode-cn.com/solution-static/153/3.png" srcset="/img/loading.gif" lazyload alt="picture">
<figcaption aria-hidden="true">picture</figcaption>
</figure>
<p>由于数组不包含重复元素，并且只要当前的区间长度不为 <span class="math inline">\(1\)</span>，<span class="math inline">\(pivot\)</span> 就不会与 <span class="math inline">\(high\)</span> 重合；而如果当前的区间长度为 <span class="math inline">\(1\)</span>
，这说明我们已经可以结束二分查找了。因此不会存在 <span class="math inline">\(nums[pivot]=nums[high]\)</span> 的情况.</p>
<p>当二分查找结束时，我们就得到了最小值所在的位置.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">findMin</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span> &#123;<br>    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> high = numsSize - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>        <span class="hljs-type">int</span> pivot = low + (high - low) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[pivot] &lt; nums[high]) &#123;<br>            high = pivot;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            low = pivot + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[low];<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="chapter5-greedy-algorithm">Chapter5 Greedy Algorithm</h1>
<h3 id="任意子数组和的绝对值的最大值medium"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-absolute-sum-of-any-subarray/">1749.
任意子数组和的绝对值的最大值「Medium」</a></h3>
<p>给你一个整数数组 nums 。一个子数组 <span class="math inline">\([nums_l,
nums_{l+1}\cdots,nums_{r-1},nums_r]\)</span> 的
<strong>和的绝对值</strong> 为 <span class="math inline">\(abs(nums_l+nums_{l+1}+\cdots+nums_{r-1}+nums_r)\)</span>.</p>
<p>请你找出 nums 中 <strong>和的绝对值</strong>
最大的任意子数组（<strong>可能为空</strong>），并返回该
<strong>最大值</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [1,-3,2,3,-4]<br>输出：5<br>解释：子数组 [2,3] 和的绝对值最大，为 abs(2+3) = abs(5) = 5 。<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<p>我们使用一个 <span class="math inline">\(sum\)</span>
数组来保存前缀和，然后<strong><em>使用 <span class="math inline">\(maxn\)</span> 和 <span class="math inline">\(minn\)</span>
来保存遍历过程中前缀和的最大值和最小值</em></strong>，这样相当于丢弃
<span class="math inline">\(maxn\)</span> 或 <span class="math inline">\(minn\)</span> 前面的子数组，可以使得目前的 <span class="math inline">\(sum[i]-maxn\)</span> 可能得到一个较大的负值 (
也许是正值 )，<span class="math inline">\(sum[i] - minn\)</span>
可能得到一个较大的正值 ( 也许是负值 )，然后更新答案变量即可.</p>
<p>值得注意的细节：</p>
<p>前缀和数组 <span class="math inline">\(sum\)</span>
我们申请多一个空间，这样就不需要单独判断 <span class="math inline">\(0\)</span> 这个可能溢出的点了，<strong><em>子区间
<span class="math inline">\([i,j]\)</span> 的和为 <span class="math inline">\(sum[j + 1]-sum[i]\)</span></em></strong>.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAbsoluteSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>) nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            sum[i] = sum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, maxn = <span class="hljs-number">0</span>, minn = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">abs</span>(sum[i] - maxn));<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">abs</span>(sum[i] - minn));<br>            maxn = <span class="hljs-built_in">max</span>(maxn, sum[i]);<br>            minn = <span class="hljs-built_in">min</span>(minn, sum[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="最大数"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-number/">179.
最大数</a></h3>
<p>给定一组非负整数
nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p>
<p><strong>注意：</strong>输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [10,2]<br>输出：&quot;210&quot;<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [3,30,34,5,9]<br>输出：&quot;9534330&quot;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<p>由题意，我们可以知道，开头位越大的数字拼接起来越大，我们可以使用排序来解决此问题.</p>
<p>字符串拼接容易理解，但是题目中给出的是 int
型的数据类型，这样就涉及一个基础的问题了，如何实现整数拼接？</p>
<p>我们可以将两个数的位数分别拉长，再将对方的数加上，最后再比大小.</p>
<p>举个例子： <span class="math inline">\((x=442,~~y=4)~~\Rightarrow~~
(x=4420,~~y=4000)~~\Rightarrow~~(x=4424,~~y=4442)\)</span>.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">largestNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;y) &#123;<br>            <span class="hljs-type">long</span> sx = <span class="hljs-number">10</span>, sy = <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">while</span> (sx &lt;= x) &#123;<br>                sx *= <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (sy &lt;= y) &#123;<br>                sy *= <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> sy * x + y &gt; sx * y + x;<br>        &#125;);<br>        <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] *** <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        &#125;<br>        string ret;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;x : nums) &#123;<br>            ret += <span class="hljs-built_in">to_string</span>(x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<hr>
<h1 id="chapter6-bit-manipulation">Chapter6 Bit Manipulation</h1>
<h3 id="连接连续二进制数字medium"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/concatenation-of-consecutive-binary-numbers/">1680.
连接连续二进制数字「Medium」</a></h3>
<p>给你一个整数 <code>n</code> ，请你将 <code>1</code> 到 <code>n</code>
的二进制表示连接起来，并返回连接结果对应的 <strong>十进制</strong>
数字对 <code>10^9 + 7</code> 取余的结果。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：n = 1<br>输出：1<br>解释：二进制的 &quot;1&quot; 对应着十进制的 1 。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：n = 3<br>输出：27<br>解释：二进制下，1，2 和 3 分别对应 &quot;1&quot; ，&quot;10&quot; 和 &quot;11&quot; 。<br>将它们依次连接，我们得到 &quot;11011&quot; ，对应着十进制的 27 。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：n = 12<br>输出：505379714<br>解释：连接结果为 &quot;1101110010111011110001001101010111100&quot; 。<br>对应的十进制数字为 118505380540 。<br>对 109 + 7 取余后，结果为 505379714 。<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<p>由于我们需要将「十进制转换成二进制」「进行运算」「将结果转换回十进制」这三个步骤，因此我们不妨直接将整个问题在十进制的角度下进行考虑。</p>
<p>假设我们当前处理到了数字 <span class="math inline">\(i\)</span>，并且前面 <span class="math inline">\([1,i-1]\)</span>
的二进制连接起来对应的<strong>十进制数</strong>为 <span class="math inline">\(x\)</span>，那么我们如何将数字 <span class="math inline">\(i\)</span> 进行连接呢？</p>
<p>观察二进制连接的过程，我们可以将这一步运算抽象为两个步骤：</p>
<ol type="1">
<li>将之前 <span class="math inline">\([1,i-1]\)</span>
的二进制数<strong>左移</strong>若干位，这个位数就是 <span class="math inline">\(i\)</span> 的二进制表示的位数；</li>
<li>将 <span class="math inline">\(i\)</span>
通过<strong>加法运算</strong>与左移的结果进行相加。</li>
</ol>
<p>这样，我们可以得到 <span class="math inline">\(x\)</span>
的递推式：<span class="math inline">\(x=x\times2^{len(i)}+i\)</span>.</p>
<p>我们可以知道 <span class="math inline">\(len(i)\)</span> 和 <span class="math inline">\(len(i-1)\)</span> 要么相等，要么相差 <span class="math inline">\(1\)</span>.</p>
<p><span class="math inline">\(x\)</span> 是 <span class="math inline">\((100\cdots)_2\)</span> 的形式存储，而 <span class="math inline">\(x-1\)</span> 是以 <span class="math inline">\((111\cdots)_2\)</span> 的形式存在，所以当一个数
<span class="math inline">\(x\)</span> 为 <span class="math inline">\(2\)</span> 的倍数次的时候，那么它比 <span class="math inline">\(x-1\)</span> 多一位，因此<strong><em>当
<code>x &amp; (x - 1) *** 0</code> 的时候，移位的位数就需要加 <span class="math inline">\(1\)</span></em></strong>，答案就显而易见了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">concatenatedBinary</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> times = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((i &amp; (i - <span class="hljs-number">1</span>)) *** <span class="hljs-number">0</span>) ++times;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; times; ++j) &#123;<br>                ans &lt;&lt;= <span class="hljs-number">1</span>;<br>                ans %= mod;<br>            &#125;<br>            ans += i;<br>            ans %= mod;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="剑指-offer-56---i.-数组中数字出现的次数medium"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指
Offer 56 - I. 数组中数字出现的次数「Medium」</a></h3>
<p>一个整型数组 <code>nums</code>
里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是
<span class="math inline">\(O(n)\)</span>，空间复杂度是 <span class="math inline">\(O(1)\)</span>.</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [4,1,4,6]<br>输出：[1,6] 或 [6,1]<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<p>设两个只出现一次的数字为 <span class="math inline">\(x,y\)</span>，由于 <span class="math inline">\(x≠y\)</span>，则 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 二进制至少有一位不同（即分别为 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(1\)</span> ），根据此位可以将 <span class="math inline">\(nums\)</span> 拆分为分别包含 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 的两个子数组。</p>
<p>易知两子数组都满足
「除一个数字之外，其他数字都出现了两次」。因此，仿照以上简化问题的思路，分别对两子数组遍历执行异或操作，即可得到两个只出现一次的数字
<span class="math inline">\(x,y\)</span>.</p>
<p>算法流程：</p>
<ol type="1">
<li><p>遍历 <span class="math inline">\(nums\)</span> 执行异或：</p>
<ul>
<li>设整型数组 <span class="math inline">\(nums=[a,a,b,b\cdots,x,y]\)</span>，对 <span class="math inline">\(nums\)</span> 中所有数字进行异或，得到的结果为
<span class="math inline">\(x\bigoplus y\)</span>.</li>
</ul></li>
<li><p>循环左移计算 m:</p>
<ul>
<li><p>根据异或运算定义，若整数 <span class="math inline">\(x\bigoplus
y\)</span> 某二进制位为 <span class="math inline">\(1\)</span>，则 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 的此二进制位一定不同。换言之，找到
<span class="math inline">\(x\bigoplus y\)</span> 某位为 <span class="math inline">\(1\)</span> 的二进制位，即可将数组 <span class="math inline">\(nums\)</span>
拆分为上述的两个子数组。根据与运算特点，可知对于任意整数 <span class="math inline">\(a\)</span> 有：</p>
<ul>
<li>若 <span class="math inline">\(a\)</span> &amp; <span class="math inline">\(0001=1\)</span>，则 <span class="math inline">\(a\)</span> 的第一位为 <span class="math inline">\(1\)</span> ；</li>
<li>若 <span class="math inline">\(a\)</span> &amp; <span class="math inline">\(0010=1\)</span>，则 <span class="math inline">\(a\)</span> 的第二位为 <span class="math inline">\(1\)</span> ；</li>
<li>以此类推...</li>
</ul></li>
<li><p>因此，初始化一个辅助变量 <span class="math inline">\(m=1\)</span>，通过与运算从右向左循环判断，可
<strong>获取整数</strong> <span class="math inline">\(x\bigoplus
y\)</span> <strong>首位</strong> <span class="math inline">\(1\)</span>，记录于 <span class="math inline">\(m\)</span> 中，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(z &amp; m *** <span class="hljs-number">0</span>) <span class="hljs-comment">// m 循环左移一位，直到 z &amp; m ！= 0</span><br>    m &lt;&lt;= <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>拆分</strong> <span class="math inline">\(nums\)</span>
<strong>为两个子数组</strong>；</p></li>
<li><p><strong>分别遍历两个子数组执行异或</strong>；</p>
<ul>
<li>通过遍历判断 <span class="math inline">\(nums\)</span> 中各数字和
<span class="math inline">\(m\)</span>
做与运算的结果，可将数组拆分为两个子数组，并分别对两个子数组遍历求异或，则可得到两个只出现一次的数字</li>
</ul></li>
</ol>
<figure>
<img src="https://pic.leetcode-cn.com/1611415418-aCzGJI-Picture2.png" srcset="/img/loading.gif" lazyload alt="picture">
<figcaption aria-hidden="true">picture</figcaption>
</figure>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">singleNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>, m = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)         <span class="hljs-comment">// 1. 遍历异或</span><br>            n ^= num;<br>        <span class="hljs-keyword">while</span>((n &amp; m) *** <span class="hljs-number">0</span>)         <span class="hljs-comment">// 2. 循环左移，计算 m</span><br>            m &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums) &#123;       <span class="hljs-comment">// 3. 遍历 nums 分组</span><br>            <span class="hljs-keyword">if</span>(num &amp; m) x ^= num;   <span class="hljs-comment">// 4. 当 num &amp; m != 0</span><br>            <span class="hljs-keyword">else</span> y ^= num;          <span class="hljs-comment">// 4. 当 num &amp; m *** 0</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123;x, y&#125;;  <span class="hljs-comment">// 5. 返回出现一次的数字</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="剑指-offer-56---ii.-数组中数字出现的次数-iimedium"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指
Offer 56 - II. 数组中数字出现的次数 II「Medium」</a></h3>
<p>在一个数组 <code>nums</code>
中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [3,4,3,3]<br>输出：4<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<p>方法一：有限状态自动机</p>
<p>各二进制位的 位运算规则相同
，因此只需考虑一位即可。如下图所示，对于所有数字中的某二进制位 <span class="math inline">\(1\)</span> 的个数，存在 <span class="math inline">\(3\)</span> 种状态，即对 <span class="math inline">\(3\)</span> 余数为 <span class="math inline">\(0,
1, 2\)</span>.</p>
<ul>
<li>若输入二进制位 <span class="math inline">\(1\)</span>，则状态按照
<span class="math inline">\(0\rightarrow1\rightarrow2\rightarrow0\rightarrow\cdots\)</span>
顺序转换；</li>
<li>若输入二进制位 <span class="math inline">\(0\)</span>，则状态不变.</li>
</ul>
<figure>
<img src="https://pic.leetcode-cn.com/1603022900-GNKGMP-Picture2.png" srcset="/img/loading.gif" lazyload alt="picture">
<figcaption aria-hidden="true">picture</figcaption>
</figure>
<p>如下图所示，由于二进制只能表示 <span class="math inline">\(0,1\)</span>，因此需要使用两个二进制位来表示 <span class="math inline">\(3\)</span> 个状态。设此两位分别为 <span class="math inline">\(two,one\)</span>，则状态转换变为：<span class="math inline">\(00\rightarrow01\rightarrow10\rightarrow00\rightarrow\cdots\)</span></p>
<figure>
<img src="/Users/wanglei/Library/Application%20Support/typora-user-images/image-20210304232713519.png" srcset="/img/loading.gif" lazyload alt="image-20210304232713519">
<figcaption aria-hidden="true">image-20210304232713519</figcaption>
</figure>
<p>接下来，需要通过<strong>状态转换表</strong>导出<strong>状态转换的计算公式</strong>。首先回忆一下位运算特点，对于任意二进制位
<span class="math inline">\(x\)</span>，有：</p>
<ul>
<li>异或运算：<code>x ^ 0 = x</code> ， <code>x ^ 1 = ~x</code></li>
<li>与运算：<code>x &amp; 0 = 0</code> ，
<code>x &amp; 1 = x</code></li>
</ul>
<p><strong><em>计算 <span class="math inline">\(one\)</span>
方法</em></strong>：</p>
<p>设当前状态为 <span class="math inline">\(two,one\)</span>，此时输入二进制位 <span class="math inline">\(n\)</span>。如下图所示，通过对状态表的情况拆分，可推出
<span class="math inline">\(one\)</span> 的计算方法为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> two *** <span class="hljs-number">0</span>:<br>  <span class="hljs-keyword">if</span> n *** <span class="hljs-number">0</span>:<br>    one = one<br>  <span class="hljs-keyword">if</span> n *** <span class="hljs-number">1</span>:<br>    one = ~one<br><span class="hljs-keyword">if</span> two *** <span class="hljs-number">1</span>:<br>    one = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>引入 <strong>异或运算</strong> ，可将以上拆分简化为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> two *** <span class="hljs-number">0</span>:<br>    one = one ^ n<br><span class="hljs-keyword">if</span> two *** <span class="hljs-number">1</span>:<br>    one = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>引入 <strong>与运算</strong> ，可继续简化为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">one = one ^ n &amp; ~two<br></code></pre></td></tr></table></figure>
<figure>
<img src="https://pic.leetcode-cn.com/1603022900-qIFpAR-Picture4.png" srcset="/img/loading.gif" lazyload alt="p">
<figcaption aria-hidden="true">p</figcaption>
</figure>
<p><strong><em>计算 <span class="math inline">\(two\)</span>
方法</em></strong>：</p>
<p>由于是先计算 <span class="math inline">\(one\)</span> ，因此应在新
<span class="math inline">\(one\)</span> 的基础上计算 <span class="math inline">\(two\)</span>.</p>
<p>如下图所示，修改为新 <span class="math inline">\(one\)</span>
后，得到了新的状态图。观察发现，可以使用同样的方法计算 <span class="math inline">\(two\)</span>，即：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">two = two ^ n &amp; ~one<br></code></pre></td></tr></table></figure>
<figure>
<img src="https://pic.leetcode-cn.com/1603022900-hnUxBz-Picture5.png" srcset="/img/loading.gif" lazyload alt="picture">
<figcaption aria-hidden="true">picture</figcaption>
</figure>
<p>*****返回值*****：</p>
<p>以上是对数字的二进制中 “一位” 的分析，而 <code>int</code> 类型的其他
<span class="math inline">\(31\)</span>
位具有相同的运算规则，因此可将以上公式直接套用在 <span class="math inline">\(32\)</span> 位数上。</p>
<p>遍历完所有数字后，各二进制位都处于状态 <span class="math inline">\(00\)</span> 和状态 <span class="math inline">\(01\)</span> ( 取决于 “只出现一次的数字”
的各二进制位是 <span class="math inline">\(0\)</span> 还是 <span class="math inline">\(1\)</span> )，而此两状态是由 <span class="math inline">\(one\)</span> 来记录的 ( 此两状态下 <span class="math inline">\(twos\)</span> 恒为 <span class="math inline">\(0\)</span> )，因此返回 <span class="math inline">\(ones\)</span> 即可.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ones = <span class="hljs-number">0</span>, twos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> &amp;num : nums)&#123;<br>            ones = ones ^ num &amp; ~twos;<br>            twos = twos ^ num &amp; ~ones;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ones;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="剑指-offer-65.-不用加减乘除做加法easy"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">剑指
Offer 65. 不用加减乘除做加法「Easy」</a></h3>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/”
四则运算符号。</p>
<p><strong>示例:</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入: a = 1, b = 1<br>输出: 2<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>a</code>, <code>b</code> 均可能是负数或 <span class="math inline">\(0\)</span></li>
<li>结果不会溢出 <span class="math inline">\(32\)</span> 位整数</li>
</ul>
<blockquote>
<p>算法分析：</p>
<p>观察发现，<strong>无进位和</strong> 与 <strong>异或运算</strong>
规律相同，<strong>进位</strong> 和 <strong>与运算</strong> 规律相同 (
并需左移一位 ) 。因此，无进位和 <span class="math inline">\(n\)</span>
与进位 <span class="math inline">\(c\)</span> 的计算公式如下： <span class="math display">\[
\left\{
\begin{aligned}
&amp;n=a\bigoplus b &amp; 非进位和：异或运算\\
&amp;c=a~~\&amp;~~b~&lt;&lt;1 &amp; 进位：与运算+左移一位\\
\end{aligned}
\right.
\]</span> 和 ( <span class="math inline">\(s\)</span> ）=（非进位和
<span class="math inline">\(n\)</span> ）+（进位 <span class="math inline">\(c\)</span> ）。即可将 <span class="math inline">\(s=a+b\)</span> 转化为：<span class="math inline">\(s=a+b\Rightarrow s=n+c\)</span>.</p>
<p>循环求 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(c\)</span>，直至进位 <span class="math inline">\(c=0\)</span>；此时 <span class="math inline">\(s=n\)</span>，返回 <span class="math inline">\(n\)</span> 即可.</p>
<figure>
<img src="https://pic.leetcode-cn.com/9716b1a1ead21824b8216c7d54910bee4d838c011581f4e3d82a14f71cb392a1-Picture1.png" srcset="/img/loading.gif" lazyload alt="picture">
<figcaption aria-hidden="true">picture</figcaption>
</figure>
</blockquote>
<blockquote>
<p>Q ： 若数字 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 中有负数，则变成了减法，如何处理？ A ：
在计算机系统中，数值一律用 补码 来表示和存储。补码的优势：
加法、减法可以统一处理（CPU只有加法器）。因此，以上方法
同时适用于正数和负数的加法 。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 当进位为 0 时跳出</span><br>            <span class="hljs-type">int</span> c = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(a &amp; b) &lt;&lt; <span class="hljs-number">1</span>;  <span class="hljs-comment">// c = 进位</span><br>            a ^= b; <span class="hljs-comment">// a = 非进位和</span><br>            b = c; <span class="hljs-comment">// b = 进位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<hr>
<h1 id="chapter7-backtrack">Chapter7 BackTrack</h1>
<h3 id="n-皇后hard"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens/">51. N
皇后「Hard」</a></h3>
<p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code>
个皇后放置在 <code>n×n</code>
的棋盘上，并且使皇后彼此之间不能相互攻击。皇后彼此不能相互攻击，也就是说：<strong><em>任何两个皇后都不能处于同一条横行、纵行或斜线上</em></strong>。</p>
<p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n
皇后问题</strong> 的解决方案。</p>
<p>每一种解法包含一个不同的 <strong>n 皇后问题</strong>
的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code>
分别代表了皇后和空位。</p>
<p><strong>示例 1：</strong></p>
<figure>
<img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" srcset="/img/loading.gif" lazyload alt="picture">
<figcaption aria-hidden="true">picture</figcaption>
</figure>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：n = 4<br>输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]<br>解释：如上图所示，4 皇后问题存在两个不同的解法。<br></code></pre></td></tr></table></figure>
<blockquote>
<p>算法分析：</p>
<p><strong>方法一：基于集合的回溯</strong></p>
<p>为了判断一个位置所在的列和两条斜线上是否已经有皇后，使用三个集合
<span class="math inline">\(columns,~diagonals1,~diagonals2\)</span>
分别记录每一列以及两个方向的每条斜线上是否有皇后。</p>
<p>列的表示法很直观，一共有 <span class="math inline">\(N\)</span>
列，每一列的下标范围从 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(N-1\)</span>，使用列的下标即可明确表示每一列。</p>
<p>如何表示两个方向的斜线呢？对于每个方向的斜线，需要找到斜线上的每个位置的行下标与列下标之间的关系。</p>
<p>方向一的斜线为从左上到右下方向，同一条斜线上的每个位置满足<strong>行下标与列下标之差相等</strong>，例如
<span class="math inline">\((0,0)\)</span> 和 <span class="math inline">\((3,3)\)</span>
在同一条方向一的斜线上。因此使用行下标与列下标之差即可明确表示每一条方向一的斜线。</p>
<figure>
<img src="https://assets.leetcode-cn.com/solution-static/51/1.png" srcset="/img/loading.gif" lazyload alt="picture">
<figcaption aria-hidden="true">picture</figcaption>
</figure>
<p>方向二的斜线为从右上到左下方向，同一条斜线上的每个位置满足<strong>行下标与列下标之和相等</strong>，例如
<span class="math inline">\((3,0)\)</span> 和 <span class="math inline">\((1,2)\)</span>
在同一条方向二的斜线上。因此使用行下标与列下标之和即可明确表示每一条方向二的斜线。</p>
<figure>
<img src="https://assets.leetcode-cn.com/solution-static/51/2.png" srcset="/img/loading.gif" lazyload alt="picture">
<figcaption aria-hidden="true">picture</figcaption>
</figure>
<p>每次放置皇后时，对于每个位置判断其是否在三个集合中，如果三个集合都不包含当前位置，则当前位置是可以放置皇后的位置。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-keyword">auto</span> solutions = vector&lt;vector&lt;string&gt;&gt;();<br>        <span class="hljs-keyword">auto</span> queens = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">auto</span> columns = <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-keyword">auto</span> diagonals1 = <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-keyword">auto</span> diagonals2 = <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-built_in">backtrack</span>(solutions, queens, n, <span class="hljs-number">0</span>, columns, diagonals1, diagonals2);<br>        <span class="hljs-keyword">return</span> solutions;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt; &amp;solutions, vector&lt;<span class="hljs-type">int</span>&gt; &amp;queens, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, unordered_set&lt;<span class="hljs-type">int</span>&gt; &amp;columns, unordered_set&lt;<span class="hljs-type">int</span>&gt; &amp;diagonals1, unordered_set&lt;<span class="hljs-type">int</span>&gt; &amp;diagonals2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (row *** n) &#123;<br>            vector&lt;string&gt; board = <span class="hljs-built_in">generateBoard</span>(queens, n);<br>            solutions.<span class="hljs-built_in">push_back</span>(board);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (columns.<span class="hljs-built_in">find</span>(i) != columns.<span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> diagonal1 = row - i;<br>                <span class="hljs-keyword">if</span> (diagonals1.<span class="hljs-built_in">find</span>(diagonal1) != diagonals1.<span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> diagonal2 = row + i;<br>                <span class="hljs-keyword">if</span> (diagonals2.<span class="hljs-built_in">find</span>(diagonal2) != diagonals2.<span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                queens[row] = i;<br>                columns.<span class="hljs-built_in">insert</span>(i);<br>                diagonals1.<span class="hljs-built_in">insert</span>(diagonal1);<br>                diagonals2.<span class="hljs-built_in">insert</span>(diagonal2);<br>                <span class="hljs-built_in">backtrack</span>(solutions, queens, n, row + <span class="hljs-number">1</span>, columns, diagonals1, diagonals2);<br>                queens[row] = <span class="hljs-number">-1</span>;<br>                columns.<span class="hljs-built_in">erase</span>(i);<br>                diagonals1.<span class="hljs-built_in">erase</span>(diagonal1);<br>                diagonals2.<span class="hljs-built_in">erase</span>(diagonal2);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateBoard</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;queens, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> board = <span class="hljs-built_in">vector</span>&lt;string&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            string row = <span class="hljs-built_in">string</span>(n, <span class="hljs-string">&#x27;.&#x27;</span>);<br>            row[queens[i]] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            board.<span class="hljs-built_in">push_back</span>(row);<br>        &#125;<br>        <span class="hljs-keyword">return</span> board;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="子集-iihard"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集
II「Hard」</a></h3>
<p>给你一个整数数组 <code>nums</code>
，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按
<strong>任意顺序</strong> 排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [1,2,2]<br>输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入：nums = [0]<br>输出：[[],[0]]<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; t;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">bool</span> choosePre, <span class="hljs-type">int</span> cur, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur *** nums.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(t);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-literal">false</span>, cur + <span class="hljs-number">1</span>, nums);<br>        <span class="hljs-keyword">if</span> (!choosePre &amp;&amp; cur &gt; <span class="hljs-number">0</span> &amp;&amp; nums[cur - <span class="hljs-number">1</span>] *** nums[cur]) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        t.<span class="hljs-built_in">push_back</span>(nums[cur]);<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-literal">true</span>, cur + <span class="hljs-number">1</span>, nums);<br>        t.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>, nums);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<hr>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Programming/">#Programming</a>
      
        <a href="/tags/Algorithm/">#Algorithm</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/02/28/linux%20&amp;%20mac%20terminal/" title="Linux &amp; Mac terminal">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux &amp; Mac terminal</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/06/03/about%20C++%20STL/" title="About C++ STL">
                        <span class="hidden-mobile">About C++ STL</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://loktarogare.github.io/" target="_blank" rel="nofollow noopener"><span>Natsumi</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };
      </script>
    

  <script  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/DynamicRibbon.min.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":200,"height":400},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
