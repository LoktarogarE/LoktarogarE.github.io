

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar1.png">
  <link rel="icon" href="/img/avatar1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Natsumi">
  <meta name="keywords" content="">
  
    <meta name="description" content="网络服务模式与APIClient&#x2F;Server 模式因特网的基本通信模式 流模式(如: Web通信) 报文模式  C&#x2F;S模式基本概念一种基于网络的信息交互&#x2F;计算 分布模式网络软件被分为client和server 这两个名词直接指向通信中的两个进程，而不是主机 C&#x2F;S模式的关系和特点 对于C&#x2F;S模式 一定&#x3D;&#x3D;由客户发起请求，而服务器只被动响">
<meta property="og:type" content="article">
<meta property="og:title" content="网络服务模式&amp;API">
<meta property="og:url" content="http://www.mementos.top/2021/01/04/C:S%E4%B8%8EAPI/index.html">
<meta property="og:site_name" content="Natsumi&#39;s Mementos">
<meta property="og:description" content="网络服务模式与APIClient&#x2F;Server 模式因特网的基本通信模式 流模式(如: Web通信) 报文模式  C&#x2F;S模式基本概念一种基于网络的信息交互&#x2F;计算 分布模式网络软件被分为client和server 这两个名词直接指向通信中的两个进程，而不是主机 C&#x2F;S模式的关系和特点 对于C&#x2F;S模式 一定&#x3D;&#x3D;由客户发起请求，而服务器只被动响">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-03T16:15:31.000Z">
<meta property="article:modified_time" content="2022-03-01T11:32:38.842Z">
<meta property="article:author" content="Natsumi">
<meta property="article:tag" content="互联网原理">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>网络服务模式&amp;API - Natsumi&#39;s Mementos</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"www.mementos.top","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"❡"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Natsumi&#39;s Mementos</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                我
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="网络服务模式&amp;API">
              
            </span>

            
              <div class="mt-3">
  
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.5k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      47 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">网络服务模式&amp;API</h1>
            
            <div class="markdown-body">
              <h1 id="网络服务模式与API"><a href="#网络服务模式与API" class="headerlink" title="网络服务模式与API"></a>网络服务模式与API</h1><h2 id="Client-x2F-Server-模式"><a href="#Client-x2F-Server-模式" class="headerlink" title="Client&#x2F;Server 模式"></a>Client&#x2F;Server 模式</h2><h3 id="因特网的基本通信模式"><a href="#因特网的基本通信模式" class="headerlink" title="因特网的基本通信模式"></a>因特网的基本通信模式</h3><ul>
<li><h5 id="流模式-如-Web通信"><a href="#流模式-如-Web通信" class="headerlink" title="流模式(如: Web通信)"></a>流模式(如: Web通信)</h5></li>
<li><h5 id="报文模式"><a href="#报文模式" class="headerlink" title="报文模式"></a>报文模式</h5></li>
</ul>
<h3 id="C-x2F-S模式基本概念"><a href="#C-x2F-S模式基本概念" class="headerlink" title="C&#x2F;S模式基本概念"></a>C&#x2F;S模式基本概念</h3><h5 id="一种基于网络的信息交互-计算-分布模式"><a href="#一种基于网络的信息交互-计算-分布模式" class="headerlink" title="一种基于网络的信息交互/计算 分布模式"></a><code>一种基于网络的信息交互/计算 分布模式</code></h5><p><strong>网络软件被分为client和server 这两个名词直接指向通信中的两个进程，而不是主机</strong></p>
<h3 id="C-x2F-S模式的关系和特点"><a href="#C-x2F-S模式的关系和特点" class="headerlink" title="C&#x2F;S模式的关系和特点"></a>C&#x2F;S模式的关系和特点</h3><ul>
<li>对于C&#x2F;S模式 一定&#x3D;&#x3D;由客户发起请求，而服务器只被动响应&#x3D;&#x3D; $\rightarrow$ 请求&amp;应答 的分布计算(会话)模式</li>
<li>应用进程可以同时是服务器和客户</li>
</ul>
<blockquote>
<p>对于服务器软件 $\rightarrow$ <strong>主体框架 + 单个服务请求处理 + 并发服务请求处理</strong></p>
<ul>
<li>在共享计算机上首先运行，当系统启动时自动调用并不断运行</li>
<li>被动等待并且接受来自任意客户的通信请求 在大部分情况下 服务器软件提供单一的服务</li>
<li>可以同时处理多个远地&#x2F;本地客户的请求，但也需要强大的硬件和高级的操作系统支持  <strong>并发执行是服务器必须具备的</strong></li>
<li><strong>一个服务器软件包括 接收请求、处理单个请求和生成新线程三个部分</strong></li>
</ul>
</blockquote>
<blockquote>
<p>对于客户软件 $\rightarrow$ <strong>客户软件只是一个应用程序在进行服务器访问时的称呼</strong></p>
<ul>
<li>是任意的应用程序，它一般还能在本地做其它的事情</li>
<li>被用户调用 主动向远地服务器发起通信</li>
</ul>
</blockquote>
<h5 id="较复杂的C-x2F-S交互"><a href="#较复杂的C-x2F-S交互" class="headerlink" title="较复杂的C&#x2F;S交互"></a>较复杂的C&#x2F;S交互</h5><ul>
<li>客户应用不限制访问一个服务器，它需要同时和多个服务器通信。</li>
<li>服务器在提供服务的同时也需要作为另一个服务器的客户</li>
<li>服务器间可能会出现循环依赖</li>
</ul>
<p>在早期C&#x2F;S系统中 服务器计算机通常作为信息共享的设备部署(文件服务器、数据库服务器) 客户端自己来计算和跑程序</p>
<p>现今阶段 服务器是数据与业务功能处理中心 客户端则主要是UI界面+少量辅助功能处理</p>
<hr>
<h3 id="服务器识别"><a href="#服务器识别" class="headerlink" title="服务器识别"></a>服务器识别</h3><p><strong>Protocol Port Number 协议端口号 (OSI 术语是运输层服务访问点TSAP) 是TCP&#x2F;UDP给每种服务定义的标识</strong></p>
<p>对于源进程(它发起了请求)交付通信时通过 端口号明确自己的身份 还有接收方身份</p>
<p>收端进程会通过端口号来向目的进程交付。(很明显 这一切都发生在运输层)</p>
<p>对于服务器 通过端口号来明确提供的服务</p>
<h5 id="服务器端口号必须是唯一定义的-而客户端的端口号可以是临时指定的-只在本地有意义"><a href="#服务器端口号必须是唯一定义的-而客户端的端口号可以是临时指定的-只在本地有意义" class="headerlink" title="服务器端口号必须是唯一定义的 而客户端的端口号可以是临时指定的(只在本地有意义)"></a>服务器端口号必须是唯一定义的 而客户端的端口号可以是临时指定的(只在本地有意义)</h5><blockquote>
<p><strong>在使用TCP通信时 只有端口号是不够的 TCP的两个端点由Socket 插口 :(IP地址，端口号)定义</strong> (或者叫端地址)</p>
</blockquote>
<h5 id="协议端口号定义"><a href="#协议端口号定义" class="headerlink" title="协议端口号定义"></a>协议端口号定义</h5><p>TCP&#x2F;UDP定义一套16bit整数值 端口号被分为熟知端口号和一般端口号两列</p>
<p>熟知端口号 : FTP $\rightarrow$ 21    Telnet $\rightarrow$ 23    SMTP $\rightarrow$ 25    DNS $\rightarrow$ 53    TFTP $\rightarrow$ 69    HTTP $\rightarrow$ 80    SNMP $\rightarrow$ 161</p>
<p>一般端口号可以在规定区域内随意定义和分配</p>
<p>主要的端口号在1-225之间</p>
<p>端口号256-1023由Unix系统占用 </p>
<p>1024-5000作为临时端口 5000+不常出现 </p>
<h3 id="其他的交互模式"><a href="#其他的交互模式" class="headerlink" title="其他的交互模式"></a>其他的交互模式</h3><blockquote>
<p>C&#x2F;S模式比较简单 但容易造成网络瓶颈 并且负载不均衡问题也会使得服务器常常过载</p>
</blockquote>
<h5 id="P2P-peer-to-peer-：无中心服务器的流行网络技术-依赖所有参与者的计算能力和带宽-占到因特网流量的50-90"><a href="#P2P-peer-to-peer-：无中心服务器的流行网络技术-依赖所有参与者的计算能力和带宽-占到因特网流量的50-90" class="headerlink" title="P2P (peer to peer)：无中心服务器的流行网络技术 依赖所有参与者的计算能力和带宽 占到因特网流量的50%-90%"></a>P2P (peer to peer)：无中心服务器的流行网络技术 依赖所有参与者的计算能力和带宽 占到因特网流量的50%-90%</h5><hr>
<blockquote>
<p><strong>因特网通信模式和C&#x2F;S模式各自说明什么问题</strong></p>
<p>因特网通信模式：流模式和报文模式有着比较鲜明的特点，说明我们对因特网功能的需求是多样的，而网络技术也可以用不同的通信模式来满足不同的用户需求，但也说明想要实现稳定可能就需要牺牲效率，实现高效可能就保证不了可靠的传输。</p>
<p>C&#x2F;S模式：早期的C&#x2F;S模式以文件数据访问服务为主，客户程序也需要进行计算。而现今的C&#x2F;S模式在强大的服务器算力支撑下，客户端几乎不用承担计算任务，这说明C&#x2F;S模式的确得到了大规模的应用，所以服务器技术才能发展的如此迅速。</p>
</blockquote>
<blockquote>
<p><strong>简述客户软件和服务器软件主要特点</strong></p>
<p>服务器软件：</p>
<ol>
<li>专门提供某类服务的程序，一定可以并行的处理多个客户请求。</li>
<li>运行在共享计算机上，只要系统不关闭，就一直运行。</li>
<li>被动等待并且接收来自任意用户的通信请求</li>
<li>一般需要较强大的硬件和高级的操作系统支持</li>
</ol>
<p>客户软件：</p>
<ol>
<li>只有在进行通信时才被称为客户，它也可能可以在本地进行其他的计算并且实现其他功能。</li>
<li>由用户调用，在用户本地计算机上运行，在用户有需要时主动向远地服务器发起通信请求。</li>
<li>可以与多个服务器通信 并且一般不需要特殊硬件和复杂的操作系统</li>
</ol>
</blockquote>
<blockquote>
<p><strong>一个服务器软件通常需要包括哪些主要的功能部分？</strong></p>
<p>一个服务器软件主要包括：等待接收请求、处理单个请求和生成新线程</p>
</blockquote>
<blockquote>
<p><strong>为什么通常服务器端口号是唯一定义的，而客户端的端口号可以临时指定？</strong></p>
<p>服务器端口号唯一定义是为了让所有的客户都能正确找到它。因为C&#x2F;S交互的身份问题，客户端的端口号只需要做到不和自己同时运行的其他进程混淆即可，临时指定端口号也可以实现同一个端口号的复用(当某个客户软件不运行时就不占用端口号了)</p>
</blockquote>
<hr>
<h1 id="API-Application-Program-Interface"><a href="#API-Application-Program-Interface" class="headerlink" title="API [Application Program Interface]"></a>API [Application Program Interface]</h1><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h5 id="是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节"><a href="#是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节" class="headerlink" title="是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节"></a><code>是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节</code></h5><ul>
<li><strong>在应用从操作系统中获得相关服务时 通过调用API 将任务和控制权都交给操作系统，在执行完毕后，操作系统会交还控制权</strong></li>
<li>网络通信和数据交互调用API $\rightarrow$ 网络API(他是应用程序和TCP&#x2F;IP协议通信交互的接口)</li>
<li><strong>API造就了 应用和网络 的一体 和 分离 $\rightarrow$  在使用时一体，在开发时分离</strong></li>
</ul>
<p>互联网中主要有两类API 伯克利版 $\rightarrow$ Socket API 以及 A&amp;AT版 $\rightarrow$ TLI[Transport Lay Interface]</p>
<p>其中Socket API被主流操作系统使用，成为标准。</p>
<h3 id="Socket-API"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h3><ul>
<li>它来自Unix 由于Unix一切皆文件(open - read - write - close)的哲学影响，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</li>
<li><strong>在通信前 APP要向OS申请一个 套接字(也叫通信描述符)，OS返回一个小的整形数作为描述符来识别这个套接字 在通信结束后，这个代表特殊参数的套接字会被回收</strong></li>
<li><strong>套接字API 定义并调用多个函数来确定参数和选项 (创建套接字(返回描述符)，然后调用这些函数来完成对接)</strong></li>
</ul>
<h3 id="实现套接字API的函数"><a href="#实现套接字API的函数" class="headerlink" title="实现套接字API的函数"></a>实现套接字API的函数</h3><ol>
<li><p><code>Socket</code>函数 <strong>&#x2F;&#x2F; 创建套接字并返回整型描述符</strong></p>
<p>$Descriptor &#x3D; socket(pf,type,protocol)$ </p>
<p>pf $\rightarrow$ ProtocolFamily:协议栈(TCP&#x2F;IP)  Type $\rightarrow$ 连接&#x2F;无连接 protocol $\rightarrow$ 具体协议</p>
</li>
<li><p><code>Bind</code> 函数 <strong>&#x2F;&#x2F; 赋予套接字特定的端地址，实现socket和端地址的联编</strong> &#x3D;&#x3D;联编相当于 绑定&#x3D;&#x3D;</p>
<p>$Bind(socket,locaaddr,addrlen)$ <strong>&#x2F;&#x2F; 不建立连接的话，bind函数之后就可以交互数据了</strong></p>
<p>loca addr $\rightarrow$ 本地端地址的一般socket地址描述结构。</p>
</li>
<li><p><code>Close</code> 函数 <strong>&#x2F;&#x2F; 告诉系统终止对一个套接字的使用(释放这个套接字)</strong></p>
<p>$close(socket)$ <strong>&#x2F;&#x2F; 如果面向连接，则先关闭连接，再回收套接字</strong></p>
</li>
<li><p><code>Listen</code> 函数 **&#x2F;&#x2F; (<em>只有面向连接使用) 套接字被设置为被动模式，等待连接请求</em>*</p>
<p>$Listen(socket,queuesize)$ Queue size $\rightarrow$ 客户请求队列长度</p>
</li>
<li><p><code>Connect</code>函数 <strong>&#x2F;&#x2F; 面向连接时使用，启动与服务器的连接(前提是服务器已经调用了listen和accept)</strong></p>
<p>$connect(socket,saddress,saddresslen)$  &#x2F;&#x2F;在UDP时 也可以使用 此时完成socket和目的服务器端地址联编</p>
</li>
<li><p><code>Accept</code>函数 **&#x2F;&#x2F; (<em>只有面向连接使用) 确定客户端的地址，确认连接，这时需要创建一个新的套接字，通信结束后回收</em>*</p>
<p>$newsock &#x3D; accept(caddress,caddresslen)$</p>
<p>c address$\rightarrow$按照socket地址结构描述的<strong>客户端IP地址</strong></p>
</li>
<li><p><code>Send</code>函数 <strong>&#x2F;&#x2F; 客户和服务器使用这个函数来发送消息</strong></p>
<p>$send(socket,data,length,flags)$ </p>
<p>data $\rightarrow$ 内存待发数据的地址    length $\rightarrow$ 数据字节数    flags $\rightarrow$ 特殊选项(用来调试系统)</p>
<p>$sendto(socket,data,length,flags,destaddress,addresslen)$ <strong>&#x2F;&#x2F;无连接使用sendto函数</strong></p>
<p>$sendmgs(socket,mgsstruct,flags)$ 作用和sendto类似</p>
</li>
<li><p><code>Recv</code>函数 <strong>&#x2F;&#x2F; 客户和服务器从套接字接收数据</strong></p>
<p>$recv(socket,buffer,length,flags)$</p>
<p>buffer $\rightarrow$ 内存中收到数据的地址    length $\rightarrow$ 缓冲区大小    flags$\rightarrow$特殊选项</p>
<p>$recvfrom(socket,buffer,length,flags,sndraddr,saddrlen)$ <strong>&#x2F;&#x2F;无连接使用recvfrom函数</strong></p>
<p>$recvmgs(socket,mgsstrucct,flags)$ 作用和recvfrom类似 <strong>sendmgs和recvmgs是原函数的简化参数版本</strong></p>
</li>
<li><p>其他</p>
<ol>
<li>$write(socket,buffer,length) &#x2F; read(socket,buffer,length)$ Unix的I&#x2F;O一般操作 在连接之后和send-recv一样</li>
<li>$getpeername$ <strong>&#x2F;&#x2F;调用accept接收连接请求后调用这个函数获取客户端地址</strong></li>
<li>$gethostname$ <strong>&#x2F;&#x2F;调用这个函数获取本机的完整信息，可以是域名，也可能是其他</strong></li>
<li>$ gethostbyname$ <strong>&#x2F;&#x2F;知道域名时 调用这个函数获取本机IP地址</strong></li>
<li>$getprotobyname$ <strong>&#x2F;&#x2F;知道域名时 调用这个函数获取 socket使用的二进制形式IP地址</strong></li>
<li>$gethostbyaddr$ <strong>&#x2F;&#x2F;知道IP地址，获取域名     这两个函数在API中完成IP地址和域名的转换</strong></li>
</ol>
</li>
</ol>
<p>备注：</p>
<ol>
<li><code>Accept</code>确认连接地址之后 需要创建一个新的socket (可以根据C&#x2F;S模式理解成，服务器创建新线程)，只要连接建立，原来的套接字就会用来和下一个客户进行连接。</li>
<li>服务器可以并发，服务器创建并发线程时套接字也会产生一个副本，这样就实现了并发线程都能调用所有的套接字功能</li>
<li><code>Listen</code>和 <code>Accept</code>函数是<em><strong>面向连接通信时</strong></em>服务器必须进行的调用</li>
</ol>
<h3 id="套接字API与C-x2F-S"><a href="#套接字API与C-x2F-S" class="headerlink" title="套接字API与C&#x2F;S"></a>套接字API与C&#x2F;S</h3><p>刚刚的程序每次收到请求都会打印一段信息(建立连接)。 </p>
<p>可以注意的是 <em><strong>客户端不需要 socket和端地址联编</strong></em> 因为客户端的端口号可以是临时指定的(端地址也就相当于是可变的)，如果客户端需要向服务器发送报文，那另说。</p>
<hr>
<blockquote>
<p><strong>API是否由TCP&#x2F;IP所定义，目前互联网最常用的API体系是什么。</strong></p>
<p>不是。API是宏观的概念，而网络中使用的API主要分为Socket API(它由Berkeley UNIX定义)和TLI ，其中Socket API被主流的操作系统使用，所以Socket API是互联网最常用的API体系。</p>
</blockquote>
<blockquote>
<p><strong>API接口与协议端口、插口有什么区别？</strong></p>
<p>在网络中使用的API，指的是应用程序和TCP&#x2F;IP协议通信交互的接口，它是经过抽象后定义的一组(函数)操作，由操作系统来调用它。API使得应用进程和TCP&#x2F;IP(运输层)实现透明。</p>
<p>协议端口是TCP&#x2F;UDP给每种服务定义的标识，在进程进行交互时协助对接。协议端口使得两端的操作系统都能识别身份和服务。</p>
</blockquote>
<blockquote>
<p><strong>服务器套接字API有哪些专门的函数（过程）；对一个面向连接的TCP通信，服务器端套接字API的实现要经过那些过程调用？</strong></p>
<ol>
<li>socket    bind    listen    accept    connect    close    send(sendto)    recv(recvfrom)    getpeername    gethostname    gethostbyname    getprotobyname    gethostbyaddr等</li>
<li>对于面向连接 服务器端API的实现要经过<ol>
<li>getprotobyname 获取IP地址</li>
<li>Socket 建立套接字</li>
<li>bind (socket和端口号联编)</li>
<li>listen 套接字设置为被动模式，等待连接请求</li>
<li>accept 确定客户端的地址，确认连接，并且返回一个新创建的套接字 </li>
<li>send&amp;recv 发送和接收数据</li>
<li>close 关闭连接 回收套接字</li>
</ol>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>对一个非连接通信，客户端套接字为什么不必和本地端地址绑定？</strong></p>
<p>因为客户端的端口号可以是临时指定的(端地址也就相当于是可变的)，这个端地址仅仅具有本地的意义，由于端地址已经可以在本地唯一的标识进程，即使不绑定套接字OS和TCP&#x2F;IP也都能通过端地址来找到应用进程。</p>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E4%BA%92%E8%81%94%E7%BD%91%E5%8E%9F%E7%90%86/">互联网原理</a>
                    
                  </div>
                
              </div>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/01/04/DNS-&amp;-FTP/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">DNS</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/01/04/%E5%9B%A0%E7%89%B9%E7%BD%91%E8%B7%AF%E7%94%B1%E4%B8%8E%E5%8D%8F%E8%AE%AE/">
                        <span class="hidden-mobile">因特网路由与协议</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://loktarogare.github.io/" target="_blank" rel="nofollow noopener"><span>Natsumi</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
